[
    {
        "prefix": "abs",
        "body": "abs(${1:number})",
        "documentation": " Absolute-value function. The absolute value of a number is\n the number without its sign.\n\n**USAGE:**\n*numeric abs(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "acos",
        "body": "acos(${1:number})",
        "documentation": " Returns the angle whose cosine is the value passed as the argument.\n\n**USAGE:**\n*numeric acos(number)*\n\n**PARAMETERS:**\n\n*number (numeric)* - The value to be converted into an angle. Must be between -1 and 1.\n"
    },
    {
        "prefix": "addSOAPRequestHeader",
        "body": "addSOAPRequestHeader(${1:webservice}, ${2:namespace}, ${3:name}, ${4:value})",
        "documentation": "Adds a SOAP header to a web service request before making the request.\n\n**USAGE:**\n*boolean addSOAPRequestHeader(webservice, namespace, name, value [, mustunderstand])*\n\n**PARAMETERS:**\n\n*webservice (string)* - A webservice object as returned from the cfobject tag\n or the createobject function\n\n*namespace (string)* - Namespace for the SOAP header\n\n*name (string)* - Name of SOAP header\n\n*value (string)* - the value for the SOAP header; this can be a CFML XML value.\n\n*mustunderstand (boolean)* - The mustUnderstand attribute indicates whether processing of the header is optional or mandatory.\nThis basically translates to the node trying to find an appropriate handler that matches the header\nand proceed with processing the message in a manner consistent with its specification. If it can't find an appropriate handler\nit must return an error and stop further processing. If mustUnderstand is set to `true`\nthe node is not allowed to ignore it.. **Default:** *false*.\n"
    },
    {
        "prefix": "addSOAPResponseHeader",
        "body": "addSOAPResponseHeader(${1:namespace}, ${2:name}, ${3:value})",
        "documentation": "Adds a SOAP response header to a web service response. Call only from within a CFC web service function that is processing a request as a SOAP web service.\n\n**USAGE:**\n*boolean addSOAPResponseHeader(namespace, name, value [, mustunderstand])*\n\n**PARAMETERS:**\n\n*namespace (string)* - A webservice object as returned from the cfobject tag or the createobject function\n\n*name (string)* - Name of the SOAP header\n\n*value (string)* - Value of the SOAP header\n\n*mustunderstand (boolean)* - The mustUnderstand attribute indicates whether processing of the header is optional or mandatory.\nThis basically translates to the node trying to find an appropriate handler that matches the header\nand proceed with processing the message in a manner consistent with its specification. If it can't find an appropriate handler\nit must return an error and stop further processing. If mustUnderstand is set to `true`\nthe node is not allowed to ignore it.\n"
    },
    {
        "prefix": "ajaxLink",
        "body": "ajaxLink(${1:url})",
        "documentation": " Causes an HTML href attribute to display link results in the current Ajax container.\n\n**USAGE:**\n*void ajaxLink(url)*\n\n**PARAMETERS:**\n\n*url (string)* - The URL of the link.\n"
    },
    {
        "prefix": "ajaxOnLoad",
        "body": "ajaxOnLoad(${1:functionname})",
        "documentation": " Causes the specified JavaScript function to run when the page loads.\n\n**USAGE:**\n*void ajaxOnLoad(functionname)*\n\n**PARAMETERS:**\n\n*functionname (string)* - The name of the function to run when the page loads.\n"
    },
    {
        "prefix": "applicationStartTime",
        "body": "applicationStartTime()",
        "documentation": "Provides information about the time when the current application scope was created.\n\n**USAGE:**\n*date applicationStartTime()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "applicationStop",
        "body": "applicationStop()",
        "documentation": " stops current application\n\n**USAGE:**\n*void applicationStop()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "array",
        "body": "array()",
        "documentation": "Creates a new array populated with any arguments that have been passed to the function.\n\n**USAGE:**\n*array array( [values])*\n\n**PARAMETERS:**\n\n*values (any)* - One or more values that can be used in the initialization of the array.\n"
    },
    {
        "prefix": "arrayAppend",
        "body": "arrayAppend(${1:array}, ${2:value})",
        "documentation": "Appends an element to the end of an array.\n\n**USAGE:**\n*boolean arrayAppend(array, value [, merge])*\n\n**PARAMETERS:**\n\n*array (array)* - The array to which the element should be appended.\n\n*value (any)* - The element to append. Can be any type.\n\n*merge (boolean)* - CF10+ When true appends array elements individually to the specified array. When false (default), the new array is appended as a single element. **Values:** *true, false*.\n"
    },
    {
        "prefix": "arrayAvg",
        "body": "arrayAvg(${1:array})",
        "documentation": " Calculates the average of the values in an array.\n All elements in the array must contain values that can be\n automatically converted to numeric.\n\n**USAGE:**\n*numeric arrayAvg(array)*\n\n**PARAMETERS:**\n\n*array (array)* - An array which to determine average\n"
    },
    {
        "prefix": "arrayClear",
        "body": "arrayClear(${1:array})",
        "documentation": " Removes all elements from an array.\n\n**USAGE:**\n*boolean arrayClear(array)*\n\n**PARAMETERS:**\n\n*array (array)* - An array name or variable name\n"
    },
    {
        "prefix": "arrayContains",
        "body": "arrayContains(${1:array}, ${2:object})",
        "documentation": "Used to determine if an object is in the given array, case sensitive. Adobe CF and OpenBD return boolean. Lucee / Railo returns the numeric index if the object is found, 0 if not.\n\n**USAGE:**\n*boolean arrayContains(array, object [, substringMatch])*\n\n**PARAMETERS:**\n\n*array (array)* - The array in which to search.\n\n*object (any)* - The object to search for in the array.\n\n*substringMatch (any)* -  Lucee4.5+ If set to true then a substring match will also return an array position. This will only work with simple values. Passing true with complex objects will throw an exception.. **Default:** *false*.\n"
    },
    {
        "prefix": "arrayContainsNoCase",
        "body": "arrayContainsNoCase(${1:array}, ${2:object})",
        "documentation": "Used to determine if an object is in the given array, case insensitive.\n\n**USAGE:**\n*boolean arrayContainsNoCase(array, object)*\n\n**PARAMETERS:**\n\n*array (array)*\n\n*object (any)*\n"
    },
    {
        "prefix": "arrayDelete",
        "body": "arrayDelete(${1:array}, ${2:object})",
        "documentation": "Deletes the first element in an array that matches the value of `object`.\nThe search is case sensitive.\nReturns `true` if the element was found and removed.\nThe array will be resized, so that the deleted element doesn't leave a gap.\n\n**USAGE:**\n*boolean arrayDelete(array, object [, scope])*\n\n**PARAMETERS:**\n\n*array (array)*\n\n*object (any)* - A string, numeric or boolean value on which to search. Case sensitive.\n\n*scope (string)* - Lucee4.5+ remove one (default) or all occurances of the object. **Default:** *one*. **Values:** *one, all*.\n"
    },
    {
        "prefix": "arrayDeleteAt",
        "body": "arrayDeleteAt(${1:array}, ${2:position})",
        "documentation": "Deletes the element at `position` from an array\nThe array will be resized, so that the deleted element doesn't leave a gap.\n\n**USAGE:**\n*boolean arrayDeleteAt(array, position)*\n\n**PARAMETERS:**\n\n*array (array)* - The array that the element will be deleted from.\n\n*position (numeric)* - The numeric position of the element. Remember that ColdFusion arrays start at 1 not 0.\n"
    },
    {
        "prefix": "arrayDeleteNoCase",
        "body": "arrayDeleteNoCase(${1:array}, ${2:object})",
        "documentation": "Deletes the first element in an array that matches the value of `object`.\nThe search is case insensitive.\nReturns `true` if the element was found and removed.\nThe array will be resized, so that the deleted element doesn't leave a gap.\n\n**USAGE:**\n*boolean arrayDeleteNoCase(array, object)*\n\n**PARAMETERS:**\n\n*array (array)*\n\n*object (any)* - A string, numeric or boolean value on which to search. Case insensitive.\n"
    },
    {
        "prefix": "arrayEach",
        "body": "arrayEach(${1:array}, ${2:closure})",
        "documentation": "Used to iterate over an array and run the function closure for each item in the array.\n\n**USAGE:**\n*void arrayEach(array, closure [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*array (array)*\n\n*closure (function)* - function / closure with the signature: any function (any item, [numeric index], [array array]) - will be executed once per item in the array\n\n*parallel (boolean)* - Railo only option, true or false if the items can be executed in parallel. **Default:** *false*. **Values:** *true, false*.\n\n*maxThreads (boolean)* - Railo only option, the number of threads to use when parallel = true. **Default:** *20*.\n"
    },
    {
        "prefix": "arrayEvery",
        "body": "arrayEvery(${1:array}, ${2:closure})",
        "documentation": "returns true if every closure returns true, otherwise false\n\n**USAGE:**\n*boolean arrayEvery(array, closure [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*array (array)*\n\n*closure (function)* - A function / closure with the signature: `boolean function (any item, [numeric index], [array array])`\n\n*parallel (boolean)* - When `true` the items can be executed in parallel. **Default:** *false*. **Values:** *true, false*.\n\n*maxThreads (boolean)* - The number of threads to use when `parallel=true`. **Default:** *20*.\n"
    },
    {
        "prefix": "arrayFilter",
        "body": "arrayFilter(${1:array}, ${2:function})",
        "documentation": "Used to filter an array to items for which the closure function returns true.\n\n**USAGE:**\n*array arrayFilter(array, function [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*array (array)*\n\n*function (function)* - Inline closure function executed for each element in the array. Returns true if the array element should be included in the filtered array. Support for passing the original array to the closure function added in CF11 Update 5.\n\n*parallel (boolean)* - Lucee only option, true or false if the items can be executed in parallel. **Default:** *false*. **Values:** *true, false*.\n\n*maxThreads (boolean)* - Lucee only option, the number of threads to use when parallel = true. **Default:** *20*.\n"
    },
    {
        "prefix": "arrayFind",
        "body": "arrayFind(${1:array}, ${2:object})",
        "documentation": " These functions searches the array for the specified object. Returns the index in the array of the first match, or 0 if there is no match.\n\n**USAGE:**\n*numeric arrayFind(array, object)*\n\n**PARAMETERS:**\n\n*array (array)* - The array you are searching.\n\n*object (any)* - The value you are looking for in the array. CF10+ or Lucee4.5+ support passing a closure function in this argument as well.\n"
    },
    {
        "prefix": "arrayFindAll",
        "body": "arrayFindAll(${1:array}, ${2:object or closure})",
        "documentation": "Searches an array for all positions of a specified object. The function searches for simple objects such as strings and numbers or for complex objects such as structures. When the second parameter is a simple object, string searches are case-sensitive\n\n**USAGE:**\n*array arrayFindAll(array, object or closure)*\n\n**PARAMETERS:**\n\n*array (array)* - The source array to search through\n\n*object or closure (variableName)* - If string, case sensitive value to search for; if closure, use signature function (item, index, array) : boolean\n"
    },
    {
        "prefix": "arrayFindAllNoCase",
        "body": "arrayFindAllNoCase(${1:array}, ${2:object or closure})",
        "documentation": "Searches an array for all positions of a specified object. The function searches for simple objects such as strings and numbers or for complex objects such as structures. When the second parameter is a simple object, string searches are case-sensitive\n\n**USAGE:**\n*array arrayFindAllNoCase(array, object or closure)*\n\n**PARAMETERS:**\n\n*array (array)* - The source array to search through\n\n*object or closure (variableName)* - If string, case insensitive value to search for; if closure, use signature function (item, index, array) : boolean\n"
    },
    {
        "prefix": "arrayFindNoCase",
        "body": "arrayFindNoCase(${1:array}, ${2:object})",
        "documentation": " These functions performs a case-insensitive search in the array for the specified object. Returns the array index of the first match; 0 if not found.\n\n**USAGE:**\n*numeric arrayFindNoCase(array, object)*\n\n**PARAMETERS:**\n\n*array (array)* - The array to search\n\n*object (any)* - The value you are looking for in the array.\n"
    },
    {
        "prefix": "arrayFirst",
        "body": "arrayFirst(${1:array})",
        "documentation": "Returns the first item from an array.\n\n**USAGE:**\n*any arrayFirst(array)*\n\n**PARAMETERS:**\n\n*array (array)*\n"
    },
    {
        "prefix": "arrayIndexExists",
        "body": "arrayIndexExists(${1:array}, ${2:index})",
        "documentation": "Returns whether there exists an item in the array at the selected index.\n\n**USAGE:**\n*boolean arrayIndexExists(array, index)*\n\n**PARAMETERS:**\n\n*array (array)*\n\n*index (numeric)*\n"
    },
    {
        "prefix": "arrayInsertAt",
        "body": "arrayInsertAt(${1:array}, ${2:position}, ${3:value})",
        "documentation": " Inserts a value at the specified position in the array. If\n the element is inserted before the end of the array, ColdFusion\n shifts the positions of all elements with a higher index to make room.\n\n**USAGE:**\n*boolean arrayInsertAt(array, position, value)*\n\n**PARAMETERS:**\n\n*array (array)* - The array which will have the new element inserted.\n\n*position (numeric)* - The numerical index in the array where the new element will be inserted.\n Must be less than or equal to the length of the array.\n Remember ColdFusion arrays start at 1 not 0.\n\n*value (any)* - The new element to insert.\n"
    },
    {
        "prefix": "arrayIsDefined",
        "body": "arrayIsDefined(${1:array}, ${2:elementIndex})",
        "documentation": " Determines whether an array element is defined.\n\n**USAGE:**\n*boolean arrayIsDefined(array, elementIndex)*\n\n**PARAMETERS:**\n\n*array (string)* - The array object\n\n*elementIndex (numeric)* - The key value/index to check.\n"
    },
    {
        "prefix": "arrayIsEmpty",
        "body": "arrayIsEmpty(${1:array})",
        "documentation": " Determines whether an array is empty. Equivalent to arrayLen().\n Calling this function on an array with 10 undefined elements\n will return false.\n CFML MX: this function can be used on XML objects.\n\n**USAGE:**\n*boolean arrayIsEmpty(array)*\n\n**PARAMETERS:**\n\n*array (array)* - An array name or variable name\n"
    },
    {
        "prefix": "arrayLast",
        "body": "arrayLast(${1:array})",
        "documentation": "Returns the first item from an array. Throws an error if the array is empty.\n\n**USAGE:**\n*any arrayLast(array)*\n\n**PARAMETERS:**\n\n*array (array)*\n"
    },
    {
        "prefix": "arrayLen",
        "body": "arrayLen(${1:array})",
        "documentation": " Determines the number of elements in an array.\n CFML MX: this function can be used on child XML objects.\n\n**USAGE:**\n*numeric arrayLen(array)*\n\n**PARAMETERS:**\n\n*array (array)* - An array which to determine length\n"
    },
    {
        "prefix": "arrayMap",
        "body": "arrayMap(${1:array}, ${2:function})",
        "documentation": "Iterates over every entry of the array and calls the closure function to work on the element of the array. The returned value will be set at the same index in a new array and the new array will be returned\n\n**USAGE:**\n*array arrayMap(array, function)*\n\n**PARAMETERS:**\n\n*array (array)* - The input array\n\n*function (any)* - Closure or a function reference that will be called for each of the iteration. The arguments passed to the callback are\r\n\r\nitem: item in the array\r\nindex: index of the array\r\narray: a reference of the original arrray\n"
    },
    {
        "prefix": "arrayMax",
        "body": "arrayMax(${1:array})",
        "documentation": " Returns the largest numeric value in an array. If the array\n parameter value is an empty array, returns zero.\n All elements must contain values that can be automatically\n converted to numeric values.\n\n**USAGE:**\n*numeric arrayMax(array)*\n\n**PARAMETERS:**\n\n*array (array)* - An array or variable name\n"
    },
    {
        "prefix": "arrayMedian",
        "body": "arrayMedian(${1:array})",
        "documentation": "Calculates the Median value of items in an array. All elements in the array must contain values that can be converted to numeric.\n\n**USAGE:**\n*numeric arrayMedian(array)*\n\n**PARAMETERS:**\n\n*array (array)*\n"
    },
    {
        "prefix": "arrayMerge",
        "body": "arrayMerge(${1:array1}, ${2:array2})",
        "documentation": "This function creates a new array with data from the two passed arrays. To add all the data from one array into another without creating a new array see the built in function ArrayAppend(arr1, arr2, true).\n\n**USAGE:**\n*array arrayMerge(array1, array2 [, leaveIndex])*\n\n**PARAMETERS:**\n\n*array1 (array)*\n\n*array2 (array)*\n\n*leaveIndex (boolean)*\n"
    },
    {
        "prefix": "arrayMid",
        "body": "arrayMid(${1:array}, ${2:start})",
        "documentation": "Extracts a sub array from an existing array.\n\n**USAGE:**\n*array arrayMid(array, start [, count])*\n\n**PARAMETERS:**\n\n*array (array)* - Array to extract data from\n\n*start (numeric)* - The position of the first element to retrieve\n\n*count (numeric)* - The number of elements to extract. If not set, all elements up to the end of the array will be returned.\n"
    },
    {
        "prefix": "arrayMin",
        "body": "arrayMin(${1:array})",
        "documentation": " Returns the smallest numeric value in an array. If the array\n parameter value is an empty array, returns zero.\n All elements must contain values that can be automatically\n converted to numeric values.\n\n**USAGE:**\n*numeric arrayMin(array)*\n\n**PARAMETERS:**\n\n*array (array)* - An array or variable name\n"
    },
    {
        "prefix": "arrayNew",
        "body": "arrayNew(${1|1,2,3|})",
        "documentation": "Creates an array of 1-3 dimensions. Index array elements with square brackets: [ ]. CFML arrays expand dynamically as data is added.\n\n**USAGE:**\n*array arrayNew(dimension [, unsynchronized])*\n\n**PARAMETERS:**\n\n*dimension (numeric)*. **Default:** *1*. **Values:** *1, 2, 3*.\n\n*unsynchronized (boolean)* - CF2016+ When true creates an unsynchronized array. Unsynchronized arrays are not thread safe so they should not be used within shared scopes (application, session, etc). According to the CF2016 Performance whitepaper: Unsynchronized arrays are about 93% faster due to lock avoidance. **Values:** *true, false*.\n"
    },
    {
        "prefix": "arrayPrepend",
        "body": "arrayPrepend(${1:array}, ${2:value})",
        "documentation": " Inserts an array element at the beginning of an array\n and shifts the positions of the existing elements to\n make room.\n\n**USAGE:**\n*boolean arrayPrepend(array, value)*\n\n**PARAMETERS:**\n\n*array (array)*\n\n*value (any)*\n"
    },
    {
        "prefix": "arrayReduce",
        "body": "arrayReduce(${1:array}, ${2:function})",
        "documentation": "Iterates over every entry of the array and calls the closure to work on the elements of the array. This function will reduce the array to a single value and will return the value.\n\n**USAGE:**\n*any arrayReduce(array, function [, initialValue])*\n\n**PARAMETERS:**\n\n*array (array)* - the input array\n\n*function (function)* - Closure or a function reference that will be called for each of the iteration. The arguments passed to the callback are\r\n\r\nresult: result of the reduce operation after the previous iteration\r\nitem: item in the array\r\nindex : current index for the iteration\r\narray : reference of the original array\n\n*initialValue (any)* - Initial value which will be used for the reduce operation. The type is any.\n"
    },
    {
        "prefix": "arrayResize",
        "body": "arrayResize(${1:array}, ${2:size})",
        "documentation": " Resets an array to a specified minimum number of elements.\n This can improve performance, if used to size an array to its\n expected maximum. For more than 500 elements, use arrayResize\n immediately after using the ArrayNew tag.\n\n**USAGE:**\n*boolean arrayResize(array, size)*\n\n**PARAMETERS:**\n\n*array (array)*\n\n*size (numeric)*\n"
    },
    {
        "prefix": "arrayReverse",
        "body": "arrayReverse(${1:array})",
        "documentation": "Returns an array with all of the elements reversed. The value in [0] within the input array will then exist in [n] in the output array, where n is the amount of elements in the array minus one.\n\n**USAGE:**\n*array arrayReverse(array)*\n\n**PARAMETERS:**\n\n*array (array)* - The array to reverse\n"
    },
    {
        "prefix": "arraySet",
        "body": "arraySet(${1:array}, ${2:start_pos}, ${3:end_pos}, ${4:value})",
        "documentation": " In a one-dimensional array, sets the elements in a specified\n index range to a value. Useful for initializing an array after\n a call to ArrayNew.\n\n**USAGE:**\n*boolean arraySet(array, start_pos, end_pos, value)*\n\n**PARAMETERS:**\n\n*array (array)*\n\n*start_pos (numeric)*\n\n*end_pos (numeric)*\n\n*value (any)*\n"
    },
    {
        "prefix": "arraySlice",
        "body": "arraySlice(${1:array}, ${2:offset})",
        "documentation": "Returns a new array, from the start position up to the count of elements.\n\n**USAGE:**\n*array arraySlice(array, offset [, length])*\n\n**PARAMETERS:**\n\n*array (array)* - Name of the array that you want to slice\n\n*offset (numeric)* - Specifies the position from which to slice the array. Negative value indicates that the array is sliced, with sequence starting from array's end.\n\n*length (numeric)* - Maximum elements to slice. **Default:** *Length of Array*.\n"
    },
    {
        "prefix": "arraySome",
        "body": "arraySome(${1:array}, ${2:closure})",
        "documentation": "Calls a given closure/function with every element in a given array and returns true if one of the closure calls returns true\n\n**USAGE:**\n*boolean arraySome(array, closure [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*array (array)* - Array to iterate\n\n*closure (function)* - Function/closure that implements the following constructor [function(any value[,numeric index,array array]):boolean].\n\n*parallel (boolean)* - Execute closures parallel\n\n*maxThreads (numeric)* - Maximum number of threads executed, ignored when argument \"parallel\" is set to false. **Default:** *20*.\n"
    },
    {
        "prefix": "arraySort",
        "body": "arraySort(${1:array}, ${2|numeric,text,textnocase|})",
        "documentation": " Sorts array elements numerically or alphanumerically.\n\n**USAGE:**\n*boolean arraySort(array, sort_type [, sort_order] [, callback])*\n\n**PARAMETERS:**\n\n*array (array)* - Name of an array\n\n*sort_type (string)* - numeric: sorts numbers\n text: sorts text alphabetically, taking case into account\n (also known as case sensitive). All letters of one case\n precede the first letter of the other case:\n - aabzABZ, if sort_order = \"asc\" (ascending sort)\n - ZBAzbaa, if sort_order = \"desc\" (descending sort)\n\n textnocase: sorts text alphabetically, without regard to\n case (also known as case-insensitive). A letter in varying\n cases precedes the next letter:\n - aAaBbBzzZ, in an ascending sort; preserves original\n intra-letter order\n - ZzzBbBaAa, in a descending sort; reverses original\n intra-letter order **Values:** *numeric, text, textnocase*.\n\n*sort_order (string)* - asc: ascending sort order. Default.\n - aabzABZ or aAaBbBzzZ, depending on value of sort_type,\n for letters\n - from smaller to larger, for numbers\n\n desc: descending sort order.\n - ZBAzbaa or ZzzBbBaAa, depending on value of sort_type,\n for letters\n - from larger to smaller, for numbers. **Default:** *asc*. **Values:** *asc, desc*.\n\n*callback (any)* - The callback function which take two elements of an array, Returns whether the first is less than (-1), equal to (0) or greater than (1) the second one(like as compare function).\n"
    },
    {
        "prefix": "arraySum",
        "body": "arraySum(${1:array})",
        "documentation": " The sum of values in an array. If the array parameter value is\n an empty array, returns zero.\n\n**USAGE:**\n*numeric arraySum(array)*\n\n**PARAMETERS:**\n\n*array (array)* - An array name or variable name\n"
    },
    {
        "prefix": "arraySwap",
        "body": "arraySwap(${1:array}, ${2:position1}, ${3:position2})",
        "documentation": "Swaps array values of an array at specified positions. This\n function is more efficient than multiple cfset tags\n\n**USAGE:**\n*boolean arraySwap(array, position1, position2)*\n\n**PARAMETERS:**\n\n*array (array)* - The array in which postions will be swapped\n\n*position1 (numeric)* - Positon of 1st element to swap.\n\n*position2 (numeric)* - Postion of 2nd element to swap.\n"
    },
    {
        "prefix": "arrayToList",
        "body": "arrayToList(${1:array})",
        "documentation": " Converts a one-dimensional array to a list.\n\n**USAGE:**\n*string arrayToList(array [, delimiter])*\n\n**PARAMETERS:**\n\n*array (array)*\n\n*delimiter (string)*. **Default:** *,*. **Values:** *,, |, _, ;, :*.\n"
    },
    {
        "prefix": "arrayToStruct",
        "body": "arrayToStruct(${1:array})",
        "documentation": "Transform the array to a struct, the index of the array is the key of the struct\n\n**USAGE:**\n*struct arrayToStruct(array)*\n\n**PARAMETERS:**\n\n*array (array)*\n"
    },
    {
        "prefix": "asc",
        "body": "asc(${1:String})",
        "documentation": " Determines the value of a character.\n\n**USAGE:**\n*numeric asc(String)*\n\n**PARAMETERS:**\n\n*String (string)*\n"
    },
    {
        "prefix": "asin",
        "body": "asin(${1:number})",
        "documentation": " Determines the arcsine of a number. The arcsine is the angle\n whose sine is number.\n\n**USAGE:**\n*numeric asin(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "atn",
        "body": "atn(${1:number})",
        "documentation": " Arctangent function. The arctangent is the angle whose tangent\n is number.\n\n**USAGE:**\n*numeric atn(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "beat",
        "body": "beat()",
        "documentation": "Outputs the swatch internet time (or beat time) of the passed local time.\n\n**USAGE:**\n*numeric beat( [time])*\n\n**PARAMETERS:**\n\n*time (any)* - The local time to get beat time from\n"
    },
    {
        "prefix": "binaryDecode",
        "body": "binaryDecode(${1:String}, ${2|hex,uu,base64|})",
        "documentation": " Converts a string to a binary object. Used to convert\n binary data that has been encoded into string format\n back into binary data.\n\n**USAGE:**\n*binary binaryDecode(String, binaryencoding)*\n\n**PARAMETERS:**\n\n*String (string)* - A string containing encoded binary data.\n\n*binaryencoding (string)* - A string specifying the algorithm used to encode the original\n binary data into a string; must be one of the following:\n - hex: characters 0-9 and A-F represent the hexadecimal value\n of each byte; for example, 3A.\n - UU: data is encoded using the UNIX UUencode algorithm.\n - base64: data is encoded using the Base64 algorithm. **Values:** *hex, uu, base64*.\n"
    },
    {
        "prefix": "binaryEncode",
        "body": "binaryEncode(${1:binarydata}, ${2|hex,uu,base64|})",
        "documentation": " Converts binary data to a string.\n\n**USAGE:**\n*string binaryEncode(binarydata, encoding)*\n\n**PARAMETERS:**\n\n*binarydata (binary)* - A string containing encoded binary data.\n\n*encoding (string)* - A string specifying the encoding method to use to represent\n the data; one of the following:\n - hex: use characters 0-9 and A-F represent the hexadecimal value\n of each byte; for example, 3A.\n - UU: use the UNIX UUencode algorithm to convert the data.\n - base64: use the Base64 algorithm to convert the data. **Values:** *hex, uu, base64*.\n"
    },
    {
        "prefix": "bitAnd",
        "body": "bitAnd(${1:number1}, ${2:number2})",
        "documentation": " Performs a bitwise logical AND operation.\n\n**USAGE:**\n*numeric bitAnd(number1, number2)*\n\n**PARAMETERS:**\n\n*number1 (numeric)* - Integer\n\n*number2 (numeric)* - Integer\n"
    },
    {
        "prefix": "bitMaskClear",
        "body": "bitMaskClear(${1:number}, ${2:start}, ${3:length})",
        "documentation": " Performs a bitwise mask clear operation.\n\n**USAGE:**\n*numeric bitMaskClear(number, start, length)*\n\n**PARAMETERS:**\n\n*number (numeric)* - Integer\n\n*start (numeric)* - Start bit for the mask (Integer in the range 0-31, inclusive)\n\n*length (numeric)* - Length of bits in the mask (Integer in the range 0-31, inclusive)\n"
    },
    {
        "prefix": "bitMaskRead",
        "body": "bitMaskRead(${1:number}, ${2:start}, ${3:length})",
        "documentation": " Performs a bitwise mask read operation.\n Returns an integer representation of the corresponding bits specified in the mask.\n\n**USAGE:**\n*numeric bitMaskRead(number, start, length)*\n\n**PARAMETERS:**\n\n*number (numeric)* - Integer\n\n*start (numeric)* - Start bit for the read mask (Integer in the range 0-31, inclusive)\n\n*length (numeric)* - Length of bits in the read mask (Integer in the range 0-31, inclusive)\n"
    },
    {
        "prefix": "bitMaskSet",
        "body": "bitMaskSet(${1:number}, ${2:mask}, ${3:start}, ${4:length})",
        "documentation": " Performs a bitwise mask set operation.\n\n**USAGE:**\n*numeric bitMaskSet(number, mask, start, length)*\n\n**PARAMETERS:**\n\n*number (numeric)* - Integer\n\n*mask (numeric)* - Integer mask\n\n*start (numeric)* - Start bit for the set mask (Integer in the range 0-31, inclusive)\n\n*length (numeric)* - Length of bits in the set mask (Integer in the range 0-31, inclusive)\n"
    },
    {
        "prefix": "bitNot",
        "body": "bitNot(${1:number})",
        "documentation": " Performs a bitwise logical NOT operation.\n\n**USAGE:**\n*numeric bitNot(number)*\n\n**PARAMETERS:**\n\n*number (numeric)* - Integer\n"
    },
    {
        "prefix": "bitOr",
        "body": "bitOr(${1:number1}, ${2:number2})",
        "documentation": " Performs a bitwise logical OR operation.\n\n**USAGE:**\n*numeric bitOr(number1, number2)*\n\n**PARAMETERS:**\n\n*number1 (numeric)* - Integer\n\n*number2 (numeric)* - Integer\n"
    },
    {
        "prefix": "bitShln",
        "body": "bitShln(${1:number}, ${2:count})",
        "documentation": " Performs a bitwise shift-left, no-rotation operation.\n\n**USAGE:**\n*numeric bitShln(number, count)*\n\n**PARAMETERS:**\n\n*number (numeric)* - Integer\n\n*count (numeric)* - Number of bits to shift to the left (Integer in the range 0-31, inclusive)\n"
    },
    {
        "prefix": "bitShrn",
        "body": "bitShrn(${1:number}, ${2:count})",
        "documentation": " Performs a bitwise shift-right, no-rotation operation.\n\n**USAGE:**\n*numeric bitShrn(number, count)*\n\n**PARAMETERS:**\n\n*number (numeric)* - Integer\n\n*count (numeric)* - Number of bits to shift to the right (Integer in the range 0-31, inclusive)\n"
    },
    {
        "prefix": "bitXor",
        "body": "bitXor(${1:number1}, ${2:number2})",
        "documentation": " Performs a bitwise logical XOR operation.\n\n**USAGE:**\n*numeric bitXor(number1, number2)*\n\n**PARAMETERS:**\n\n*number1 (numeric)* - Integer\n\n*number2 (numeric)* - Integer\n"
    },
    {
        "prefix": "booleanFormat",
        "body": "booleanFormat(${1:number})",
        "documentation": "Evaluates the input as a boolean, and outputs either true or false. If not a boolean throws an exception.\n\n**USAGE:**\n*numeric booleanFormat(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "bundleInfo",
        "body": "bundleInfo(${1:obj})",
        "documentation": "Returns information from the class of the given bundle object comes from\n\n**USAGE:**\n*structure bundleInfo(obj)*\n\n**PARAMETERS:**\n\n*obj (any)* - Object from bundle\n"
    },
    {
        "prefix": "cacheClear",
        "body": "cacheClear()",
        "documentation": "Flushes the cache\n\n**USAGE:**\n*numeric cacheClear( [filterOrTags] [, cacheName])*\n\n**PARAMETERS:**\n\n*filterOrTags (any)* - A String containing a key filter for the elements in the cache to flush, the filter follow the same rules as for cfdirectory-filter OR an Array containing tags defined when put into the cache\n\n*cacheName (string)* - definition of the cache used by name, when not set the \"default Object Cache\" defined in Lucee Administrator is used instead\n"
    },
    {
        "prefix": "cacheCount",
        "body": "cacheCount()",
        "documentation": "Returns the amount (integer) of keys stored in the cache.\n\n**USAGE:**\n*numeric cacheCount( [cacheName])*\n\n**PARAMETERS:**\n\n*cacheName (string)* - Definition of the cache used by name, when not set the \"default Object Cache\" defined in Lucee Administrator is used instead\n"
    },
    {
        "prefix": "cacheDelete",
        "body": "cacheDelete(${1:id})",
        "documentation": "Deletes a single element from the cache.\n\n**USAGE:**\n*void cacheDelete(id [, throwOnError] [, cacheName])*\n\n**PARAMETERS:**\n\n*id (string)* - The id of the element to delete, can also contain a \",\" (not used as separator)\n\n*throwOnError (boolean)* - Define if the functions throws an exception when the element does not exist (default is false)\n\n*cacheName (string)* - Definition of the cache used by name, when not set the \"default Object Cache\" defined in Lucee Administrator is used instead\n"
    },
    {
        "prefix": "cacheGet",
        "body": "cacheGet(${1:id})",
        "documentation": " Gets an object that is stored in the cache.\n\n**USAGE:**\n*any cacheGet(id [, region] [, cacheName] [, throwWhenNotExist])*\n\n**PARAMETERS:**\n\n*id (string)* - The ID value assigned to the cache object when it was created\n\n*region (string)* - CF10+ The name of the cache region where the object was stored. Applies only to ACF.\n\n*cacheName (string)* - Lucee4.5+ The name of the cache where the object was stored. Applies only to Lucee.\n\n*throwWhenNotExist (boolean)* - Lucee4.5+ Enable/Disable throwing an error if element not exists. **Default:** *false*. **Values:** *true, false*.\n"
    },
    {
        "prefix": "cacheGetAll",
        "body": "cacheGetAll()",
        "documentation": "Returns a structure containing all elements inside the cache.\n\n**USAGE:**\n*struct cacheGetAll( [filter] [, cacheName])*\n\n**PARAMETERS:**\n\n*filter (string)* - Key filter for the elements, the filter follows the same rules as the cfdirectory-filter\n\n*cacheName (string)* - Definition of the cache used by name, when not set the \"default Object Cache\" defined in Lucee Administrator is used instead\n"
    },
    {
        "prefix": "cacheGetAllIds",
        "body": "cacheGetAllIds()",
        "documentation": " Gets the IDs of all objects stored in the cache.\n\n**USAGE:**\n*array cacheGetAllIds()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "cacheGetDefaultCacheName",
        "body": "cacheGetDefaultCacheName(${1|object,resource,template,query|})",
        "documentation": "Returns the default cache name for the specified type.\n\n**USAGE:**\n*string cacheGetDefaultCacheName(type)*\n\n**PARAMETERS:**\n\n*type (string)* - Cache type **Values:** *object, resource, template, query*.\n"
    },
    {
        "prefix": "cacheGetMetadata",
        "body": "cacheGetMetadata(${1:id})",
        "documentation": " Gets the metadata values for a cached object.\n\n**USAGE:**\n*struct cacheGetMetadata(id [, template] [, region])*\n\n**PARAMETERS:**\n\n*id (string)* - The ID of the cached object.\n\n*template (string)* - Gets metadata for template caches.\n\n*region (string)* - The name of the cache region\n"
    },
    {
        "prefix": "cacheGetProperties",
        "body": "cacheGetProperties(${1|object,template,resource,query|})",
        "documentation": " Gets the cache properties for the object cache, the page cache, or both. The information is application-specific.\n\n**USAGE:**\n*array cacheGetProperties(type)*\n\n**PARAMETERS:**\n\n*type (string)* - Properties to get information for\n\n\"\" or not set - information to all default caches\nobject - information to \"Default Object\" Cache\ntemplate - information to \"Default Template\" Cache\nquery - information to \"Default Query\" Cache\nresource - information to \"Default Resource\" Cache\n{cache name} - information to a specific cache **Values:** *object, template, resource, query*.\n"
    },
    {
        "prefix": "cacheGetSession",
        "body": "cacheGetSession(${1:objectType})",
        "documentation": "Lets you retrieve the underlying cache object to access additional cache functionality that is not implemented in the tag cfcache.\n\nNote: Caution! Using the cacheGetSession function might pose security vulnerabilities. If you wish to disable the usage of this function, add it to Sandbox Security. \n\n**USAGE:**\n*any cacheGetSession(objectType [, isKey])*\n\n**PARAMETERS:**\n\n*objectType ()* - Any of the following values: object, template, or name of the user-defined cache\n\n*isKey (boolean)* - Set to true if objectType is user-defined cache.. **Default:** *false*.\n"
    },
    {
        "prefix": "cacheIdExists",
        "body": "cacheIdExists(${1:id})",
        "documentation": " Used to find if a cached object exists in the cache region. The region can be the default cache region (either at server or application level) or the custom region you specify.\n\n**USAGE:**\n*boolean cacheIdExists(id [, region])*\n\n**PARAMETERS:**\n\n*id ()* - The ID of the cached object.\n\n*region ()* - The cache region where you check for the cached object.\n"
    },
    {
        "prefix": "cacheKeyExists",
        "body": "cacheKeyExists(${1:key})",
        "documentation": "Returns true/false whether the cache contains an element with the specified keyname.\n\n**USAGE:**\n*boolean cacheKeyExists(key [, cacheName])*\n\n**PARAMETERS:**\n\n*key (string)* - Key to check\n\n*cacheName (string)* - Definition of the cache used by name, when not set the \"default Object Cache\" defined in Lucee Administrator is used instead.\n"
    },
    {
        "prefix": "cachePut",
        "body": "cachePut(${1:id}, ${2:value})",
        "documentation": " Stores an object in the cache.\n\n**USAGE:**\n*void cachePut(id, value [, timespan] [, idleTime] [, region] [, cacheName])*\n\n**PARAMETERS:**\n\n*id (string)* - Unique identifier for the cached value\n\n*value (string)* - The value to cache\n\n*timespan (date)* - The interval until the object is flushed from the cache, as a decimal number of days. One way to set the value is to use the return value from the CreateTimeSpan function. The default is to not time out the object.\n\n*idleTime (date)* - A decimal number of days after which the object is flushed from the cache if it is not accessed during that time. One way to set the value is to use the return value from the CreateTimeSpan function.\n\n*region (string)* - CF10+ Specifies the cache region where you can place the cache object. Applies only to ACF.\n\n*cacheName (string)* - Lucee4.5+ Definition of the cache used by name. Applies only to Lucee.\n"
    },
    {
        "prefix": "cacheRegionExists",
        "body": "cacheRegionExists(${1:region})",
        "documentation": " Checks if the cache region exists.\n\n**USAGE:**\n*boolean cacheRegionExists(region)*\n\n**PARAMETERS:**\n\n*region ()* - Name of the cache region.\n"
    },
    {
        "prefix": "cacheRegionNew",
        "body": "cacheRegionNew(${1:region})",
        "documentation": "Creates a new custom cache region (if no cache region exists).\n\n**USAGE:**\n*void cacheRegionNew(region [, properties] [, throwOnError])*\n\n**PARAMETERS:**\n\n*region ()* - Name of the new cache region to be created.\n\n*properties ()* - Struct that contains the cache region properties.\n\n*throwOnError ()* - A Boolean value specifying if to throw an exception if the cache region name you specify already exists. The default value is true.\n"
    },
    {
        "prefix": "cacheRegionRemove",
        "body": "cacheRegionRemove(${1:region})",
        "documentation": "Removes a specified cache region.\n\n**USAGE:**\n*void cacheRegionRemove(region)*\n\n**PARAMETERS:**\n\n*region ()* - Name of the cache region that has to be removed.\n"
    },
    {
        "prefix": "cacheRemove",
        "body": "cacheRemove(${1:ids})",
        "documentation": "Removes an object from the cache.\n\n**USAGE:**\n*void cacheRemove(ids [, throwOnError] [, key] [, exact])*\n\n**PARAMETERS:**\n\n*ids (string)* - Comma delimited list of cache IDs. A list of all available IDs can be retrieved using cacheGetAllIds. CF11+ Can take an array instead of a list.\n\n*throwOnError (boolean)* - `true` throws an error when cache ID does not exist. **Values:** *true, false*.\n\n*key (string)* - CF10+ Specify which cache region to search\n\n*exact (boolean)* - CF10+ Used to partially match on keys. **Default:** *true*. **Values:** *true, false*.\n"
    },
    {
        "prefix": "cacheRemoveAll",
        "body": "cacheRemoveAll()",
        "documentation": " Removes all stored objects in a cache region. If no cache region is specified, objects in the default region are removed.\n\n**USAGE:**\n*void cacheRemoveAll( [region])*\n\n**PARAMETERS:**\n\n*region ()* - Indicates the cache region from which to remove the stored objects. If no value is specified, default cache region is considered by default.\n"
    },
    {
        "prefix": "cacheSetProperties",
        "body": "cacheSetProperties(${1:properties})",
        "documentation": " Set multiple cache settings\n\n**USAGE:**\n*void cacheSetProperties(properties)*\n\n**PARAMETERS:**\n\n*properties (structure)* - Key-Value pairs of properties to be changed\n"
    },
    {
        "prefix": "callStackDump",
        "body": "callStackDump()",
        "documentation": " Similar to the function callStackGet except that it returns a string representation of the call stack.\n\n**USAGE:**\n*void callStackDump( [destination])*\n\n**PARAMETERS:**\n\n*destination (string)* - If you chose \"file\" and do not provide the complete path to the file, the file is written to the temp directory as determined by the function `getTempDirectory()`.. **Default:** *browser*. **Values:** *console, browser, file*.\n"
    },
    {
        "prefix": "callStackGet",
        "body": "callStackGet()",
        "documentation": " Returns an array of structs. Each struct contains template name, line number, and function name (if applicable). This is a snapshot of all function calls or invocations.\n\n**USAGE:**\n*array callStackGet()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "canonicalize",
        "body": "canonicalize(${1:input}, ${2:restrictMultiple}, ${3:restrictMixed})",
        "documentation": "Canonicalize or decode the input string. Canonicalization is simply the operation of reducing a possibly encoded string down to its simplest form. This is important because attackers frequently use encoding to change their input in a way that will bypass validation filters, but still be interpreted properly by the target of the attack. Note that data encoded more than once is not something that a normal user would generate and should be regarded as an attack.\n\n**USAGE:**\n*string canonicalize(input, restrictMultiple, restrictMixed [, throwOnError])*\n\n**PARAMETERS:**\n\n*input (string)* - Required. The string to be encoded.\n\n*restrictMultiple (boolean)* - Required. If set to true, multiple encoding is restricted. This argument can be set to true to restrict the input if multiple or nested encoding is detected. If this argument is set to true, and the given input is multiple or nested encoded using one encoding scheme an error will be thrown.\n\n*restrictMixed (boolean)* - Required. If set to true, mixed encoding is restricted. This argument can be set to true to restrict the input if mixed encoding is detected. If this argument is set to true, and the given input is encoded using mixed encoding, an error will be thrown.\n\n*throwOnError (boolean)* - (Added in Adobe CF11+) Optional. Default value is false. If the value of this argument is true, and if restrictMultiple or restrictMixed is true and the given input contains mixed or multiple encoded strings, an exception will be thrown. If the value of this argument is false, an empty string will be returned instead of an exception.\n"
    },
    {
        "prefix": "ceiling",
        "body": "ceiling(${1:number})",
        "documentation": "Determines the closest integer that is greater than a\n specified floating point number.\n\n**USAGE:**\n*numeric ceiling(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "cfusion_Decrypt",
        "body": "cfusion_Decrypt(${1:string}, ${2:key})",
        "documentation": "Decrypts the given string, alias for function call decrypt(string,key,\"cfmx_compat\",\"hex\").\n\n**USAGE:**\n*string cfusion_Decrypt(string, key)*\n\n**PARAMETERS:**\n\n*string (string)*\n\n*key (string)*\n"
    },
    {
        "prefix": "cfusion_Encrypt",
        "body": "cfusion_Encrypt(${1:string}, ${2:key})",
        "documentation": "Encrypts the given string, alias for function call encrypt(string,key,\"cfmx_compat\",\"hex\").\n\n**USAGE:**\n*string cfusion_Encrypt(string, key)*\n\n**PARAMETERS:**\n\n*string (string)*\n\n*key (string)*\n"
    },
    {
        "prefix": "charsetDecode",
        "body": "charsetDecode(${1:String}, ${2|utf-8,iso-8859-1,windows-1252,us-ascii,shift_jis,iso-2022-jp,euc-jp,euc-kr,big5,euc-cn,utf-16|})",
        "documentation": " Converts as string to a binary representation.\n\n**USAGE:**\n*binary charsetDecode(String, encoding)*\n\n**PARAMETERS:**\n\n*String (string)* - A string containing data to encode in binary format.\n\n*encoding (string)* - A string specifying encoding of the input data. **Values:** *utf-8, iso-8859-1, windows-1252, us-ascii, shift_jis, iso-2022-jp, euc-jp, euc-kr, big5, euc-cn, utf-16*.\n"
    },
    {
        "prefix": "charsetEncode",
        "body": "charsetEncode(${1:binaryobject}, ${2|utf-8,iso-8859-1,windows-1252,us-ascii,shift_jis,iso-2022-jp,euc-jp,euc-kr,big5,euc-cn,utf-16|})",
        "documentation": " Uses the specified encoding to convert binary data to a string.\n\n**USAGE:**\n*binary charsetEncode(binaryobject, encoding)*\n\n**PARAMETERS:**\n\n*binaryobject (binary)* - A variable containing binary data to decode into text.\n\n*encoding (string)* - The character encoding that was used to encode the string into binary format. **Values:** *utf-8, iso-8859-1, windows-1252, us-ascii, shift_jis, iso-2022-jp, euc-jp, euc-kr, big5, euc-cn, utf-16*.\n"
    },
    {
        "prefix": "chr",
        "body": "chr(${1|9: \\t tab,10: \\n New Line,13: \\r Carriage Return|})",
        "documentation": " Converts a numeric value to a UCS-2 character.\n\n**USAGE:**\n*string chr(number)*\n\n**PARAMETERS:**\n\n*number (numeric)* **Values:** *9: \\t tab, 10: \\n New Line, 13: \\r Carriage Return*.\n"
    },
    {
        "prefix": "cjustify",
        "body": "cjustify(${1:String}, ${2:length})",
        "documentation": " Centers a string in a field length.\n\n**USAGE:**\n*string cjustify(String, length)*\n\n**PARAMETERS:**\n\n*String (string)*\n\n*length (numeric)*\n"
    },
    {
        "prefix": "collectionEach",
        "body": "collectionEach(${1:collection}, ${2:closure})",
        "documentation": "Iterate over each item contained in the collection given\n\n**USAGE:**\n*void collectionEach(collection, closure)*\n\n**PARAMETERS:**\n\n*collection (any)*\n\n*closure (function)*\n"
    },
    {
        "prefix": "collectionEvery",
        "body": "collectionEvery(${1:collection}, ${2:closure})",
        "documentation": "Checks if every item passes the truth test of an expression given in the closure\n\n**USAGE:**\n*boolean collectionEvery(collection, closure [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*collection (any)*\n\n*closure (function)*\n\n*parallel (boolean)*\n\n*maxThreads (numeric)*. **Default:** *20*.\n"
    },
    {
        "prefix": "collectionFilter",
        "body": "collectionFilter(${1:collection}, ${2:filter})",
        "documentation": "Filters items from a collection passing the filter condition\n\n**USAGE:**\n*any collectionFilter(collection, filter [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*collection (any)*\n\n*filter (function)*\n\n*parallel (boolean)*\n\n*maxThreads (numeric)*. **Default:** *20*.\n"
    },
    {
        "prefix": "collectionMap",
        "body": "collectionMap(${1:collection}, ${2:closure})",
        "documentation": "Maps values in a collection\n\n**USAGE:**\n*any collectionMap(collection, closure [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*collection (any)*\n\n*closure (function)*\n\n*parallel (boolean)*\n\n*maxThreads (numeric)*. **Default:** *20*.\n"
    },
    {
        "prefix": "collectionReduce",
        "body": "collectionReduce(${1:collection}, ${2:closure})",
        "documentation": "Sum amount of an item value for every item\n\n**USAGE:**\n*any collectionReduce(collection, closure [, initalValue])*\n\n**PARAMETERS:**\n\n*collection (any)*\n\n*closure (function)*\n\n*initalValue (any)*\n"
    },
    {
        "prefix": "collectionSome",
        "body": "collectionSome(${1:collection}, ${2:closure})",
        "documentation": "Similar to collectionEvery, except it returns true if at least one item returns true\n\n**USAGE:**\n*boolean collectionSome(collection, closure [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*collection (any)*\n\n*closure (function)*\n\n*parallel (boolean)*\n\n*maxThreads (numeric)*. **Default:** *20*.\n"
    },
    {
        "prefix": "compare",
        "body": "compare(${1:string1}, ${2:string2})",
        "documentation": " Performs a case-sensitive comparison of two strings.\n -1, if string1 is less than string2\n 0, if string1 is equal to string2\n 1, if string1 is greater than string2\n\n**USAGE:**\n*numeric compare(string1, string2)*\n\n**PARAMETERS:**\n\n*string1 (string)*\n\n*string2 (string)*\n"
    },
    {
        "prefix": "compareNoCase",
        "body": "compareNoCase(${1:string1}, ${2:string2})",
        "documentation": " Performs a case-insensitive comparison of two strings.\n An indicator of the difference:\n A negative number, if string1 is less than string2\n 0, if string1 is equal to string2\n A positive number, if string1 is greater than string2\n\n**USAGE:**\n*numeric compareNoCase(string1, string2)*\n\n**PARAMETERS:**\n\n*string1 (string)*\n\n*string2 (string)*\n"
    },
    {
        "prefix": "componentCacheClear",
        "body": "componentCacheClear()",
        "documentation": "\n\n**USAGE:**\n*void componentCacheClear()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "componentCacheList",
        "body": "componentCacheList()",
        "documentation": "\n\n**USAGE:**\n*struct componentCacheList()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "componentInfo",
        "body": "componentInfo(${1:component})",
        "documentation": "\n\n**USAGE:**\n*struct componentInfo(component)*\n\n**PARAMETERS:**\n\n*component (component)*\n"
    },
    {
        "prefix": "compress",
        "body": "compress(${1|bzip,bzip2,tbz,tbz2,tar,tar.bz,tar.gz,gzip,tgz,zip|}, ${2:source}, ${3:target})",
        "documentation": "Compress a file or a directory with files.\n\n**USAGE:**\n*boolean compress(format, source, target [, includeBaseFolder] [, mode])*\n\n**PARAMETERS:**\n\n*format (string)* - The format in which you want to compress the files. **Values:** *bzip, bzip2, tbz, tbz2, tar, tar.bz, tar.gz, gzip, tgz, zip*.\n\n*source (string)* - Path (relative or absolute) to the file or directory you want to compress.\n\n*target (string)* - Path (relative or absolute) including the name, where you want to save the compressed output-file.\n\n*includeBaseFolder (boolean)* - Compress the directory or just the content of the directory.. **Default:** *true*.\n\n*mode (string)*. **Default:** *777*.\n"
    },
    {
        "prefix": "contractPath",
        "body": "contractPath(${1:path})",
        "documentation": "\n\n**USAGE:**\n*string contractPath(path [, placeholder])*\n\n**PARAMETERS:**\n\n*path (string)*\n\n*placeholder (boolean)*\n"
    },
    {
        "prefix": "cos",
        "body": "cos(${1:number})",
        "documentation": " Calculates the cosine of an angle that is entered\n in radians.\n A number; the cosine of the angle.\n\n**USAGE:**\n*numeric cos(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "createDate",
        "body": "createDate(${1:year}, ${2:month}, ${3:day})",
        "documentation": " Creates a date/time object\n\n**USAGE:**\n*date createDate(year, month, day)*\n\n**PARAMETERS:**\n\n*year (numeric)*\n\n*month (numeric)* - Numeric month of the year (1-12)\n\n*day (numeric)* - Day of the month\n"
    },
    {
        "prefix": "createDateTime",
        "body": "createDateTime(${1:year}, ${2:month}, ${3:day}, ${4:hour}, ${5:minute}, ${6:second})",
        "documentation": " Creates a date-time object.\n\n**USAGE:**\n*date createDateTime(year, month, day, hour, minute, second)*\n\n**PARAMETERS:**\n\n*year (numeric)*\n\n*month (numeric)* - Numeric month of the year (1-12)\n\n*day (numeric)* - Day of the month\n\n*hour (numeric)* - Hour of the day in 24-hour notation (0-23)\n\n*minute (numeric)*\n\n*second (numeric)*\n"
    },
    {
        "prefix": "createDynamicProxy",
        "body": "createDynamicProxy(${1:fullyQualifiedNameOfCFC})",
        "documentation": "Creates a dynamic proxy of the ColdFusion component that is passed to a Java library. Dynamic proxy lets you pass ColdFusion components to Java objects. Java objects can work with the ColdFusion components seamlessly as if they are native Java objects.\n\n**USAGE:**\n*any createDynamicProxy(fullyQualifiedNameOfCFC [, interfaceName])*\n\n**PARAMETERS:**\n\n*fullyQualifiedNameOfCFC ()* - Fully qualified name of the ColdFusion component or a CFC instance.\n\n*interfaceName ()* - An array of Java interfaces for which you want to create the dynamic proxy.\n"
    },
    {
        "prefix": "createGUID",
        "body": "createGUID()",
        "documentation": "Creates a globally unique identifier (32 character hexadecimal string)\n\n**USAGE:**\n*guid createGUID()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "createObject",
        "body": "createObject(${1|component,corba,com,java,webservice,.NET,dotnet|}, ${2:context}, ${3:class}, ${4:locale}, ${5:servername}, ${6:component_name}, ${7:urltowsdl})",
        "documentation": "The createObject function takes different arguments depending on the value of the type argument:\n\n createObject('component', cfcName)\n createObject('java', class)\n createObject('java', class, bundleName, bundleVersion) <small><em>(Lucee only)</em></small>\n createObject('webservice', urltowsdl, [, portname])\n createObject('.NET', class, assembly [, server, port, protocol, secure])\n createObject('com', class, context, serverName)\n\n**USAGE:**\n*any createObject(type, context, class, locale, servername, component_name, urltowsdl [, portname] [, OSGibundle] [, OSGiversion])*\n\n**PARAMETERS:**\n\n*type (string)* - The type of object **Values:** *component, corba, com, java, webservice, .NET, dotnet*.\n\n*context (string)*\n\n*class (string)*\n\n*locale (string)*\n\n*servername (string)*\n\n*component_name (string)*\n\n*urltowsdl (string)* - WSDL file URL; location of web service\n\n*portname (string)* - The port name for the web service. This value is case-sensitive\n and corresponds to the port element's name attribute under the\n service element.\n Specify this parameter if the web service contains multiple ports.\n If no port name is specified, ColdFusion uses the first port found\n in the WSDL.\n\n*OSGibundle (string)* - Bundle where the object has to be located\n\n*OSGiversion (string)* - Specific version to\n"
    },
    {
        "prefix": "createODBCDate",
        "body": "createODBCDate(${1:date})",
        "documentation": " Creates an ODBC date object.\n\n**USAGE:**\n*date createODBCDate(date)*\n\n**PARAMETERS:**\n\n*date (date)* - Date or date/time object.\n"
    },
    {
        "prefix": "createODBCDateTime",
        "body": "createODBCDateTime(${1:date})",
        "documentation": " Creates an ODBC date-time object.\n\n**USAGE:**\n*date createODBCDateTime(date)*\n\n**PARAMETERS:**\n\n*date (date)* - Date or date/time object.\n"
    },
    {
        "prefix": "createODBCTime",
        "body": "createODBCTime(${1:date})",
        "documentation": " Creates an ODBC time object.\n\n**USAGE:**\n*date createODBCTime(date)*\n\n**PARAMETERS:**\n\n*date (date)* - Date or date/time object.\n"
    },
    {
        "prefix": "createTime",
        "body": "createTime(${1:hour}, ${2:minute}, ${3:second})",
        "documentation": " Creates a time variable.\n\n**USAGE:**\n*date createTime(hour, minute, second)*\n\n**PARAMETERS:**\n\n*hour (numeric)* - Hour of the day in 24-hour notation (0-23)\n\n*minute (numeric)*\n\n*second (numeric)*\n"
    },
    {
        "prefix": "createTimespan",
        "body": "createTimespan(${1:days}, ${2:hours}, ${3:minutes}, ${4:seconds})",
        "documentation": "Returns a value that defines a time period, represented by a numeric (double) where 1 equals 1 day. You can add or subtract it from other date/time objects and use it with the cachedWithin attribute of cfquery.\n\n**USAGE:**\n*numeric createTimespan(days, hours, minutes, seconds)*\n\n**PARAMETERS:**\n\n*days (numeric)* - The number of days ranging from 0 to 32768\n\n*hours (numeric)* - The number of hours\n\n*minutes (numeric)* - The number of minutes\n\n*seconds (numeric)* - The number of seconds\n"
    },
    {
        "prefix": "createUniqueID",
        "body": "createUniqueID()",
        "documentation": "Creates a Unique Identifier for the current instance. If you want it to be Universal Unique use createUUID instead.\n\n**USAGE:**\n*string createUniqueID()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "createUUID",
        "body": "createUUID()",
        "documentation": " Creates a Universally Unique Identifier (UUID). A UUID is a\n 35-character string representation of a unique 128-bit integer\n xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx : x is a hexadecimal digit (8-4-4-16).\n SQL Server UUIDs are similar but have a format of 8-4-4-4-12.\n\n**USAGE:**\n*uuid createUUID()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "csrfGenerateToken",
        "body": "csrfGenerateToken()",
        "documentation": " Generates a random token and stores it in the session to protect against Cross-Site Request Forgery (CSRF) attacks. You can optionally provide a specific key to store in the session, and optionally force the generation of a new token.\n\n**USAGE:**\n*string csrfGenerateToken( [key] [, forceNew])*\n\n**PARAMETERS:**\n\n*key (string)* - A random token is generated based on the key provided. This key is stored in the session.\n\n*forceNew (boolean)* - If set to true, a new token is generated every time the method is called. If false, and in the case where a token already exists [for the key], the same key is returned.. **Default:** *false*. **Values:** *true, false*.\n"
    },
    {
        "prefix": "csrfVerifyToken",
        "body": "csrfVerifyToken(${1:token})",
        "documentation": "Validates the passed in token against the token stored in the session for a specific key. Used to help prevent Cross-Site Request Forgery (CSRF) attacks.\n\n**USAGE:**\n*boolean csrfVerifyToken(token [, key])*\n\n**PARAMETERS:**\n\n*token (string)* - The passed in token that is to be validated against the token stored in the session.\n\n*key (string)* - The key against which the token was originally generated.\n"
    },
    {
        "prefix": "ctCacheClear",
        "body": "ctCacheClear()",
        "documentation": "Flushes the customtag path cache\n\n**USAGE:**\n*void ctCacheClear()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "ctCacheList",
        "body": "ctCacheList()",
        "documentation": "Get elements in the customtag path cache\n\n**USAGE:**\n*struct ctCacheList()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "datasourceFlushMetacache",
        "body": "datasourceFlushMetacache()",
        "documentation": "\n\n**USAGE:**\n*boolean datasourceFlushMetacache( [datasourceName])*\n\n**PARAMETERS:**\n\n*datasourceName (string)*\n"
    },
    {
        "prefix": "dateAdd",
        "body": "dateAdd(${1|yyyy,q,m,y,d,w,ww,h,n,s,l|}, ${2:number}, ${3:date})",
        "documentation": "Adds units of time to a date.\n\n**USAGE:**\n*date dateAdd(datepart, number, date)*\n\n**PARAMETERS:**\n\n*datepart (string)* - `yyyy` - Year\n`q` - Quarter\n`m` - Month\n`y` - Day of year\n`d` - Day\n`w` - Week day\n`ww` - Week\n`h` - Hour\n`n` - Minute\n`s` - Second\n`l` - Millisecond **Values:** *yyyy, q, m, y, d, w, ww, h, n, s, l*.\n\n*number (numeric)* - The number of datepart units to add to the provided date.\n Negative integers move the date into the past, positive into the future.\n\n*date (date)*\n"
    },
    {
        "prefix": "dateCompare",
        "body": "dateCompare(${1:date1}, ${2:date2})",
        "documentation": "Performs a full date/time comparison of two dates.\n `-1` if date1 is less than date2\n `0` if date1 is equal to date2\n `1` if date1 is greater than date2\n [DatePart] `yyyy`: Year; `m`: Month; `d`: Day; `h`: Hour; `n`: Minute; `s`: Second\n\n**USAGE:**\n*numeric dateCompare(date1, date2 [, datePart])*\n\n**PARAMETERS:**\n\n*date1 (date)* - A date to compare\n\n*date2 (date)* - Another date to compare\n\n*datePart (string)*. **Default:** *s*. **Values:** *yyyy, m, y, d, h, n, s*.\n"
    },
    {
        "prefix": "dateConvert",
        "body": "dateConvert(${1|local2Utc,utc2Local|}, ${2:date})",
        "documentation": "Converts local time to Coordinated Universal Time (UTC), or UTC to local time. The function uses the daylight savings settings in the executing computer to compute daylight savings time, if required.\n\n**USAGE:**\n*date dateConvert(type, date)*\n\n**PARAMETERS:**\n\n*type (string)* - 'local2Utc' - Converts local time to UTC time.\n'utc2Local' - Converts UTC time to local time. **Values:** *local2Utc, utc2Local*.\n\n*date (date)*\n"
    },
    {
        "prefix": "dateDiff",
        "body": "dateDiff(${1|yyyy,q,m,y,d,w,ww,h,n,s|}, ${2:date1}, ${3:date2})",
        "documentation": "Determines the integer number of datepart units by which date1 is less than date2.\n\n**USAGE:**\n*numeric dateDiff(datepart, date1, date2)*\n\n**PARAMETERS:**\n\n*datepart (string)* - yyyy: Year\n q: Quarter\n m: Month\n y: Day of year\n d: Day\n w: Week\n ww: Week\n h: Hour\n n: Minute\n s: Second\n **Values:** *yyyy, q, m, y, d, w, ww, h, n, s*.\n\n*date1 (date)*\n\n*date2 (date)*\n"
    },
    {
        "prefix": "dateFormat",
        "body": "dateFormat(${1:date})",
        "documentation": "Formats a date value using U.S. date formats. When formatting both date and time, use dateTimeFormat. For international date support, use lsDateFormat.\n\n**USAGE:**\n*string dateFormat(date [, mask])*\n\n**PARAMETERS:**\n\n*date (date)* - The date object\n\n*mask (string)* - Each keyword below will be replaced in the string by its respective datepart \n`d`: Day of the month as digits; no leading zero for single-digit days.\n`dd`: Day of the month as digits; leading zero for single-digit days.\n`ddd`: Day of the week as a three-letter abbreviation.\n`dddd`: Day of the week as its full name.\n`e`: Day in a week (CF2016u3+).\n`f`: Day of a week in a month (CF2016u3+).\n`m`: Month as digits; no leading zero for single-digit months.\n`mm`: Month as digits; leading zero for single-digit months.\n`mmm`: Month as a three-letter abbreviation.\n`mmmm`: Month as its full name.\n`k`: Hour in a day (CF2016u3+).\n`w`: Week in a month (CF2016u3+).\n`W`: Week in a year (CF2016u3+).\n`yy`: Year as last two digits; leading zero for years less than 10.\n`yyyy`,`YYYY`: Year represented by four digits.\n`gg`: Period/era string.\n`z`: Time zone in unstandardized abbreviated format, for example, EST (CF2016u3+).\n`Z`: Time zone in hours of offset (RFC 822 TimeZone), for example, +0530 (CF2016u3+).\n`X`: Time zone in hours of offset in ISO 8601 format. (CF2016u3+).\n\n The following keywords are shorthand for specific full formats and cannot be combined with other masks:\n`short`: equivalent to `m/d/y`\n`medium`: equivalent to `mmm d, yyyy`\n`long`: equivalent to `mmmm d, yyyy`\n`full`: equivalent to `dddd, mmmm d, yyyy`. **Default:** *dd-mmm-yy*.\n"
    },
    {
        "prefix": "datePart",
        "body": "datePart(${1|yyyy,q,m,y,d,w,ww,h,n,s,l|}, ${2:date})",
        "documentation": "Extracts a part from a datetime value as a numeric.\n\n**USAGE:**\n*numeric datePart(datepart, date)*\n\n**PARAMETERS:**\n\n*datepart (string)* - yyyy: Year \n q: Quarter \n m: Month \n y: Day of year \n d: Day \n w: Weekday \n ww: Week \n h: Hour \n n: Minute \n s: Second \n l: Millisecond **Values:** *yyyy, q, m, y, d, w, ww, h, n, s, l*.\n\n*date (date)*\n"
    },
    {
        "prefix": "dateTimeFormat",
        "body": "dateTimeFormat(${1:dateTime})",
        "documentation": " Formats a datetime value using U.S. date and time formats. For international date support, use LSDateTimeFormat.\n[mask - quicky]\nd: Day of the month as digits; no leading zero for single-digit days.\ndd: Day of the month as digits; leading zero for single-digit days.\nEEE: Day of the week as a three-letter abbreviation.\nEEEE: Day of the week as its full name.\nm: Month as digits; no leading zero for single-digit months.\nmm: Month as digits; leading zero for single-digit months.\nmmm: Month as a three-letter abbreviation.\nmmmm: Month as its full name.\nyy: Year as last two digits; leading zero for years less than 10.\nyyyy: Year represented by four digits.\n Y YY: Week Year\nG: Period/era string.\nh: hours; no leading zero for single-digit hours (12-hour clock)\nhh: hours; leading zero for single-digit hours (12-hour clock)\nH: hours; no leading zero for single-digit hours (24-hour clock)\nHH: hours; leading zero for single-digit hours (24-hour clock)\nn: minutes; no leading zero for single-digit minutes\nnn: minutes; a leading zero for single-digit minutes\ns: seconds; no leading zero for single-digit seconds\nss: seconds; leading zero for single-digit seconds\nl or L: milliseconds, with no leading zeros\nt: one-character time marker string, such as A or P\ntt: multiple-character time marker string, such as AM or PM\n\n**USAGE:**\n*string dateTimeFormat(dateTime [, mask] [, timezone])*\n\n**PARAMETERS:**\n\n*dateTime (date)* - A datetime value.\n\n*mask (string)* - The mask used to format the datetime.\n\n*timezone (string)* - The timezone to use. Can be 3 letter code (UTC) or full America/New_York **Values:** *UTC, GMT, America/Chicago*.\n"
    },
    {
        "prefix": "day",
        "body": "day(${1:date})",
        "documentation": " Determines the day of the month, in a date.\n The ordinal for the day of the month, ranging from 1 to 31.\n\n**USAGE:**\n*numeric day(date)*\n\n**PARAMETERS:**\n\n*date (date)* - Date or date/time object.\n"
    },
    {
        "prefix": "dayOfWeek",
        "body": "dayOfWeek(${1:date})",
        "documentation": " Determines the day of the week, in a date. Returns the ordinal for the day of the week, as an integer in the range 1 (Sunday) to 7 (Saturday).\n\n**USAGE:**\n*numeric dayOfWeek(date)*\n\n**PARAMETERS:**\n\n*date (date)* - Date or date/time object.\n"
    },
    {
        "prefix": "dayOfWeekAsString",
        "body": "dayOfWeekAsString(${1|1,2,3,4,5,6,7|})",
        "documentation": " Determines the day of the week as a string from 1-7\n\n**USAGE:**\n*string dayOfWeekAsString(day_of_week)*\n\n**PARAMETERS:**\n\n*day_of_week (numeric)* - Only values from 1 to 7 are valid.\nWeek starting with 1 for Sunday and ends with 7 for Saturday. **Values:** *1, 2, 3, 4, 5, 6, 7*.\n"
    },
    {
        "prefix": "dayOfWeekShortAsString",
        "body": "dayOfWeekShortAsString(${1|1,2,3,4,5,6,7|})",
        "documentation": "\n\n**USAGE:**\n*string dayOfWeekShortAsString(day_of_week [, locale])*\n\n**PARAMETERS:**\n\n*day_of_week (numeric)* - Only values from 1 to 7 are valid.\nWeek starting with 1 for Sunday and ends with 7 for Saturday. **Values:** *1, 2, 3, 4, 5, 6, 7*.\n\n*locale (string)*\n"
    },
    {
        "prefix": "dayOfYear",
        "body": "dayOfYear(${1:date})",
        "documentation": " Determines the day of the year, in a date.\n\n**USAGE:**\n*numeric dayOfYear(date)*\n\n**PARAMETERS:**\n\n*date (date)* - Date or date/time object.\n"
    },
    {
        "prefix": "daysInMonth",
        "body": "daysInMonth(${1:date})",
        "documentation": " Determines the number of days in a month.\n\n**USAGE:**\n*numeric daysInMonth(date)*\n\n**PARAMETERS:**\n\n*date (date)* - Date or date/time object.\n"
    },
    {
        "prefix": "daysInYear",
        "body": "daysInYear(${1:date})",
        "documentation": " Determines the number of days in a year.\n\n**USAGE:**\n*numeric daysInYear(date)*\n\n**PARAMETERS:**\n\n*date (date)* - Date or date/time object.\n"
    },
    {
        "prefix": "de",
        "body": "de(${1:String})",
        "documentation": "Delay evaluation of a string as an expression, when it is passed as a parameter to the IIf or Evaluate functions. Escapes any double quotation marks in the parameter and wraps the result in double quotation marks. It does not escape `#` so the string could still be evaluated in some cases.\n\n**USAGE:**\n*string de(String)*\n\n**PARAMETERS:**\n\n*String (string)*\n"
    },
    {
        "prefix": "decimalFormat",
        "body": "decimalFormat(${1:number})",
        "documentation": " Converts a number to a decimal-formatted string.\n\n**USAGE:**\n*string decimalFormat(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "decodeForHTML",
        "body": "decodeForHTML(${1:inputString})",
        "documentation": " Decodes an HTML encoded string.\n\n**USAGE:**\n*string decodeForHTML(inputString)*\n\n**PARAMETERS:**\n\n*inputString ()* - The encoded string to decode.\n"
    },
    {
        "prefix": "decodeFromURL",
        "body": "decodeFromURL(${1:inputString})",
        "documentation": " Decodes an encoded HTML URL string.\n\n**USAGE:**\n*string decodeFromURL(inputString)*\n\n**PARAMETERS:**\n\n*inputString ()* - The encoded URL string to decode..\n"
    },
    {
        "prefix": "decrementValue",
        "body": "decrementValue(${1:number})",
        "documentation": "Decrements the integer part of a number. Same as x=x-1 or x--\n\n**USAGE:**\n*numeric decrementValue(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "decrypt",
        "body": "decrypt(${1:encrypted_string}, ${2:key})",
        "documentation": " Decrypts a string that is encrypted with the Encrypt function.\n\n**USAGE:**\n*string decrypt(encrypted_string, key [, algorithm] [, encoding] [, ivorsalt] [, iterations])*\n\n**PARAMETERS:**\n\n*encrypted_string (string)* - String to decrypt.\n\n*key (string)* - Key or seed used to encrypt the string.\n * For the CFMX_COMPAT algorithm, any combination of any\n number of characters; used as a seed used to generate\n a 32-bit encryption key.\n * For all other algorithms, a key in the format used by the\n algorithm. For these algorithms, use the GenerateSecretKey\n function to generate the key.\n\n*algorithm (string)* - The algorithm to use to decrypt the string. Must be the same\n as the algorithm used to encrypt the string.\n * CFMX_COMPAT: the algorithm used in ColdFusion MX and prior\n releases. This algorithm is the least secure option (default).\n * AES: the Advanced Encryption Standard specified by the\n National Institute of Standards and Technology (NIST) FIPS-197.\n * BLOWFISH: the Blowfish algorithm defined by Bruce Schneier.\n * DES: the Data Encryption Standard algorithm defined by NIST FIPS-46-3.\n * DESEDE: the \"Triple DES\" algorithm defined by NIST FIPS-46-3.. **Default:** *CFMX_COMPAT*. **Values:** *CFMX_COMPAT, AES, BLOWFISH, DES, DESEDE*.\n\n*encoding (string)* - The binary encoding used to represent the data as a string.\n Must be the same as the algorithm used to encrypt the string.\n * Base64: the Base64 algorithm, as specified by IETF RFC 2045.\n * Hex: the characters A-F and 0-9 represent the hexadecimal byte values.\n * UU: the UNIX standard UUEncode algorithm (default).\n If you specify this parameter, you must also specify the algorithm parameter.. **Default:** *UU*. **Values:** *UU, Base64, Hex*.\n\n*ivorsalt (binary)* - Specify this parameter to adjust ColdFusion encryption to match\n the details of other encryption software. If you specify this\n parameter, you must also specify the algorithm parameter.\n * For Block Encryption Algorithms: This is the binary\n Initialization Vector value to use with the algorithm. The\n algorithm must contain a Feedback Mode other than ECB. This\n must be a binary value that is exactly the same size as the\n algorithm block size.\n * For Password Based Encryption Algorithms: This is the binary\n Salt value to transform the password into a key.\n\n*iterations (numeric)* - The number of iterations to transform the password into a\n binary key. Specify this parameter to adjust ColdFusion\n encryption to match the details of other encryption software.\n If you specify this parameter, you must also specify the\n algorithm parameter with a Password Based Encryption (PBE)\n algorithm. Do not specify this parameter for Block Encryption\n Algorithms. You must use the same value to encrypt and\n decrypt the data.\n * For Password Based Encryption Algorithms: This is the\n binary Salt value to transform the password into a key.\n"
    },
    {
        "prefix": "decryptBinary",
        "body": "decryptBinary(${1:bytes}, ${2:key})",
        "documentation": " Decrypts encrypted binary data with the specified key, value, algorithm, salt, and iterations.\n\n**USAGE:**\n*string decryptBinary(bytes, key [, algorithm] [, ivorsalt] [, iterations])*\n\n**PARAMETERS:**\n\n*bytes (string)* - Binary data to decrypt.\n\n*key (string)* - Key or seed used to encrypt the string.\n * For the CFMX_COMPAT algorithm, any combination of any\n number of characters; used as a seed used to generate\n a 32-bit encryption key.\n * For all other algorithms, a key in the format used by the\n algorithm. For these algorithms, use the GenerateSecretKey\n function to generate the key.\n\n*algorithm (string)* - The algorithm to use to decrypt the string. Must be the same\n as the algorithm used to encrypt the string.\n * CFMX_COMPAT: the algorithm used in ColdFusion MX and prior\n releases. This algorithm is the least secure option (default).\n * AES: the Advanced Encryption Standard specified by the\n National Institute of Standards and Technology (NIST) FIPS-197.\n * BLOWFISH: the Blowfish algorithm defined by Bruce Schneier.\n * DES: the Data Encryption Standard algorithm defined by NIST FIPS-46-3.\n * DESEDE: the \"Triple DES\" algorithm defined by NIST FIPS-46-3.. **Default:** *CFMX_COMPAT*. **Values:** *CFMX_COMPAT, AES, BLOWFISH, DES, DESEDE*.\n\n*ivorsalt (binary)* - Specify this parameter to adjust ColdFusion encryption to match\n the details of other encryption software. If you specify this\n parameter, you must also specify the algorithm parameter.\n * For Block Encryption Algorithms: This is the binary\n Initialization Vector value to use with the algorithm. The\n algorithm must contain a Feedback Mode other than ECB. This\n must be a binary value that is exactly the same size as the\n algorithm block size.\n * For Password Based Encryption Algorithms: This is the binary\n Salt value to transform the password into a key.\n\n*iterations (numeric)* - The number of iterations to transform the password into a\n binary key. Specify this parameter to adjust ColdFusion\n encryption to match the details of other encryption software.\n If you specify this parameter, you must also specify the\n algorithm parameter with a Password Based Encryption (PBE)\n algorithm. Do not specify this parameter for Block Encryption\n Algorithms. You must use the same value to encrypt and\n decrypt the data.\n * For Password Based Encryption Algorithms: This is the\n binary Salt value to transform the password into a key.\n"
    },
    {
        "prefix": "deleteClientVariable",
        "body": "deleteClientVariable(${1:name})",
        "documentation": " Deletes a client variable. (To test for the existence of a\n variable, use IsDefined.)\n\n**USAGE:**\n*boolean deleteClientVariable(name)*\n\n**PARAMETERS:**\n\n*name (string)*\n"
    },
    {
        "prefix": "deserialize",
        "body": "deserialize(${1:StringToBeDeserialized}, ${2:type}, ${3:useCustomSerializer})",
        "documentation": "Deserializes a string.\n\n**USAGE:**\n*string deserialize(StringToBeDeserialized, type, useCustomSerializer)*\n\n**PARAMETERS:**\n\n*StringToBeDeserialized ()* - A string that needs to be deserialized.\n\n*type ()* - String. The type of the data to be deserialized. ColdFusion by default supports XML and JSON formats. You can also implement support for other types in the CustomSerializer CFC.\n\n*useCustomSerializer ()* - Boolean. Whether to use the custom serializer or not. The default value is true. The custom serializer will be always used for deserialization. If false, the XML/JSON deserialization will be done using the default ColdFusion behavior. If any other type is passed with useCustomSerializer as false, then TypeNotSupportedException will be thrown.\n"
    },
    {
        "prefix": "deserializeJSON",
        "body": "deserializeJSON(${1:jsonvar}, ${2:useCustomSerializer})",
        "documentation": " Converts a JSON (JavaScript Object Notation) string data representation into CFML data, such as a CFML structure or array.\n\n**USAGE:**\n*any deserializeJSON(jsonvar [, strictMapping], useCustomSerializer)*\n\n**PARAMETERS:**\n\n*jsonvar (string)* - A string that contains a valid JSON construct, or variable that represents one.\n\n*strictMapping (boolean)* - A Boolean value that specifies whether to convert the JSON strictly. If true everything becomes structures.. **Default:** *true*.\n\n*useCustomSerializer (boolean)* - CF11+ Use custom serializer if defined. See: https://helpx.adobe.com/coldfusion/developing-applications/changes-in-coldfusion/restful-web-services-in-coldfusion.html. **Default:** *true*.\n"
    },
    {
        "prefix": "deserializeXML",
        "body": "deserializeXML(${1:StringToBeDeserialized}, ${2:useCustomSerializer})",
        "documentation": "Deserializes a string in XML format to a ColdFusion object.\n\n**USAGE:**\n*any deserializeXML(StringToBeDeserialized, useCustomSerializer)*\n\n**PARAMETERS:**\n\n*StringToBeDeserialized ()* - A string that needs to be deserialized.\n\n*useCustomSerializer ()* - Boolean. Whether to use the custom serializer or not. The default value is true. The custom serializer will be always used for XML deserialization. If false, the XML/JSON deserialization will be done using the default ColdFusion behavior. If any other type is passed with useCustomSerializer as false, then TypeNotSupportedException will be thrown.\n"
    },
    {
        "prefix": "directoryCopy",
        "body": "directoryCopy(${1:source}, ${2:destination})",
        "documentation": "Copies the contents of a directory to a destination directory\n\n**USAGE:**\n*void directoryCopy(source, destination [, recurse] [, filter] [, createPath])*\n\n**PARAMETERS:**\n\n*source (string)* - Pathname of directory from which you copy content.\n\n*destination (string)* - Path of the destination directory. If not an absolute path, it is relative to the source directory.\n\n*recurse (boolean)* - If true, copies the subdirectories, otherwise only the files in the source directory.. **Default:** *false*.\n\n*filter (any)* - Filter to be used to filter the data copied: - A string that uses \"*\" as a wildcard, for example, \"*.cfm\" - a UDF (User defined Function) using the following pattern \"functioname(String path):boolean\", the function is run for every single file, if the function returns true, then the file is will be added to the list otherwise it will be omitted.\n\n*createPath (boolean)* - Lucee4.5+ If set to false, expects all parent directories to exist. If set to true, it will generate necessary directories.. **Default:** *true*.\n"
    },
    {
        "prefix": "directoryCreate",
        "body": "directoryCreate(${1:path})",
        "documentation": " Creates new directory for specified path\n\n**USAGE:**\n*void directoryCreate(path)*\n\n**PARAMETERS:**\n\n*path (string)*\n"
    },
    {
        "prefix": "directoryDelete",
        "body": "directoryDelete(${1:path}, ${2|true,false|})",
        "documentation": " Deltes directory for given path\n\n**USAGE:**\n*void directoryDelete(path, recurse)*\n\n**PARAMETERS:**\n\n*path (string)*\n\n*recurse (boolean)* **Values:** *true, false*.\n"
    },
    {
        "prefix": "directoryExists",
        "body": "directoryExists(${1:absolute_path})",
        "documentation": " Determines whether a directory exists.\n\n**USAGE:**\n*boolean directoryExists(absolute_path)*\n\n**PARAMETERS:**\n\n*absolute_path (string)*\n"
    },
    {
        "prefix": "directoryList",
        "body": "directoryList(${1:path})",
        "documentation": "List the contents of a directory. Returns either an array, or a query.\n\n**USAGE:**\n*any directoryList(path [, recurse] [, listInfo] [, filter] [, sort] [, type])*\n\n**PARAMETERS:**\n\n*path (string)* - The path to a directory. If given a relative path, that path will be relative to the server\"s temp directory.\n\n*recurse (boolean)* - If `true` directoryList traverses the directory tree.. **Default:** *false*. **Values:** *true, false*.\n\n*listInfo (string)* - Sets the return type. `name` returns an array with only the file names, `path` returns an array with the full path names and `query` returns a query containing the follwing fields: `Attributes`, `DateLastModified`, `Directory`, `Link`, `Mode`, `Name`, `Size`, `Type`.. **Default:** *path*. **Values:** *name, path, query*.\n\n*filter (string)* - Applies a filter to the listed files, for example, `*.jpg`. Multiple filters can be applied by using a pipe delimiter. For example: `*.doc|*.xls`\n\n*sort (string)* - Columns by which to sort. e.g. `Directory, Size DESC, DateLastModified`.\n\n*type (string)* - CF11+ Lucee5+ Filter the result to only include files, directories, or both.. **Default:** *all*. **Values:** *file, dir, all*.\n"
    },
    {
        "prefix": "directoryRename",
        "body": "directoryRename(${1:path}, ${2:newPath})",
        "documentation": " Renames given directory\n\n**USAGE:**\n*void directoryRename(path, newPath)*\n\n**PARAMETERS:**\n\n*path (string)*\n\n*newPath (string)*\n"
    },
    {
        "prefix": "directorySize",
        "body": "directorySize(${1:path})",
        "documentation": " Returns size of given directory\n\n**USAGE:**\n*numeric directorySize(path)*\n\n**PARAMETERS:**\n\n*path (string)*\n"
    },
    {
        "prefix": "dollarFormat",
        "body": "dollarFormat(${1:number})",
        "documentation": "Formats a money string in U.S. currency format.\n\n**USAGE:**\n*string dollarFormat(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "dotnetToCFType",
        "body": "dotnetToCFType(${1:variable_name})",
        "documentation": " Explicitly converts a value returned by a .NET method to the corresponding ColdFusion data type.\n\n**USAGE:**\n*any dotnetToCFType(variable_name)*\n\n**PARAMETERS:**\n\n*variable_name (Varible)*\n"
    },
    {
        "prefix": "duplicate",
        "body": "duplicate(${1:variable})",
        "documentation": " Returns a clone, also known as a deep copy, of a variable\n or XML object. There is no reference to the original variable.\n\n**USAGE:**\n*any duplicate(variable)*\n\n**PARAMETERS:**\n\n*variable (any)*\n"
    },
    {
        "prefix": "each",
        "body": "each(${1:collection}, ${2:closure})",
        "documentation": "Same as collectionEach expect it has the two additional optinal params `parallel` and `maxThreads`\n\n**USAGE:**\n*void each(collection, closure [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*collection (any)*\n\n*closure (function)*\n\n*parallel (boolean)*\n\n*maxThreads (numeric)*. **Default:** *20*.\n"
    },
    {
        "prefix": "echo",
        "body": "echo(${1:string})",
        "documentation": "While writeOutput writes to the page-output stream, this function writes to the main response buffer\n\n**USAGE:**\n*boolean echo(string)*\n\n**PARAMETERS:**\n\n*string (string)* - String to be written to the output buffer\n"
    },
    {
        "prefix": "empty",
        "body": "empty(${1|\"\",{},[]|})",
        "documentation": "Checks if a variable is empty\n\n**USAGE:**\n*boolean empty(variable)*\n\n**PARAMETERS:**\n\n*variable (any)* **Values:** *\"\", {}, []*.\n"
    },
    {
        "prefix": "encodeForCSS",
        "body": "encodeForCSS(${1:inputString})",
        "documentation": " Encodes the input string for use in CSS.\n\n**USAGE:**\n*string encodeForCSS(inputString [, canonicalize])*\n\n**PARAMETERS:**\n\n*inputString ()* - The string to encode.\n\n*canonicalize ()* - If set to true, canonicalization happens before encoding. If set to false, the given input string will just be encoded. The default value for canonicalize is false. When this parameter is not specified, canonicalization will not happen. By default, when canonicalization is performed, both mixed and multiple encodings will be allowed. To use any other combinations you should canonicalize using canonicalize method and then do encoding.\n"
    },
    {
        "prefix": "encodeForDN",
        "body": "encodeForDN(${1:string})",
        "documentation": "Encodes the given string for safe output in LDAP Distinguished Names. Lucee only, not supported on Adobe CF.\n\n**USAGE:**\n*string encodeForDN(string)*\n\n**PARAMETERS:**\n\n*string ()* - string to encode.\n"
    },
    {
        "prefix": "encodeForHTML",
        "body": "encodeForHTML(${1:inputString})",
        "documentation": "Encodes the inputString for safe output in the body of a HTML tag. The encoding in meant to mitigate Cross Site Scripting (XSS) attacks. This function can provide more protection from XSS than the HTMLEditFormat or XMLFormat functions do.\n\n**USAGE:**\n*string encodeForHTML(inputString [, canonicalize])*\n\n**PARAMETERS:**\n\n*inputString (string)* - A string to encode\n\n*canonicalize (boolean)* - When true runs the canonicalize function against the input before encoding. This argument is not supported on Lucee.\n"
    },
    {
        "prefix": "encodeForHTMLAttribute",
        "body": "encodeForHTMLAttribute(${1:inputString})",
        "documentation": "Encodes the inputString for safe output in the attribute value of an HTML attribute, such as table width or image height. The encoding is meant to mitigate Cross Site Scripting (XSS) attacks.\n\n**USAGE:**\n*string encodeForHTMLAttribute(inputString [, canonicalize])*\n\n**PARAMETERS:**\n\n*inputString (string)* - A string to encode\n\n*canonicalize (boolean)* - When true runs the canonicalize function against the input before encoding. This argument is not supported on Lucee.\n"
    },
    {
        "prefix": "encodeForJavaScript",
        "body": "encodeForJavaScript(${1:inputString})",
        "documentation": "Encodes the inputString for safe output within JavaScript code. The encoding in meant to mitigate Cross Site Scripting (XSS) attacks. This function can provide more protection from XSS than JSStringFormat does.\n\n**USAGE:**\n*string encodeForJavaScript(inputString [, canonicalize])*\n\n**PARAMETERS:**\n\n*inputString (string)* - A string to encode\n\n*canonicalize (boolean)* - When true runs the canonicalize function against the input before encoding. This argument is not supported on Lucee.\n"
    },
    {
        "prefix": "encodeForLDAP",
        "body": "encodeForLDAP(${1:string})",
        "documentation": "Encodes the given string for safe output in LDAP queries.\n\n**USAGE:**\n*string encodeForLDAP(string)*\n\n**PARAMETERS:**\n\n*string ()* - String to encode.\n"
    },
    {
        "prefix": "encodeForURL",
        "body": "encodeForURL(${1:inputString})",
        "documentation": "Encodes the input string for use in URLs.\n\n**USAGE:**\n*string encodeForURL(inputString [, canonicalize])*\n\n**PARAMETERS:**\n\n*inputString ()* - The string to encode.\n\n*canonicalize ()* - If set to true, canonicalization happens before encoding. If set to false, the given input string will just be encoded. The default value for canonicalize is false. When this parameter is not specified, canonicalization will not happen. By default, when canonicalization is performed, both mixed and multiple encodings will be allowed. To use any other combinations you should canonicalize using canonicalize method and then do encoding.\n"
    },
    {
        "prefix": "encodeForXML",
        "body": "encodeForXML(${1:inputString})",
        "documentation": "Encodes a string for safe use within an XML tag body. Use `encodeForXMLAttribute` for variables output inside an XML attribute value.\n\n**USAGE:**\n*string encodeForXML(inputString [, canonicalize])*\n\n**PARAMETERS:**\n\n*inputString ()* - The string to encode.\n\n*canonicalize (boolean)* - When `true` the canonicalize function is called before encoding the input. If set to false, the given input string will just be encoded, both mixed and multiple encodings will be allowed.. **Default:** *false*. **Values:** *true, false*.\n"
    },
    {
        "prefix": "encodeForXMLAttribute",
        "body": "encodeForXMLAttribute(${1:inputString})",
        "documentation": "Encodes a string for safe output within an XML attribute. Use encodeForXML when outputting a variable inside a XML tag body.\n\n**USAGE:**\n*string encodeForXMLAttribute(inputString [, canonicalize])*\n\n**PARAMETERS:**\n\n*inputString ()* - The string to encode.\n\n*canonicalize (boolean)* - When `true` the canonicalize function is called before encoding the input. If set to false, the given input string will just be encoded, both mixed and multiple encodings will be allowed.. **Default:** *false*. **Values:** *true, false*.\n"
    },
    {
        "prefix": "encodeForXPath",
        "body": "encodeForXPath(${1:inputString})",
        "documentation": "Returns an encoded string for using with XPATH.\n\n**USAGE:**\n*string encodeForXPath(inputString [, canonicalize])*\n\n**PARAMETERS:**\n\n*inputString (string)* - The string to encode.\n\n*canonicalize (boolean)* - If set to true, canonicalization happens before encoding.\nIf set to false, the given input string will just be encoded. The default value for canonicalize is false.\nWhen this parameter is not specified, canonicalization will not happen.\n\nBy default, when canonicalization is performed, both mixed and multiple encodings will be allowed. To use any other combinations you should canonicalize using canonicalize method and then do encoding.\n"
    },
    {
        "prefix": "encrypt",
        "body": "encrypt(${1:String}, ${2:key})",
        "documentation": " Encrypts a string. Uses a symmetric key-based algorithm, in which the same key is used to encrypt and decrypt a string. The security of the encrypted string depends on maintaining the secrecy of the key. Algorithm support is determined by the installed default JCE provider.\n\n**USAGE:**\n*string encrypt(String, key [, algorithm] [, encoding] [, ivorsalt] [, iterations])*\n\n**PARAMETERS:**\n\n*String (string)* - String to encrypt.\n\n*key (string)* - Key or seed used to encrypt the string.\n * For the CFMX_COMPAT algorithm, any combination of any number of characters; used as a seed used to generate a 32-bit encryption key.\n * For all other algorithms, a key in the format used by the\n algorithm. For these algorithms, use the GenerateSecretKey\n function to generate the key.\n\n*algorithm (string)* - The algorithm to use to encrypt the string. \n * CFMX_COMPAT: the algorithm used in ColdFusion MX and prior releases. This algorithm is the least secure option (default).\n * AES: the Advanced Encryption Standard specified by the National Institute of Standards and Technology (NIST) FIPS-197.\n * BLOWFISH: the Blowfish algorithm defined by Bruce Schneier.\n * DES: the Data Encryption Standard algorithm defined by NIST FIPS-46-3.\n * DESEDE: the \"Triple DES\" algorithm defined by NIST FIPS-46-3.. **Default:** *CFMX_COMPAT*. **Values:** *CFMX_COMPAT, AES, BLOWFISH, DES, DESEDE*.\n\n*encoding (string)* - The binary encoding used to represent the data as a string.\n Must be the same as the algorithm used to encrypt the string.\n * Base64: the Base64 algorithm, as specified by IETF RFC 2045.\n * Hex: the characters A-F and 0-9 represent the hexadecimal byte values.\n * UU: the UNIX standard UUEncode algorithm (default).\n If you specify this parameter, you must also specify the algorithm parameter.. **Default:** *UU*. **Values:** *UU, Base64, Hex*.\n\n*ivorsalt (binary)* - Specify this parameter to adjust ColdFusion encryption to match\n the details of other encryption software. If you specify this\n parameter, you must also specify the algorithm parameter.\n * For Block Encryption Algorithms: This is the binary\n Initialization Vector value to use with the algorithm. The\n algorithm must contain a Feedback Mode other than ECB. This\n must be a binary value that is exactly the same size as the\n algorithm block size.\n * For Password Based Encryption Algorithms: This is the binary\n Salt value to transform the password into a key.\n\n*iterations (numeric)* - The number of iterations to transform the password into a\n binary key. Specify this parameter to adjust ColdFusion\n encryption to match the details of other encryption software.\n If you specify this parameter, you must also specify the\n algorithm parameter with a Password Based Encryption (PBE)\n algorithm. Do not specify this parameter for Block Encryption\n Algorithms. You must use the same value to encrypt and\n decrypt the data.\n * For Password Based Encryption Algorithms: This is the\n binary Salt value to transform the password into a key.\n"
    },
    {
        "prefix": "encryptBinary",
        "body": "encryptBinary(${1:bytes}, ${2:key})",
        "documentation": " Encrypts binary data using a specific algorithm and encoding method.\n\n**USAGE:**\n*string encryptBinary(bytes, key [, algorithm] [, ivorsalt] [, iterations])*\n\n**PARAMETERS:**\n\n*bytes (string)* - Bindary data to encrypt.\n\n*key (string)* - Key or seed used to encrypt the string.\n * For the CFMX_COMPAT algorithm, any combination of any\n number of characters; used as a seed used to generate\n a 32-bit encryption key.\n * For all other algorithms, a key in the format used by the\n algorithm. For these algorithms, use the GenerateSecretKey\n function to generate the key.\n\n*algorithm (string)* - The algorithm to use to encrypt the string. \n * CFMX_COMPAT: the algorithm used in ColdFusion MX and prior\n releases. This algorithm is the least secure option (default).\n * AES: the Advanced Encryption Standard specified by the\n National Institute of Standards and Technology (NIST) FIPS-197.\n * BLOWFISH: the Blowfish algorithm defined by Bruce Schneier.\n * DES: the Data Encryption Standard algorithm defined by NIST FIPS-46-3.\n * DESEDE: the \"Triple DES\" algorithm defined by NIST FIPS-46-3.. **Default:** *CFMX_COMPAT*. **Values:** *CFMX_COMPAT, AES, BLOWFISH, DES, DESEDE*.\n\n*ivorsalt (binary)* - Specify this parameter to adjust ColdFusion encryption to match\n the details of other encryption software. If you specify this\n parameter, you must also specify the algorithm parameter.\n * For Block Encryption Algorithms: This is the binary\n Initialization Vector value to use with the algorithm. The\n algorithm must contain a Feedback Mode other than ECB. This\n must be a binary value that is exactly the same size as the\n algorithm block size.\n * For Password Based Encryption Algorithms: This is the binary\n Salt value to transform the password into a key.\n\n*iterations (numeric)* - The number of iterations to transform the password into a\n binary key. Specify this parameter to adjust ColdFusion\n encryption to match the details of other encryption software.\n If you specify this parameter, you must also specify the\n algorithm parameter with a Password Based Encryption (PBE)\n algorithm. Do not specify this parameter for Block Encryption\n Algorithms. You must use the same value to encrypt and\n decrypt the data.\n * For Password Based Encryption Algorithms: This is the\n binary Salt value to transform the password into a key.\n"
    },
    {
        "prefix": "entityDelete",
        "body": "entityDelete(${1:entity})",
        "documentation": " Deletes the record from the database for the specified entity.\nentityDelete(entity)\n\n**USAGE:**\n*void entityDelete(entity)*\n\n**PARAMETERS:**\n\n*entity (variableName)* - Name of the entity being deleted.\n"
    },
    {
        "prefix": "entityLoad",
        "body": "entityLoad(${1:entityName})",
        "documentation": "Loads and returns an array of entities of the specified entityname or an entity if unique=true or if a primary key id is passed in to filterCriteria.\n\n**USAGE:**\n*any entityLoad(entityName [, filterCriteria] [, unique] [, sortOrder] [, options])*\n\n**PARAMETERS:**\n\n*entityName (string)* - Name of CFC / Entity\n\n*filterCriteria (any)* - A struct of key value pairs, or a primary key value\n\n*unique (boolean)* - When true a single entity is returned, otherwise an array\n\n*sortOrder (string)* - Column name and direction list, eg: LastName ASC, FirstName ASC\n\n*options (struct)* - A struct with possible keys: ignorecase, sortorder, offset, maxresults, cacheable, cachename, timeout\n"
    },
    {
        "prefix": "entityLoadByExample",
        "body": "entityLoadByExample(${1:sampleEntity})",
        "documentation": " Loads and returns an array of objects that match the sampleentity.\nentityLoadByExample(sampleEntity,[unique])\n\n**USAGE:**\n*any entityLoadByExample(sampleEntity [, unique])*\n\n**PARAMETERS:**\n\n*sampleEntity (string)* - No Help Available\n\n*unique (boolean)* - No Help Available\n"
    },
    {
        "prefix": "entityLoadByPK",
        "body": "entityLoadByPK(${1:entityName}, ${2:id})",
        "documentation": " Loads and returns an array of objects for given primary key.\n\n**USAGE:**\n*any entityLoadByPK(entityName, id [, unique])*\n\n**PARAMETERS:**\n\n*entityName (string)* - Name of the entity to be loaded\n\n*id (string)* - ID of the entity to be loaded\n\n*unique (boolean)* - Lucee4.5+ Specify whether you expect multiple or just one record\nIf set to `true`, the entity is returned\nIf set to `false` an array is returned to support multiple entities\nIf set to `true` but multiple entities would be returned an error will be thrown\n"
    },
    {
        "prefix": "entityMerge",
        "body": "entityMerge(${1:entity})",
        "documentation": " Attaches given enity to current ORM session\n\n**USAGE:**\n*any entityMerge(entity)*\n\n**PARAMETERS:**\n\n*entity (variableName)* - The entity that must be attached to the ORM session.\n"
    },
    {
        "prefix": "entityNameArray",
        "body": "entityNameArray()",
        "documentation": "Returns an array of all loaded entities\n\n**USAGE:**\n*array entityNameArray()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "entityNameList",
        "body": "entityNameList()",
        "documentation": "Returns a list of all loaded entities\n\n**USAGE:**\n*string entityNameList( [delimiter])*\n\n**PARAMETERS:**\n\n*delimiter (string)*\n"
    },
    {
        "prefix": "entityNew",
        "body": "entityNew(${1:entityName})",
        "documentation": " Creates a new instance of the persistent CFC with the entity name that you provide.\n\n**USAGE:**\n*any entityNew(entityName)*\n\n**PARAMETERS:**\n\n*entityName (string)* - Entity name of the persistent CFC.\n"
    },
    {
        "prefix": "entityReload",
        "body": "entityReload(${1:entity})",
        "documentation": " Reloads data for an entity that is already loaded.\n\n**USAGE:**\n*void entityReload(entity)*\n\n**PARAMETERS:**\n\n*entity (variableName)* - No Help Available\n"
    },
    {
        "prefix": "entitySave",
        "body": "entitySave(${1:entity})",
        "documentation": " Saves or updates data of the entity and all related entities to the database.\nentitySave(entity, [forceinsert])\n\n**USAGE:**\n*void entitySave(entity [, forceInsert])*\n\n**PARAMETERS:**\n\n*entity (variableName)* - Name of the entity that must be saved in the database.\n\n*forceInsert (boolean)* - If true, then ColdFusion always tries to insert the entity as a new record. **Values:** *true, false*.\n"
    },
    {
        "prefix": "entityToQuery",
        "body": "entityToQuery(${1:orm_object})",
        "documentation": " Converts the input entity object or the input array of entity objects to a query object.\nentityToQuery (orm_object, [entity_name]) \nentityToQuery (orm_object_array, [entity_name])\n\n**USAGE:**\n*query entityToQuery(orm_object [, entity_name])*\n\n**PARAMETERS:**\n\n*orm_object (variableName)* - Entity object that needs to be converted to a query object.\n\n*entity_name (string)* - Name of the entity. Use this optional parameter to return the query of the given entity in the case of inheritance mapping.\n"
    },
    {
        "prefix": "esapiDecode",
        "body": "esapiDecode(${1:decodeFrom}, ${2:string})",
        "documentation": "\n\n**USAGE:**\n*string esapiDecode(decodeFrom, string)*\n\n**PARAMETERS:**\n\n*decodeFrom (string)*\n\n*string (string)*\n"
    },
    {
        "prefix": "esapiEncode",
        "body": "esapiEncode(${1:encodeFor}, ${2:string})",
        "documentation": "Warning: esapiEncode() is deprecated, use encodeForHTML() instead! A Railo/Lucee specific function for calling the various encodeFor functions: encodeForHTML, etc. Not supported in ACF.\n\n**USAGE:**\n*string esapiEncode(encodeFor, string)*\n\n**PARAMETERS:**\n\n*encodeFor (string)* - Required. Encode for what, valid values are: - css: for output inside Cascading Style Sheets (CSS) - dn: for output in LDAP Distinguished Names - html: for output inside HTML - html_attr: for output inside HTML Attributes - javascript: for output inside Javascript - ldap: for output in LDAP queries - url: for output in URL - vbscript: for output inside vbscript - xml: for output inside XML - xml_attr: for output inside XML Attributes - xpath: for output in XPath.\n\n*string (string)* - Required. String to encode.\n"
    },
    {
        "prefix": "evaluate",
        "body": "evaluate(${1:expression1})",
        "documentation": "Evaluates one or more string expressions, dynamically, from left to right. (The results of an evaluation on the left can have meaning in an expression to the right.) Returns the result of evaluating the rightmost expression.\n\n**USAGE:**\n*any evaluate(expression1 [, expression2] [, expressionN])*\n\n**PARAMETERS:**\n\n*expression1 (string)*\n\n*expression2 (string)*\n\n*expressionN (string)*\n"
    },
    {
        "prefix": "exp",
        "body": "exp(${1:number})",
        "documentation": " Calculates the exponent whose base is e that represents number.\n The constant e equals 2.71828182845904, the base of the natural\n logarithm. This function is the inverse of Log, the natural\n logarithm of number.\n\n**USAGE:**\n*numeric exp(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "expandPath",
        "body": "expandPath(${1:relative_path})",
        "documentation": " Creates an absolute, platform-appropriate path that is\n equivalent to the value of relative_path, appended to the base\n path. This function (despite its name) can accept an absolute\n or relative path in the relative_path attribute\n\n**USAGE:**\n*string expandPath(relative_path)*\n\n**PARAMETERS:**\n\n*relative_path (string)*\n"
    },
    {
        "prefix": "extract",
        "body": "extract(${1|bzip,bzip2,tbz,tbz2,tar,tar.bz,tar.gz,gzip,tgz,zip|}, ${2:source}, ${3:target})",
        "documentation": "Extract the data of a compressed file.\n\n**USAGE:**\n*boolean extract(format, source, target)*\n\n**PARAMETERS:**\n\n*format (string)* - The format of the compressed file. **Values:** *bzip, bzip2, tbz, tbz2, tar, tar.bz, tar.gz, gzip, tgz, zip*.\n\n*source (string)* - Path (relative or absolute) to the source-file or a directory with zip-files.\n\n*target (string)* - Path (relative or absolute) to the the directory, where you want to extract the data.\n"
    },
    {
        "prefix": "fileAppend",
        "body": "fileAppend(${1:filePath}, ${2:data})",
        "documentation": "Appends the data contents to the file.\n\n**USAGE:**\n*void fileAppend(filePath, data [, charset])*\n\n**PARAMETERS:**\n\n*filePath (string)* - File path\n\n*data (string)* - Data to append to the file\n\n*charset (string)* - The character encoding in which the file contents is encoded.\n"
    },
    {
        "prefix": "fileClose",
        "body": "fileClose(${1:fileObj})",
        "documentation": "Closes an on-disk or in-memory file that is open.\n\n**USAGE:**\n*void fileClose(fileObj)*\n\n**PARAMETERS:**\n\n*fileObj (any)* - A file object\n"
    },
    {
        "prefix": "fileCopy",
        "body": "fileCopy(${1:source}, ${2:destination})",
        "documentation": " Copies the specified on-disk or in-memory source file to the specified destination file.\n\n**USAGE:**\n*void fileCopy(source, destination)*\n\n**PARAMETERS:**\n\n*source (string)* - Path where the file is located currently\n\n*destination (string)* - Path where a copy of the file should be placed\n"
    },
    {
        "prefix": "fileDelete",
        "body": "fileDelete(${1:filepath})",
        "documentation": "Deletes the specified file on the server. fileDelete throws an exception whenever a file doesn't exist.\n\n**USAGE:**\n*void fileDelete(filepath)*\n\n**PARAMETERS:**\n\n*filepath ()* - Pathname of the file to delete. If not an absolute path (starting with a drive letter and a colon, or a forward or backward slash), it is relative to the ColdFusion temporary directory, which is returned by the GetTempDirectory function.\n"
    },
    {
        "prefix": "fileExists",
        "body": "fileExists(${1:path})",
        "documentation": " Determines whether a file exists\n\n**USAGE:**\n*boolean fileExists(path)*\n\n**PARAMETERS:**\n\n*path (string)*\n"
    },
    {
        "prefix": "fileGetMimeType",
        "body": "fileGetMimeType(${1:path}, ${2:fileObject}, ${3:strict})",
        "documentation": " Gets the MIME type for the file path/file object you have specified.\n\n**USAGE:**\n*string fileGetMimeType(path, fileObject, strict)*\n\n**PARAMETERS:**\n\n*path ()* - Full path on disk to the file if strict is set to true.If you do not specify the full path, the file is assumed to be present in the temp directory, as returned by the function getTempDirectory.\n\n*fileObject ()* - Name of the file object.\n\n*strict ()* - If false, determines the file type by extension. The default value is true.\n"
    },
    {
        "prefix": "fileIsEOF",
        "body": "fileIsEOF(${1:fileObject})",
        "documentation": " Determines whether ColdFusion has reached the end of the file while reading it.\n\n**USAGE:**\n*boolean fileIsEOF(fileObject)*\n\n**PARAMETERS:**\n\n*fileObject (any)* - The file object.\n"
    },
    {
        "prefix": "fileMove",
        "body": "fileMove(${1:source}, ${2:destination})",
        "documentation": " Moves file from source to destination\n\n**USAGE:**\n*void fileMove(source, destination)*\n\n**PARAMETERS:**\n\n*source ()* - No Help Available\n\n*destination ()* - No Help Available\n"
    },
    {
        "prefix": "fileOpen",
        "body": "fileOpen(${1:filePath})",
        "documentation": "Opens a file\n\n**USAGE:**\n*any fileOpen(filePath [, mode] [, charset])*\n\n**PARAMETERS:**\n\n*filePath ()* - An absolute path of an on-disk or in-memory file on the server\n\n*mode ()* - Type of access you require to the file stream. **Default:** *read*. **Values:** *read, readBinary, write, append*.\n\n*charset ()* - Character encoding identified by the file's byte order mark, if any; otherwise, JVM default file character set **Values:** *utf-8, iso-8859-1, windows-1252, us-ascii, shift_jis, iso-2022-jp, euc-jp, euc-kr, big5, euc-cn, utf-16*.\n"
    },
    {
        "prefix": "fileRead",
        "body": "fileRead(${1:filepath})",
        "documentation": " Reads an on-disk or in-memory text file or a file object created with the FileOpen function.\n\n**USAGE:**\n*string fileRead(filepath [, charset])*\n\n**PARAMETERS:**\n\n*filepath (string)* - An absolute file path, or file object.\n\n*charset (string)* - Character encoding used to read the file **Values:** *utf-8, iso-8859-1, windows-1252, us-ascii*.\n"
    },
    {
        "prefix": "fileReadBinary",
        "body": "fileReadBinary(${1:filePath})",
        "documentation": "Reads an on-disk or in-memory binary file (such as an executable or image file) on the server, into a binary object\n\n**USAGE:**\n*binary fileReadBinary(filePath)*\n\n**PARAMETERS:**\n\n*filePath (string)* - No Help Available\n"
    },
    {
        "prefix": "fileReadLine",
        "body": "fileReadLine(${1:fileObj})",
        "documentation": "Returns the next line from the file\n\n**USAGE:**\n*string fileReadLine(fileObj)*\n\n**PARAMETERS:**\n\n*fileObj ()* - file object previously opened with fileOpen()\n"
    },
    {
        "prefix": "fileSeek",
        "body": "fileSeek(${1:file}, ${2:position})",
        "documentation": " Shifts the file pointer to the given position. The file must be opened with seekable option\n\n**USAGE:**\n*void fileSeek(file, position)*\n\n**PARAMETERS:**\n\n*file (variableName)* - No Help Available\n\n*position (numeric)* - No Help Available\n"
    },
    {
        "prefix": "fileSetAccessMode",
        "body": "fileSetAccessMode(${1:filePath}, ${2:mode})",
        "documentation": " Sets the attributes of an on-disk file on UNIX or Linux. This function does not work with in-memory files.\n\n**USAGE:**\n*void fileSetAccessMode(filePath, mode)*\n\n**PARAMETERS:**\n\n*filePath (string)* - No Help Available\n\n*mode (string)* - No Help Available\n"
    },
    {
        "prefix": "fileSetAttribute",
        "body": "fileSetAttribute(${1:filePath}, ${2|readOnly,hidden,normal|})",
        "documentation": "Sets the attributes of an on-disk file in Windows. This function does not work with in-memory files.\n\n**USAGE:**\n*void fileSetAttribute(filePath, attribute)*\n\n**PARAMETERS:**\n\n*filePath (string)* - Path to on-disk file\n\n*attribute (string)* - Attribute to enable/disable\n\nreadonly/hidden sets the given attribute to `true` and the other one to `false`\nnormal sets both to false **Values:** *readOnly, hidden, normal*.\n"
    },
    {
        "prefix": "fileSetLastModified",
        "body": "fileSetLastModified(${1:filePath}, ${2:date})",
        "documentation": " Sets the date when an on-disk or in-memory file was most recently modified.\n\n**USAGE:**\n*void fileSetLastModified(filePath, date)*\n\n**PARAMETERS:**\n\n*filePath (string)* - No Help Available\n\n*date (date)* - No Help Available\n"
    },
    {
        "prefix": "fileSkipBytes",
        "body": "fileSkipBytes(${1:file}, ${2:bytes})",
        "documentation": " Shifts the file pointer by the given number of bytes.\n\n**USAGE:**\n*void fileSkipBytes(file, bytes)*\n\n**PARAMETERS:**\n\n*file (variableName)* - No Help Available\n\n*bytes (numeric)* - No Help Available\n"
    },
    {
        "prefix": "fileUpload",
        "body": "fileUpload(${1:destination})",
        "documentation": "Uploads file to a directory on the server.\n\n**USAGE:**\n*struct fileUpload(destination [, fileField] [, nameConflict] [, accept] [, strict])*\n\n**PARAMETERS:**\n\n*destination (string)* - Path of directory in which to upload the file. If not an absolute path (starting with a drive letter and a colon, or a forward or backward slash), it is relative to the ColdFusion temporary directory returned by the function getTempDirectory. If the destination you specify does not exist, ColdFusion creates a file with the specified destination name.\n\n*fileField (string)* - Name of form field used to select the file. Do not use number signs (#) to specify the field name.\n\n*nameConflict (string)* - Action to take if file has the same name of a file in the directory. **Values:** *error, skip, overwrite, makeunique*.\n\n*accept (string)* - Specify a comma-delimited list of MIME types and/or file extensions to test the uploaded file against. If the file is not of any of the types in this list, an error of type `coldfusion.tagext.io.FileUtils$InvalidUploadTypeException`is thrown.\nIf you specify file extensions, use this format: `.txt,.jpg`, not `txt`, `*.txt`, or `*.*`. You can use `*` as a wildcard to accept all files.\n\n*strict (boolean)* - CF10+ Defines which method is used to determine the file type to check against the value of the `accept` attribute.\n`true:` The first few bytes of the uploaded file are used to determine the MIME type.\n`false:` The MIME type provided by the browser in the request payload is used.. **Default:** *true*. **Values:** *true, false*.\n"
    },
    {
        "prefix": "fileUploadAll",
        "body": "fileUploadAll(${1:destination})",
        "documentation": "Uploads all files sent to the page in an HTTP request to a directory on the server.\n\n**USAGE:**\n*array fileUploadAll(destination [, accept] [, nameConflict])*\n\n**PARAMETERS:**\n\n*destination (string)* - Path of directory in which to upload the file. If not an absolute path (starting with a drive letter and a colon, or a forward or backward slash), it is relative to the ColdFusion temporary directory returned by the function getTempDirectory. If the destination you specify does not exist, ColdFusion creates a file with the specified destination name.\n\n*accept (string)* - Limits the MIME types to accept. Comma-delimited list. For example, the following code permits JPEG and Microsoft Word file uploads:'image/jpg,application/msword' .The browser uses the filename extension to determine file type.\n\n*nameConflict (string)* - Action to take if file has the same name of a file in the directory. **Values:** *Error, Skip, Overwrite, MakeUnique*.\n"
    },
    {
        "prefix": "fileWrite",
        "body": "fileWrite(${1:file}, ${2:data})",
        "documentation": "Writes the data to the file object or file path speficied using the charset specified or the java default character set if unspecified.\n\n**USAGE:**\n*void fileWrite(file, data [, charset])*\n\n**PARAMETERS:**\n\n*file (any)* - A file object or a file system path string.\n\n*data (String)* - The variable to  write to the file.\n\n*charset (String)* - An optional character set that the data is encoded with. Defaults to the Java default character set (which is usually UTF-8).\n"
    },
    {
        "prefix": "fileWriteLine",
        "body": "fileWriteLine(${1:fileobj}, ${2:content})",
        "documentation": "Appends content to an existing file\n\n**USAGE:**\n*void fileWriteLine(fileobj, content)*\n\n**PARAMETERS:**\n\n*fileobj (any)* - The file where you want to add your content\n\n*content (string)*\n"
    },
    {
        "prefix": "find",
        "body": "find(${1:substring}, ${2:String})",
        "documentation": " Finds the first occurrence of a substring in a string, from a\n specified start position. The search is case-sensitive.\n\n**USAGE:**\n*numeric find(substring, String [, start])*\n\n**PARAMETERS:**\n\n*substring (string)* - The string you are looking for.\n\n*String (string)* - The string to search in.\n\n*start (numeric)* - The position to start searching in the string (starts at 1). **Default:** *1*. **Values:** *1*.\n"
    },
    {
        "prefix": "findNoCase",
        "body": "findNoCase(${1:substring}, ${2:String})",
        "documentation": " Finds the first occurrence of a substring in a string, from a\n specified start position. If substring is not in string,\n returns zero. The search is case-insensitive.\n\n**USAGE:**\n*numeric findNoCase(substring, String [, start])*\n\n**PARAMETERS:**\n\n*substring (string)*\n\n*String (string)*\n\n*start (numeric)*. **Default:** *1*. **Values:** *1*.\n"
    },
    {
        "prefix": "findOneOf",
        "body": "findOneOf(${1:set}, ${2:string})",
        "documentation": " Finds the first occurrence of any one of a set of characters in a string,\n from a specified start position. The search is case-sensitive.\n\n Returns the position of the first member of set found in string; or 0, if no member of set is found in string.\n\n**USAGE:**\n*numeric findOneOf(set, string [, start])*\n\n**PARAMETERS:**\n\n*set (string)* - String which contains one or more characters to search for. \n\n*string (string)* - String in which to search. \n\n*start (numeric)* - Start position of search. Can be 1 through the length of the string to search.\n Choosing a start index greater than the length of the string to search will return a 0.. **Default:** *1*. **Values:** *1 through string length.*.\n"
    },
    {
        "prefix": "firstDayOfMonth",
        "body": "firstDayOfMonth(${1:date})",
        "documentation": " Determines the ordinal (day number, in the year) of the first\n day of the month in which a given date falls.\n\n**USAGE:**\n*numeric firstDayOfMonth(date)*\n\n**PARAMETERS:**\n\n*date (date)* - Date or date/time object.\n"
    },
    {
        "prefix": "fix",
        "body": "fix(${1:number})",
        "documentation": "Converts a real number to an integer.\n**Tip:** If you want to `fix()` to outcome of a division, simply use the integer division operator (\\).\n\n**USAGE:**\n*numeric fix(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "floor",
        "body": "floor(${1:number})",
        "documentation": "Returns the integer less than or equal to the input. This function is equivalent to the int function.\n\n**USAGE:**\n*numeric floor(number)*\n\n**PARAMETERS:**\n\n*number (numeric)* - A numeric value\n"
    },
    {
        "prefix": "formatBaseN",
        "body": "formatBaseN(${1:number}, ${2:radix})",
        "documentation": " String Converts number to a string, in the base specified by radix.\n\n**USAGE:**\n*string formatBaseN(number, radix)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n\n*radix (numeric)*\n"
    },
    {
        "prefix": "generatePBKDFKey",
        "body": "generatePBKDFKey(${1|PBKDF2WithHmacSHA1,PBKDF2WithSHA1,PBKDF2WithSHA224,PBKDF2WithSHA256,PBKDF2WithSHA384,PBKDF2WithSHA512|}, ${2:passphrase}, ${3:salt}, ${4:iterations}, ${5|true,false|})",
        "documentation": "CFML implementation of Password-Based Key-Derivation Function (PBKDF)\n\n**USAGE:**\n*string generatePBKDFKey(algorithm, passphrase, salt, iterations, keySize)*\n\n**PARAMETERS:**\n\n*algorithm (string)* - Hashing algorithm used for generating key **Values:** *PBKDF2WithHmacSHA1, PBKDF2WithSHA1, PBKDF2WithSHA224, PBKDF2WithSHA256, PBKDF2WithSHA384, PBKDF2WithSHA512*.\n\n*passphrase (string)* - Passphrase used for the key. KEEP THIS SECRET.\n\n*salt (string)* - A string which will be added to the passphrase before encryption.\n The standard recommends a salt length of at least 64 bits (8 characters). The salt needs to be generated using a pseudo-random number generator (e.g SHA1PRNG)\n\n*iterations (numeric)* - The number of PBKDEF iterations to perform. A minimum recommended value is 1000\n\n*keySize (numeric)* - The length in bytes of the key to generate **Values:** *true, false*.\n"
    },
    {
        "prefix": "generateSecretKey",
        "body": "generateSecretKey()",
        "documentation": "Generates a secure random key value for use in the encrypt and decrypt functions.\n\n**USAGE:**\n*string generateSecretKey( [algorithm] [, keysize])*\n\n**PARAMETERS:**\n\n*algorithm (string)* **Values:** *CFMX_COMPAT, AES, BLOWFISH, DES, DESEDE*.\n\n*keysize (numeric)* - Number of bits requested in the key for the specified algorithm (when allowed by JDK).. **Default:** *128*. **Values:** *128, 192, 256, 512*.\n"
    },
    {
        "prefix": "getApplicationMetadata",
        "body": "getApplicationMetadata()",
        "documentation": "Returns the application settings that you have specified in the application, either in the Application.cfc or Application.cfm. Contains application settings such as name, sessionManagement, or invokeImplicitAccessor.\n\n**USAGE:**\n*struct getApplicationMetadata()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getApplicationSettings",
        "body": "getApplicationSettings(${1:suppressFunction})",
        "documentation": "return all data from this scope, when using a application.cfc or all setting defined in tag cfapplication\n\n**USAGE:**\n*struct getApplicationSettings(suppressFunction)*\n\n**PARAMETERS:**\n\n*suppressFunction (boolean)* - if true only data members from this scope are returned (no functions), default is false. **Default:** *false*.\n"
    },
    {
        "prefix": "getAuthUser",
        "body": "getAuthUser()",
        "documentation": " Gets the name of an authenticated user.\n\n**USAGE:**\n*string getAuthUser()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getBaseTagData",
        "body": "getBaseTagData(${1:tagname})",
        "documentation": " Used within a custom tag. Finds calling (ancestor) tag by\n name and accesses its data.\n\n**USAGE:**\n*any getBaseTagData(tagname [, instancenumber])*\n\n**PARAMETERS:**\n\n*tagname (string)*\n\n*instancenumber (numeric)*\n"
    },
    {
        "prefix": "getBaseTagList",
        "body": "getBaseTagList()",
        "documentation": " Gets ancestor tag names, starting with the parent tag.\n\n**USAGE:**\n*string getBaseTagList( [delimiter])*\n\n**PARAMETERS:**\n\n*delimiter (string)*. **Default:** *,*.\n"
    },
    {
        "prefix": "getBaseTemplatePath",
        "body": "getBaseTemplatePath()",
        "documentation": "Gets the absolute server file system path of the requested CFML file.\n\n**USAGE:**\n*string getBaseTemplatePath()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getBuiltinFunction",
        "body": "getBuiltinFunction(${1:name})",
        "documentation": "\n\n**USAGE:**\n*any getBuiltinFunction(name)*\n\n**PARAMETERS:**\n\n*name (string)*\n"
    },
    {
        "prefix": "getCanonicalPath",
        "body": "getCanonicalPath(${1:path})",
        "documentation": "Returns the canonical path of the input path. If a directory a trailing slash is always used.\n\n**USAGE:**\n*string getCanonicalPath(path)*\n\n**PARAMETERS:**\n\n*path (string)*\n"
    },
    {
        "prefix": "getClassPath",
        "body": "getClassPath()",
        "documentation": "Returns an array containing the Java classpath of the current enviroment.\n\n**USAGE:**\n*array getClassPath()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getClientVariablesList",
        "body": "getClientVariablesList()",
        "documentation": " Finds the client variables to which a page has write access.\n Comma-delimited list of non-read-only client variables\n\n**USAGE:**\n*string getClientVariablesList()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getComponentMetadata",
        "body": "getComponentMetadata(${1:path})",
        "documentation": " Gets metadata (such as the functions and implemented interfaces of a component) for a CFC or ColdFusion interface.\n\n**USAGE:**\n*struct getComponentMetadata(path)*\n\n**PARAMETERS:**\n\n*path (string)* - The dot-delimited path of the interface or CFC definition.\n"
    },
    {
        "prefix": "getContextRoot",
        "body": "getContextRoot()",
        "documentation": " Returns path to the J2EE server context root for the current request.\n\n**USAGE:**\n*string getContextRoot()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getCpuUsage",
        "body": "getCpuUsage()",
        "documentation": " Gets the CPU usage with default or custom snapshot interval.\n\n**USAGE:**\n*numeric getCpuUsage( [interval])*\n\n**PARAMETERS:**\n\n*interval (numeric)* - Time in milli-seconds. This is the time delay between two snapshots.. **Default:** *1000*.\n"
    },
    {
        "prefix": "getCurrentContext",
        "body": "getCurrentContext()",
        "documentation": "\n\n**USAGE:**\n*array getCurrentContext()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getCurrentTemplatePath",
        "body": "getCurrentTemplatePath()",
        "documentation": "Gets the absolute server file system path of the file that calls this function.\n\n**USAGE:**\n*string getCurrentTemplatePath()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getDirectoryFromPath",
        "body": "getDirectoryFromPath(${1:path})",
        "documentation": "Extracts a directory from an absolute path. Returns the absolute path with a trailing slash and omits the filename.\n\n**USAGE:**\n*string getDirectoryFromPath(path)*\n\n**PARAMETERS:**\n\n*path (string)*\n"
    },
    {
        "prefix": "getEncoding",
        "body": "getEncoding(${1|form,url|})",
        "documentation": " Returns the encoding (character set) of the Form or URL scope.\n\n**USAGE:**\n*string getEncoding(scope_name)*\n\n**PARAMETERS:**\n\n*scope_name (string)* **Values:** *form, url*.\n"
    },
    {
        "prefix": "getException",
        "body": "getException(${1:javaobject})",
        "documentation": " Used with the cftry and cfcatch tags. Retrieves a Java\n exception object from a Java object.\n\n**USAGE:**\n*any getException(javaobject)*\n\n**PARAMETERS:**\n\n*javaobject (any)*\n"
    },
    {
        "prefix": "getFileFromPath",
        "body": "getFileFromPath(${1:path})",
        "documentation": " Extracts a filename from an absolute path.\n\n**USAGE:**\n*string getFileFromPath(path)*\n\n**PARAMETERS:**\n\n*path (string)*\n"
    },
    {
        "prefix": "getFileInfo",
        "body": "getFileInfo(${1:path})",
        "documentation": "Returns information about on-disk or in-memory file. Return struct contains keys such as: lastModified, size, path, name, type, canWrite, canRead, isHidden and more.\n\n**USAGE:**\n*struct getFileInfo(path)*\n\n**PARAMETERS:**\n\n*path (string)* - Path to the on-disk or in-memory file\n"
    },
    {
        "prefix": "getFreeSpace",
        "body": "getFreeSpace(${1:path})",
        "documentation": " Gets information about free hard disk space or free in-memory VFS space.\n\n**USAGE:**\n*numeric getFreeSpace(path)*\n\n**PARAMETERS:**\n\n*path ()* - The Path to the Hard Disk Drive or to the in-memory file system - ram.\n"
    },
    {
        "prefix": "getFunctionCalledName",
        "body": "getFunctionCalledName()",
        "documentation": " Returns the name of the variable used to call a defined function. This function can be used to return data from CFCs by simulating getters and setters.\n\n**USAGE:**\n*string getFunctionCalledName()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getFunctionData",
        "body": "getFunctionData(${1:functionName})",
        "documentation": "Return information to a function as struct\n\n**USAGE:**\n*struct getFunctionData(functionName [, dialect])*\n\n**PARAMETERS:**\n\n*functionName (string)* - The function you want information for\n\n*dialect (string)* - The dialect you want details for. **Default:** *current template's dialect*. **Values:** *CFML, Lucee*.\n"
    },
    {
        "prefix": "getFunctionKeywords",
        "body": "getFunctionKeywords()",
        "documentation": "Returns all keywords defined with all functions.\n\n**USAGE:**\n*array getFunctionKeywords()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getFunctionList",
        "body": "getFunctionList()",
        "documentation": "Returns a struct with keys of the names of functions that are available in CFML.\n\n**USAGE:**\n*struct getFunctionList()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getGatewayHelper",
        "body": "getGatewayHelper(${1:gatewayID})",
        "documentation": " Gets a Java GatewayHelper object that provides methods\n and properties for use with a ColdFusion event gateway.\n\n**USAGE:**\n*any getGatewayHelper(gatewayID)*\n\n**PARAMETERS:**\n\n*gatewayID (string)* - Identifier of the gateway that provides the GatewayHelper object.\n"
    },
    {
        "prefix": "getHTTPRequestData",
        "body": "getHTTPRequestData()",
        "documentation": "Returns HTTP request headers and request body. The resulting structure contains the following keys:\n\t content (the request body),\n\t headers (a structure of request headers),\n\t method (same as cgi.request_method),\n\t protocol (same as cgi.server_protocol).\n\n**USAGE:**\n*struct getHTTPRequestData()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getHTTPTimeString",
        "body": "getHTTPTimeString()",
        "documentation": " Gets the current time, in the Universal Time code (UTC).\n\n**USAGE:**\n*string getHTTPTimeString( [DateTime])*\n\n**PARAMETERS:**\n\n*DateTime (date)*. **Default:** *now()*.\n"
    },
    {
        "prefix": "getK2ServerDocCount",
        "body": "getK2ServerDocCount()",
        "documentation": "Determines the number of documents that can be searched by the\n CFML registered K2 Server. This function is used\n primarily by the CFML Verity and K2Server Administrator\n pages, and requires significant processing time. Avoid using\n it in production applications. This function uses Verity\n K2Server Release K2.2.0.\n\n**USAGE:**\n*numeric getK2ServerDocCount()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getK2ServerDocCountLimit",
        "body": "getK2ServerDocCountLimit()",
        "documentation": "Gets the maximum number of documents that the CFML\n registered K2 Server is permitted to return from a search.\n This function is used primarily by the CFML Verity and\n K2Server Administrator pages. This function uses Verity\n K2Server Release K2.2.0.\n\n**USAGE:**\n*numeric getK2ServerDocCountLimit()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getLocale",
        "body": "getLocale()",
        "documentation": " Gets the current geographic/language locale value.\n To set the default display format of date, time, number, and\n currency values in a CFML application session, you use\n the SetLocale function.\n\n**USAGE:**\n*string getLocale()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getLocaleCountry",
        "body": "getLocaleCountry()",
        "documentation": "Gets the country where the locale belongs to.\n\n**USAGE:**\n*string getLocaleCountry()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getLocaleDisplayName",
        "body": "getLocaleDisplayName()",
        "documentation": " Gets a locale value and displays the name in a manner\n that is appropriate to a specific locale. By default,\n gets the current locale in the current locale's language.\n\n**USAGE:**\n*string getLocaleDisplayName()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getLocaleInfo",
        "body": "getLocaleInfo(${1|en,de_DE,de_ch,...|})",
        "documentation": "A short description that describes what the tag or function does.\n\n**USAGE:**\n*struct getLocaleInfo(locale [, displayLocale])*\n\n**PARAMETERS:**\n\n*locale (string)* - Geographic/language locale value. **Default:** *getLocale()*. **Values:** *en, de_DE, de_ch, ...*.\n\n*displayLocale (string)* - Locale's display name/Output language. **Default:** *getLocaleDisplayName()*. **Values:** *English, German, French, ...*.\n"
    },
    {
        "prefix": "getLocaleLanguage",
        "body": "getLocaleLanguage()",
        "documentation": "Gets the language from where the locale belongs to.\n\n**USAGE:**\n*string getLocaleLanguage()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getLocalhostIP",
        "body": "getLocalhostIP()",
        "documentation": " Returns the localhost IP address, which is 127.0.0.1 for IPv4 and ::1 for IPv6 addresses.\n\n**USAGE:**\n*string getLocalhostIP()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getLuceeID",
        "body": "getLuceeID()",
        "documentation": "Get ID, ApiKey and SecurityKey for the Server and the current Web-Context.\n\n**USAGE:**\n*struct getLuceeID()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getMemoryUsage",
        "body": "getMemoryUsage()",
        "documentation": "\n\n**USAGE:**\n*query getMemoryUsage( [type])*\n\n**PARAMETERS:**\n\n*type (string)*\n"
    },
    {
        "prefix": "getMetadata",
        "body": "getMetadata(${1:Object})",
        "documentation": " Gets metadata (the methods, properties, and parameters of a\n component) associated with an object that is deployed on the\n CFML server.\n\n**USAGE:**\n*any getMetadata(Object)*\n\n**PARAMETERS:**\n\n*Object (any)*\n"
    },
    {
        "prefix": "getMetricData",
        "body": "getMetricData(${1|perf_monitor,simple_load,prev_req_time,avg_req_time|})",
        "documentation": " Gets server performance metrics\n [mode - quicky]\n perf_monitor - Returns internal data, in a structure.\n simple_load - Returns an integer value that is computed\n from the state of the server's internal\n queues. Indicates the overall server load.\n prev_req_time - Returns the time, in milliseconds, that it\n took the server to process the previous\n request.\n avg_req_time - Returns the average time, in milliseconds,\n that it takes the server to process a\n request.\n\n**USAGE:**\n*any getMetricData(mode)*\n\n**PARAMETERS:**\n\n*mode (string)* **Values:** *perf_monitor, simple_load, prev_req_time, avg_req_time*.\n"
    },
    {
        "prefix": "getNumericDate",
        "body": "getNumericDate(${1:arg1})",
        "documentation": "\n\n**USAGE:**\n*numeric getNumericDate(arg1)*\n\n**PARAMETERS:**\n\n*arg1 (any)*\n"
    },
    {
        "prefix": "getPageContext",
        "body": "getPageContext()",
        "documentation": " Gets the current java PageContext object that provides access to page attributes and configuration, request and response objects.\n\n**USAGE:**\n*any getPageContext()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getPrinterInfo",
        "body": "getPrinterInfo()",
        "documentation": "Determines which print attributes are supported by a selected printer.\n\n**USAGE:**\n*struct getPrinterInfo( [printer])*\n\n**PARAMETERS:**\n\n*printer (string)* - Name of the printer\n"
    },
    {
        "prefix": "getPrinterList",
        "body": "getPrinterList()",
        "documentation": " Returns list of printers accessible by the ColdFusion server\n\n**USAGE:**\n*string getPrinterList( [delimiter])*\n\n**PARAMETERS:**\n\n*delimiter (string)* - list separator\n"
    },
    {
        "prefix": "getProfileSections",
        "body": "getProfileSections(${1:inifile})",
        "documentation": " Gets all the sections of an initialization file.\n An initialization file, as a struct whose format is as follows:\n - Each initialization file section name is a key in the\n struct\n - Each list of entries in a section of an initialization\n file is a value in the struct\n\n**USAGE:**\n*struct getProfileSections(inifile)*\n\n**PARAMETERS:**\n\n*inifile (string)*\n"
    },
    {
        "prefix": "getProfileString",
        "body": "getProfileString(${1:inipath}, ${2:section}, ${3:entry})",
        "documentation": "Gets an initialization file entry. An initialization file assigns values to configuration variables, also known as entries, that are set when the system\n boots, the operating system comes up, or an application starts. Returns the entry - if no value, returns an empty string.\n\n**USAGE:**\n*string getProfileString(inipath, section, entry)*\n\n**PARAMETERS:**\n\n*inipath (string)*\n\n*section (string)*\n\n*entry (string)*\n"
    },
    {
        "prefix": "getReadableImageFormats",
        "body": "getReadableImageFormats()",
        "documentation": " Returns a list of image formats that ColdFusion can read on the operating system where ColdFusion is deployed.\n\n**USAGE:**\n*string getReadableImageFormats()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getSafeHTML",
        "body": "getSafeHTML(${1:inputString}, ${2:PolicyFile}, ${3:throwOnError})",
        "documentation": "Sanitizes HTML using antisamy policy rules. \n\n**USAGE:**\n*any getSafeHTML(inputString, PolicyFile, throwOnError)*\n\n**PARAMETERS:**\n\n*inputString (string)* - String to be sanitized\n\n*PolicyFile (string)* - File path for custom antisamy policy file. Can be defined in the application scope or if not defined will use Coldfusion  server default\n\n*throwOnError (boolean)* - If true will throw error else empty string will be returned\n"
    },
    {
        "prefix": "getSOAPRequest",
        "body": "getSOAPRequest()",
        "documentation": " Returns an XML object that contains the entire SOAP\n request. Usually called from within a web service CFC.\n\n**USAGE:**\n*any getSOAPRequest()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getSOAPRequestHeader",
        "body": "getSOAPRequestHeader(${1:namespace}, ${2:name})",
        "documentation": " Obtains a SOAP request header. Call only from within\n a CFC web service function that is processing a request\n as a SOAP web service.\n\n**USAGE:**\n*any getSOAPRequestHeader(namespace, name [, asXML])*\n\n**PARAMETERS:**\n\n*namespace (string)* - A String that is the namespace for the header\n\n*name (string)* - A String that is the name of the header\n\n*asXML (boolean)* - If True, the header is returned as a CFML XML object;\n if false (default), the header is returned as a Java object. **Values:** *true, false*.\n"
    },
    {
        "prefix": "getSOAPResponse",
        "body": "getSOAPResponse(${1:webservice})",
        "documentation": " Returns an XML object that contains the entire\n SOAP response after invoking a web service.\n\n**USAGE:**\n*any getSOAPResponse(webservice)*\n\n**PARAMETERS:**\n\n*webservice (string)* - A webservice object as returned from the cfobject tag or the CreateObject function.\n"
    },
    {
        "prefix": "getSOAPResponseHeader",
        "body": "getSOAPResponseHeader(${1:webservice}, ${2:namespace}, ${3:name})",
        "documentation": " Returns a SOAP response header. Call this function\n from within code that is invoking a web service after\n making a web service request.\n\n**USAGE:**\n*any getSOAPResponseHeader(webservice, namespace, name [, asXML])*\n\n**PARAMETERS:**\n\n*webservice (any)* - A webservice object as returned from the cfobject tag\n or the Createobject function.\n\n*namespace (string)* - A String that is the namespace for the header.\n\n*name (string)* - A String that is the name of the SOAP header.\n\n*asXML (boolean)* - If True, the header is returned as a CFML XML object;\n if false (default), the header is returned as a Java object. **Values:** *true, false*.\n"
    },
    {
        "prefix": "getSystemFreeMemory",
        "body": "getSystemFreeMemory()",
        "documentation": "Gets details of free memory.\n\n**USAGE:**\n*numeric getSystemFreeMemory()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getSystemTotalMemory",
        "body": "getSystemTotalMemory()",
        "documentation": " Gets details of the memory that is available for the operating system, in bytes.\n\n**USAGE:**\n*numeric getSystemTotalMemory( [region])*\n\n**PARAMETERS:**\n\n*region ()* - Indicates the cache region from which to remove the stored objects. If no value is specified, default cache region is considered by default.\n"
    },
    {
        "prefix": "getTagData",
        "body": "getTagData(${1:nameSpaceWithSeperator}, ${2:tagName})",
        "documentation": "Return information to a Tag as Struct\n\n**USAGE:**\n*struct getTagData(nameSpaceWithSeperator, tagName [, dialect])*\n\n**PARAMETERS:**\n\n*nameSpaceWithSeperator (string)*\n\n*tagName (string)*\n\n*dialect (string)* - Define the dialect you want details for. **Default:** *current template's dialect*. **Values:** *CFML, Lucee*.\n"
    },
    {
        "prefix": "getTagList",
        "body": "getTagList()",
        "documentation": "\n\n**USAGE:**\n*struct getTagList()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getTempDirectory",
        "body": "getTempDirectory()",
        "documentation": " Gets the path of the directory that CFML uses for\n temporary files. Before using this function in an application,\n test to determine the directory it returns under your account.\n Returns the absolute pathname of a directory, including a\n trailing slash.\n\n**USAGE:**\n*string getTempDirectory()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getTempFile",
        "body": "getTempFile(${1:dir}, ${2:prefix})",
        "documentation": " Creates a temporary file in a directory whose name starts with\n (at most) the first three characters of prefix.\n\n**USAGE:**\n*string getTempFile(dir, prefix)*\n\n**PARAMETERS:**\n\n*dir (string)*\n\n*prefix (string)*\n"
    },
    {
        "prefix": "getTemplatePath",
        "body": "getTemplatePath()",
        "documentation": "Returns the filepath of the base template in this request\n\n**USAGE:**\n*string getTemplatePath()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getTickCount",
        "body": "getTickCount()",
        "documentation": " Returns the current value of an internal millisecond timer.\n\n**USAGE:**\n*numeric getTickCount()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getTimezone",
        "body": "getTimezone()",
        "documentation": "\n\n**USAGE:**\n*string getTimezone()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getTimezoneInfo",
        "body": "getTimezoneInfo(${1:text})",
        "documentation": " Gets local time zone information for the computer on which it\n is called, relative to Universal Time Coordinated (UTC). UTC is\n the mean solar time of the meridian of Greenwich, England.\n\n**USAGE:**\n*any getTimezoneInfo(text)*\n\n**PARAMETERS:**\n\n*text (string)*\n"
    },
    {
        "prefix": "getToken",
        "body": "getToken(${1:String}, ${2:index})",
        "documentation": " Determines whether a token of the list in the delimiters\n parameter is present in a string.\n Returns the token found at position index of the string, as a\n string. If index is greater than the number of tokens in the\n string, returns an empty string.\n\n**USAGE:**\n*string getToken(String, index [, delimiters])*\n\n**PARAMETERS:**\n\n*String (string)*\n\n*index (numeric)*\n\n*delimiters (string)*. **Default:** *space, tab, or newline character; or their codes: 'chr(32)', 'chr(9)', 'chr(10)'*. **Values:** *,, |, _, ;, :*.\n"
    },
    {
        "prefix": "getTotalSpace",
        "body": "getTotalSpace(${1:path})",
        "documentation": " Returns the total disk space or in-memory space avaialbe for an appliation.\n\n**USAGE:**\n*numeric getTotalSpace(path)*\n\n**PARAMETERS:**\n\n*path ()* - path to the hard drive or for in memory file system.\n"
    },
    {
        "prefix": "getUserRoles",
        "body": "getUserRoles()",
        "documentation": " Retrieves the list of roles for the current user.\n\n**USAGE:**\n*string getUserRoles()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "getVariable",
        "body": "getVariable(${1:name})",
        "documentation": "Retrieves value of a variabl\n\n**USAGE:**\n*any getVariable(name)*\n\n**PARAMETERS:**\n\n*name (string)*\n"
    },
    {
        "prefix": "getVFSMetadata",
        "body": "getVFSMetadata(${1:fileSystemType})",
        "documentation": " Returns metadata for VFS\n\n**USAGE:**\n*struct getVFSMetadata(fileSystemType)*\n\n**PARAMETERS:**\n\n*fileSystemType (string)*\n"
    },
    {
        "prefix": "getWriteableImageFormats",
        "body": "getWriteableImageFormats()",
        "documentation": " No Help Available\n\n**USAGE:**\n*string getWriteableImageFormats()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "hash",
        "body": "hash(${1:String})",
        "documentation": "Converts a string into a fixed length hexadecimal string.\n\n**USAGE:**\n*string hash(String [, algorithm] [, encoding] [, iterations])*\n\n**PARAMETERS:**\n\n*String (string)*\n\n*algorithm (string)* - A supported algorithm such as MD5,SHA,SHA-256,SHA-384, or SHA-512. Of those listed SHA-512 is the strongest and generates a 128 character hex result. CF7+. **Default:** *MD5*. **Values:** *CFMX_COMPAT, MD5, SHA, SHA-256, SHA-384, SHA-512*.\n\n*encoding (string)* - A string specifying the encoding to use when converting\n the string to byte data used by the hash algorithm.\n Must be a character encoding name recognized by the\n Java runtime. CF7+ **Values:** *utf-8, iso-8859-1, windows-1252, us-ascii, shift_jis, iso-2022-jp, euc-jp, euc-kr, big5, euc-cn, utf-16*.\n\n*iterations (numeric)* - Iterates the number of times the hash is computed to create a more computationally intensive hash. Lucee and Adobe CF implement this differently (off by one), see compatibility notes below. CF10+. **Default:** *1*.\n"
    },
    {
        "prefix": "hash40",
        "body": "hash40(${1:input})",
        "documentation": "Converts a variable-length string to a 32-byte, hexadecimal string, using the MD5 algorithm.\nNote: It is not possible to convert the hash result back to the source string.\n\n**USAGE:**\n*string hash40(input [, algorithm] [, encoding] [, numIterations])*\n\n**PARAMETERS:**\n\n*input (any)* - String for hashing\n\n*algorithm (string)* - The algorithm to use to hash the string. Supported are the following algorithms:\n- CFMX_COMPAT: generating a hash string using classic CFML algorithm.\n- MD5: (default) Generates a 32-character, hexadecimal string, using the MD5 algorithm.\n- SHA: Generates a 28-character string using the Secure Hash Standard SHA-1 algorithm specified by Nation Institute of Standards and Technology (NIST) FIPS-180-2.\n- SHA-256: Generates a 44-character string using the SHA-256 algorithm specified by FIPS-180-2.\n- SHA-384: Generates a 64-character string using the SHA-384 algorithm specified by FIPS-180-2.\n- SHA-512: Generates an 88-character string using the SHA-1 algorithm specified by FIPS-180-2. **Values:** *CFMX_COMPAT, MD5, SHA, SHA-1, SHA-256, SHA-384, SHA-512*.\n\n*encoding (string)* - Encoding which will be used by the hash algorithm\n\n*numIterations (numeric)* - number of iterations. **Default:** *1*.\n"
    },
    {
        "prefix": "hmac",
        "body": "hmac(${1:message}, ${2:key})",
        "documentation": "Creates a keyed-hash message authentication code (HMAC), which can be used to verify authenticity and integrity of a message by two parties that share the key.\n\n**USAGE:**\n*string hmac(message, key [, algorithm] [, encoding])*\n\n**PARAMETERS:**\n\n*message (string)* - The message or data to autenticate\n\n*key (string)* - The secret key.\n\n*algorithm (string)* - An algorithm supported by the java crypto provider, for example HMACSHA256. **Default:** *HMACMD5*. **Values:** *HMACMD5, HMACSHA1, HMACSHA256, HMACSHA384, HMACSHA512*.\n\n*encoding (string)* - The character encoding to use when converting the message to bytes. Must be a character encoding name recognized by the Java runtime.. **Default:** *utf-8*. **Values:** *utf-8, iso-8859-1, windows-1252, us-ascii, shift_jis, iso-2022-jp, euc-jp, euc-kr, big5, euc-cn, utf-16*.\n"
    },
    {
        "prefix": "hour",
        "body": "hour(${1:date})",
        "documentation": " Extracts the hour of the day from a date/time object.\n Ordinal value of the hour, in the range 0 - 23.\n\n**USAGE:**\n*numeric hour(date)*\n\n**PARAMETERS:**\n\n*date (date)*\n"
    },
    {
        "prefix": "htmlCodeFormat",
        "body": "htmlCodeFormat(${1:String})",
        "documentation": " Replaces special characters in a string with their HTML-escaped\n equivalents and inserts &ltpre&gt; and &lt/pre&gt tags at the beginning\n and end of the string.\n [version]\n HTML version to use. currently ignored.\n -1: The latest implementation of HTML\n 2.0: HTML 2.0 (Default)\n 3.2: HTML 3.2\n\n**USAGE:**\n*string htmlCodeFormat(String [, version])*\n\n**PARAMETERS:**\n\n*String (string)*\n\n*version (numeric)* **Values:** *-1, 2, 3.2*.\n"
    },
    {
        "prefix": "htmlEditFormat",
        "body": "htmlEditFormat(${1:string})",
        "documentation": "Replaces special characters in a string with their HTML-escaped equivalents.\n\n**USAGE:**\n*string htmlEditFormat(string [, version])*\n\n**PARAMETERS:**\n\n*string (string)* - A string or a variable that contains one.\n\n*version (numeric)* - HTML version to use; currently ignored. **Values:** *-1, 2, 3.2*.\n"
    },
    {
        "prefix": "htmlParse",
        "body": "htmlParse(${1:html})",
        "documentation": "\n\n**USAGE:**\n*xml htmlParse(html [, caseSensitive])*\n\n**PARAMETERS:**\n\n*html (string)*\n\n*caseSensitive (boolean)*\n"
    },
    {
        "prefix": "iIf",
        "body": "iIf(${1:condition}, ${2:expression1}, ${3:expression2})",
        "documentation": "A boolean condition or value is passed into the first argument. If the condition is `true` the second argument is evaluated and returned, if `false` the third argument is evaluated and returned.\n\n**USAGE:**\n*string iIf(condition, expression1, expression2)*\n\n**PARAMETERS:**\n\n*condition (boolean)* - A boolean value or an expression that evaluates to a boolean.\n\n*expression1 (string)* - A CFML expression that is evaluated dynamically using Evaluate if the condition is `true`.\n\n*expression2 (string)* - A CFML expression that is evaluated dynamically using Evaluate if the condition is `false`.\n"
    },
    {
        "prefix": "imageAddBorder",
        "body": "imageAddBorder(${1:name}, ${2:thickness})",
        "documentation": " Adds a rectangular border around the outside edge of a ColdFusion image.\n\n**USAGE:**\n*void imageAddBorder(name, thickness [, color] [, bordertype])*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*thickness (string)* - Thickness of the border in pixels. The default value is 1. The border is added to the outside edge of the image; the image area is increased accordingly.\n\n*color (string)* - Only valid if the borderType is not specified or if borderType = 'constant'.. **Default:** *black*.\n\n*bordertype (string)* - The type of border.. **Default:** *constant*. **Values:** *zero, constant, copy, reflect, wrap*.\n"
    },
    {
        "prefix": "imageBlur",
        "body": "imageBlur(${1:name})",
        "documentation": " Smooths (blurs) the ColdFusion image.\n\n**USAGE:**\n*void imageBlur(name [, blurradius])*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*blurradius (numeric)* - The size of the blur radius.Value must be greater than or equal to 3 and less than or equal to 10.. **Default:** *3*.\n"
    },
    {
        "prefix": "imageClearRect",
        "body": "imageClearRect(${1:name}, ${2:x}, ${3:y}, ${4:width}, ${5:height})",
        "documentation": " Clears the specified rectangle by filling it with the background color of the current drawing surface.\n\n**USAGE:**\n*void imageClearRect(name, x, y, width, height)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed\n\n*x (numeric)* - The X coordinate of the rectangle to clear.\n\n*y (numeric)* - The Y coordinate of the rectangle to clear.\n\n*width (numeric)* - The width of the rectangle to clear.\n\n*height (numeric)* - The height of the rectangle to clear.\n"
    },
    {
        "prefix": "imageCopy",
        "body": "imageCopy(${1:name}, ${2:x}, ${3:y}, ${4:width}, ${5:height})",
        "documentation": " Copies a rectangular area of an image.\n\n**USAGE:**\n*any imageCopy(name, x, y, width, height [, dx] [, dy])*\n\n**PARAMETERS:**\n\n*name (string)* - The ColdFusion image on which this operation is performed.\n\n*x (numeric)* - The x coordinate of the source rectangle.\n\n*y (numeric)* - The y coordinate of the source rectangle.\n\n*width (numeric)* - The width of the source rectangle.\n\n*height (numeric)* - The height of the source rectangle.\n\n*dx (numeric)* - The x coordinate of the destination rectangle.\n\n*dy (numeric)* - The y coordinate of the destination rectangle.\n"
    },
    {
        "prefix": "imageCreateCaptcha",
        "body": "imageCreateCaptcha(${1:height}, ${2:width}, ${3:text})",
        "documentation": " Create a Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) image, a distorted text image that is human-readable, but not machine-readable, used in a challenge-response test for preventing spam.\n\n**USAGE:**\n*any imageCreateCaptcha(height, width, text [, difficulty] [, font] [, fontsize])*\n\n**PARAMETERS:**\n\n*height ()* - Height in pixels of the image.\n\n*width ()* - Width in pixels of the image.\n\n*text ()* - Text string displayed in the CAPTCHA image. Use capital letters for better readability. Do not include spaces because users cannot detect them in the resulting CAPTCHA image..\n\n*difficulty ()* - Level of complexity of the CAPTCHA text. Specify one of the following levels of text distortion: low, medium, and high\n\n*font ()* - One or more valid fonts to use for the CAPTCHA text. Separate multiple fonts with commas. ColdFusion supports only the system fonts that the JDK can recognize. For example, TTF fonts in the Windows directory are supported on Windows.\n\n*fontsize ()* - Font size of the text in the CAPTCHA image. The value must be an integer.\n"
    },
    {
        "prefix": "imageCrop",
        "body": "imageCrop(${1:name}, ${2:x}, ${3:y}, ${4:width}, ${5:height})",
        "documentation": " Crops a ColdFusion image to a specified rectangular area.\n\n**USAGE:**\n*void imageCrop(name, x, y, width, height)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*x (numeric)* - The X origin of the crop area.\n\n*y (numeric)* - The Y origin of the crop area.\n\n*width (numeric)* - The width of the crop area.\n\n*height (numeric)* - The height of the crop area.\n"
    },
    {
        "prefix": "imageDrawArc",
        "body": "imageDrawArc(${1:name}, ${2:x}, ${3:y}, ${4:width}, ${5:height}, ${6:startAngle}, ${7:archAngle})",
        "documentation": " Draws a circular or elliptical arc.\n\n**USAGE:**\n*void imageDrawArc(name, x, y, width, height, startAngle, archAngle [, filled])*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*x (numeric)* - The x coordinate of the upper-left corner of the arc.\n\n*y (numeric)* - The y coordinate of the upper-left corner of the arc.\n\n*width (numeric)* - The width of the arc.\n\n*height (numeric)* - The height of the arc.\n\n*startAngle (numeric)* - The beginning angle in degrees.\n\n*archAngle (numeric)* - The angular extent of the arc, relative to the start angle.\n\n*filled (boolean)* - Specify whether the arc is filled. **Default:** *false*. **Values:** *true, false*.\n"
    },
    {
        "prefix": "imageDrawBeveledRect",
        "body": "imageDrawBeveledRect(${1:name}, ${2:x}, ${3:y}, ${4:width}, ${5:height}, ${6:raised})",
        "documentation": " Draws a rectangle with beveled edges.\n\n**USAGE:**\n*void imageDrawBeveledRect(name, x, y, width, height, raised [, filled])*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*x (numeric)* - The x coordinate of the rectangle.\n\n*y (numeric)* - The y coordinate of the rectangle.\n\n*width (numeric)* - The width of the rectangle.\n\n*height (numeric)* - The height of the rectangle.\n\n*raised (boolean)* - Specify whether the rectangle appears raised above the surface or sunk into the surface. **Default:** *false*.\n\n*filled (boolean)* - Specify whether the rectangle is filled.. **Default:** *false*.\n"
    },
    {
        "prefix": "imageDrawCubicCurve",
        "body": "imageDrawCubicCurve(${1:name}, ${2:ctrlx1}, ${3:ctrly1}, ${4:ctrlx2}, ${5:ctrly2}, ${6:x1}, ${7:y1}, ${8:x2}, ${9:y2})",
        "documentation": " Draws a cubic curve.\n\n**USAGE:**\n*void imageDrawCubicCurve(name, ctrlx1, ctrly1, ctrlx2, ctrly2, x1, y1, x2, y2)*\n\n**PARAMETERS:**\n\n*name ()* - The image on which this operation is performed.\n\n*ctrlx1 (string)* - The x coordinate of the start point of the cubic curve segment.\n\n*ctrly1 (numeric)* - The y coordinate of the start point of the cubic curve segment.\n\n*ctrlx2 (numeric)* - The x coordinate of the first control point of the cubic curve segment.\n\n*ctrly2 (numeric)* - The y coordinate of the first control point of the cubic curve segment.\n\n*x1 (numeric)* - The x coordinate of the second control point of the cubic curve segment.\n\n*y1 (numeric)* - The y coordinate of the second control point of the cubic curve segment.\n\n*x2 (numeric)* - The x coordinate of the end point of the cubic curve segment.\n\n*y2 (numeric)* - The y coordinate of the end point of the cubic curve segment.\n"
    },
    {
        "prefix": "imageDrawImage",
        "body": "imageDrawImage(${1:name}, ${2:image}, ${3:x}, ${4:y})",
        "documentation": "\n\n**USAGE:**\n*void imageDrawImage(name, image, x, y)*\n\n**PARAMETERS:**\n\n*name (any)*\n\n*image (any)*\n\n*x (numeric)*\n\n*y (numeric)*\n"
    },
    {
        "prefix": "imageDrawLine",
        "body": "imageDrawLine(${1:name}, ${2:x1}, ${3:y1}, ${4:x2}, ${5:y2})",
        "documentation": " Draws a single line defined by two sets of x and y coordinates on a ColdFusion image.\n\n**USAGE:**\n*void imageDrawLine(name, x1, y1, x2, y2)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*x1 (numeric)* - The x coordinate for the start point of the line.\n\n*y1 (numeric)* - The y coordinate for the start point of the line.\n\n*x2 (numeric)* - The x coordinate for the end point of the line.\n\n*y2 (numeric)* - The y coordinate for the end point of the line.\n"
    },
    {
        "prefix": "imageDrawLines",
        "body": "imageDrawLines(${1:name}, ${2:xcords}, ${3:ycords})",
        "documentation": " Draws a sequence of connected lines defined by arrays of x and y coordinates.\n\n**USAGE:**\n*void imageDrawLines(name, xcords, ycords [, isPolygon] [, filled])*\n\n**PARAMETERS:**\n\n*name (string)* - NThe image on which this operation is performed.\n\n*xcords (numeric)* - A array of x coordinates.\n\n*ycords (numeric)* - A array of y coordinates.\n\n*isPolygon (boolean)* - Specify whether the lines form a polygon. **Default:** *false*.\n\n*filled (boolean)* - Specify whether the polygon is filled. **Default:** *false*.\n"
    },
    {
        "prefix": "imageDrawOval",
        "body": "imageDrawOval(${1:name}, ${2:x}, ${3:y}, ${4:width}, ${5:height})",
        "documentation": " Draws an oval.\n\n**USAGE:**\n*void imageDrawOval(name, x, y, width, height [, filled])*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*x (numeric)* - The x coordinate of the upper left corner of the oval to draw.\n\n*y (numeric)* - The y coordinate of the upper left corner of the oval to draw.\n\n*width (numeric)* - The width of the oval to draw.\n\n*height (numeric)* - The height of the oval to draw.\n\n*filled (boolean)* - Specify whether the oval is filled. **Default:** *false*.\n"
    },
    {
        "prefix": "imageDrawPoint",
        "body": "imageDrawPoint(${1:name}, ${2:x}, ${3:y})",
        "documentation": " Draws a point at the specified (x,y) coordinate.\n\n**USAGE:**\n*void imageDrawPoint(name, x, y)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*x (numeric)* - The x coordinate of the point.\n\n*y (numeric)* - The y coordinate of the point.\n"
    },
    {
        "prefix": "imageDrawQuadraticCurve",
        "body": "imageDrawQuadraticCurve(${1:name}, ${2:x1}, ${3:y1}, ${4:ctrlx1}, ${5:ctrly1}, ${6:x2}, ${7:y2})",
        "documentation": " Draws a curved line. The curve is controlled by a single point.\n\n**USAGE:**\n*void imageDrawQuadraticCurve(name, x1, y1, ctrlx1, ctrly1, x2, y2)*\n\n**PARAMETERS:**\n\n*name ()* - The image on which this operation is performed.\n\n*x1 (numeric)* - The x coordinate of the start point of the quadratic curve segment.\n\n*y1 (numeric)* - The y coordinate of the start point of the quadratic curve segment.\n\n*ctrlx1 (string)* - The x coordinate of the first control point of the quadratic curve segment.\n\n*ctrly1 (numeric)* - The y coordinate of the first control point of the quadratic curve segment.\n\n*x2 (numeric)* - The x coordinate of the end point of the quadratic curve segment.\n\n*y2 (numeric)* - The y coordinate of the end point of the quadratic curve segment.\n"
    },
    {
        "prefix": "imageDrawRect",
        "body": "imageDrawRect(${1:name}, ${2:x}, ${3:y}, ${4:width}, ${5:height})",
        "documentation": " Draws a rectangle.\n\n**USAGE:**\n*void imageDrawRect(name, x, y, width, height [, filled])*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*x (numeric)* - The x coordinate of the rectangle.\n\n*y (numeric)* - The y coordinate of the rectangle.\n\n*width (numeric)* - The width of the rectangle.\n\n*height (numeric)* - The height of the rectangle.\n\n*filled (boolean)* - Specify whether the rectangle is filled. **Default:** *false*.\n"
    },
    {
        "prefix": "imageDrawRoundRect",
        "body": "imageDrawRoundRect(${1:name}, ${2:x}, ${3:y}, ${4:width}, ${5:height}, ${6:arcwidth}, ${7:archeight})",
        "documentation": " Draws a rectangle with rounded corners.\n\n**USAGE:**\n*void imageDrawRoundRect(name, x, y, width, height, arcwidth, archeight [, filled])*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*x (numeric)* - The x coordinate of the rectangle.\n\n*y (numeric)* - The y coordinate of the rectangle.\n\n*width (numeric)* - The width of the rectangle.\n\n*height (numeric)* - The height of the rectangle.\n\n*arcwidth (numeric)* - The horizontal diameter of the arc at the four corners.\n\n*archeight (numeric)* - The vertical diameter of the arc at the four corners.\n\n*filled (boolean)* - Specify whether the rectangle is filled. **Default:** *false*.\n"
    },
    {
        "prefix": "imageDrawText",
        "body": "imageDrawText(${1:name}, ${2:str}, ${3:x}, ${4:y})",
        "documentation": " Draws a text string on a ColdFusion image with the baseline of the first character positioned at (x,y) in the image.\n\n**USAGE:**\n*void imageDrawText(name, str, x, y [, attributecollection])*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*str (string)* - The text to draw.\n\n*x (numeric)* - The x coordinate for the start point of the string.\n\n*y (numeric)* - The y coordinate for the start point of the string.\n\n*attributecollection (struct)* - A structure used to specify the text characteristics. the following keys are supported: \r\nfont: The name of the font used to draw the text string. If you do not specify the font attribute, the text is drawn in the default system font. \r\nsize: The font size for the text string. The default value is 10 points. \r\nstyle: The style to apply to the font ( bold,italic,boldItalic,plain (default) ). \r\nstrikethrough: a boolean that specify whether strikethrough is applied to the text image, default is false. \r\nunderline: a boolean that specify whether underline is applied to the text image, default is false.\n"
    },
    {
        "prefix": "imageFilter",
        "body": "imageFilter(${1:name}, ${2:filtername})",
        "documentation": "\n\n**USAGE:**\n*void imageFilter(name, filtername [, parameters])*\n\n**PARAMETERS:**\n\n*name (any)*\n\n*filtername (string)*\n\n*parameters (struct)*\n"
    },
    {
        "prefix": "imageFilterColorMap",
        "body": "imageFilterColorMap(${1:type})",
        "documentation": "\n\n**USAGE:**\n*any imageFilterColorMap(type [, lineColor1] [, lineColor2])*\n\n**PARAMETERS:**\n\n*type (string)*\n\n*lineColor1 (string)*\n\n*lineColor2 (string)*\n"
    },
    {
        "prefix": "imageFilterCurves",
        "body": "imageFilterCurves()",
        "documentation": "\n\n**USAGE:**\n*any imageFilterCurves()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "imageFilterKernel",
        "body": "imageFilterKernel(${1:width}, ${2:height}, ${3:data})",
        "documentation": "\n\n**USAGE:**\n*any imageFilterKernel(width, height, data)*\n\n**PARAMETERS:**\n\n*width (numeric)*\n\n*height (numeric)*\n\n*data (any)*\n"
    },
    {
        "prefix": "imageFilterWarpGrid",
        "body": "imageFilterWarpGrid(${1:rows}, ${2:cols}, ${3:width}, ${4:height})",
        "documentation": "\n\n**USAGE:**\n*any imageFilterWarpGrid(rows, cols, width, height)*\n\n**PARAMETERS:**\n\n*rows (numeric)*\n\n*cols (numeric)*\n\n*width (numeric)*\n\n*height (numeric)*\n"
    },
    {
        "prefix": "imageFlip",
        "body": "imageFlip(${1:name}, ${2|vertical (default): Flip an image across an imaginary horizontal line that runs through the center of the image.,horizontal: Flip an image across an imaginary vertical line that runs through the center of the image.,diagonal: Flip an image across its main diagonal that runs from the upper-left to the lower-right corner.,antidiagonal: Flip an image across its main diagonal that runs from the upper-right to the lower-left corner.,90|180|270: Rotate an image clockwise by 90, 180, or 270 degrees.|})",
        "documentation": " Flips an image across an axis.\n\n**USAGE:**\n*void imageFlip(name, transpose)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*transpose (string)* - Transpose the image.. **Default:** *vertical*. **Values:** *vertical (default): Flip an image across an imaginary horizontal line that runs through the center of the image., horizontal: Flip an image across an imaginary vertical line that runs through the center of the image., diagonal: Flip an image across its main diagonal that runs from the upper-left to the lower-right corner., antidiagonal: Flip an image across its main diagonal that runs from the upper-right to the lower-left corner., 90|180|270: Rotate an image clockwise by 90, 180, or 270 degrees.*.\n"
    },
    {
        "prefix": "imageFonts",
        "body": "imageFonts()",
        "documentation": "\n\n**USAGE:**\n*array imageFonts()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "imageFormats",
        "body": "imageFormats()",
        "documentation": "\n\n**USAGE:**\n*struct imageFormats()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "imageGetBlob",
        "body": "imageGetBlob(${1:source})",
        "documentation": "Retrieves the bytes of the underlying image. The bytes are in the same image format as the source image.\n\n**USAGE:**\n*binary imageGetBlob(source)*\n\n**PARAMETERS:**\n\n*source (string)* - The ColdFusion image on which this operation is performed.\n"
    },
    {
        "prefix": "imageGetBufferedImage",
        "body": "imageGetBufferedImage(${1:name})",
        "documentation": " Returns the java.awt.BufferedImage object underlying the current ColdFusion image.\n\n**USAGE:**\n*any imageGetBufferedImage(name)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n"
    },
    {
        "prefix": "imageGetExifMetaData",
        "body": "imageGetExifMetaData(${1:name})",
        "documentation": " Retrieves the Exchangeable Image File Format (EXIF) headers in an image as a CFML structure.\n\n**USAGE:**\n*struct imageGetExifMetaData(name)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n"
    },
    {
        "prefix": "imageGetEXIFTag",
        "body": "imageGetEXIFTag(${1:name}, ${2:tagName})",
        "documentation": " Retrieves the specified EXIF tag in an image.\n\n**USAGE:**\n*string imageGetEXIFTag(name, tagName)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*tagName (string)* - The EXIF tag name to be returned.\n"
    },
    {
        "prefix": "imageGetHeight",
        "body": "imageGetHeight(${1:name})",
        "documentation": " Retrieves the height of the ColdFusion image in pixels.\n\n**USAGE:**\n*numeric imageGetHeight(name)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n"
    },
    {
        "prefix": "imageGetIPTCMetaData",
        "body": "imageGetIPTCMetaData(${1:name})",
        "documentation": " Retrieves the International Press Telecommunications Council (IPTC )headers in a ColdFusion image as a structure.\n\n**USAGE:**\n*struct imageGetIPTCMetaData(name)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n"
    },
    {
        "prefix": "imageGetIPTCtag",
        "body": "imageGetIPTCtag(${1:name}, ${2:tagName})",
        "documentation": " Retrieves the value of the IPTC tag for a ColdFusion image.\n\n**USAGE:**\n*string imageGetIPTCtag(name, tagName)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*tagName (string)* - The IPTC tag name whose value is returned.\n"
    },
    {
        "prefix": "imageGetMetadata",
        "body": "imageGetMetadata(${1:name})",
        "documentation": "A structure containing information about the image.\n\n**USAGE:**\n*struct imageGetMetadata(name)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n"
    },
    {
        "prefix": "imageGetWidth",
        "body": "imageGetWidth(${1:name})",
        "documentation": " Retrieves the width of the specified ColdFusion image.\n\n**USAGE:**\n*numeric imageGetWidth(name)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n"
    },
    {
        "prefix": "imageGrayScale",
        "body": "imageGrayScale(${1:name})",
        "documentation": " Converts a ColdFusion image to grayscale.\n\n**USAGE:**\n*void imageGrayScale(name)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n"
    },
    {
        "prefix": "imageInfo",
        "body": "imageInfo(${1:name})",
        "documentation": " Returns a structure that contains information about the image, such as height, width, color model, size, and filename.\n\n**USAGE:**\n*struct imageInfo(name)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n"
    },
    {
        "prefix": "imageMakeColorTransparent",
        "body": "imageMakeColorTransparent(${1:img}, ${2:color})",
        "documentation": " Creates an image and sets a transparent color..\n\n**USAGE:**\n*any imageMakeColorTransparent(img, color)*\n\n**PARAMETERS:**\n\n*img ()* - The ColdFusion image on which this operation is performed.\n\n*color ()* - The transparent color: Hexadecimal, String value, Default is black.\n"
    },
    {
        "prefix": "imageMakeTranslucent",
        "body": "imageMakeTranslucent(${1:img}, ${2:percentage})",
        "documentation": " Create a new translucent image with given percentage of translucence.\n\n**USAGE:**\n*any imageMakeTranslucent(img, percentage)*\n\n**PARAMETERS:**\n\n*img ()* - The ColdFusion image on which this operation is performed.\n\n*percentage ()* - The percent of translucence: 0 = opaque, 100=transparent. Decimal values are supported\n"
    },
    {
        "prefix": "imageNegative",
        "body": "imageNegative(${1:name})",
        "documentation": " Inverts the pixel values of a ColdFusion image.\n\n**USAGE:**\n*void imageNegative(name)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n"
    },
    {
        "prefix": "imageNew",
        "body": "imageNew()",
        "documentation": " Creates a ColdFusion image.\n\n**USAGE:**\n*any imageNew( [source] [, width] [, height] [, imagetype] [, canvascolor])*\n\n**PARAMETERS:**\n\n*source (string)* - The source image path, URL, a variable that is read into the new image, or a Java buffered image.\n\n*width (numeric)* - The width of the new image. Valid when the height is specified and the source is not.\n\n*height (numeric)* - The height of the new image. Valid when the width is specified and the source is not.\n\n*imagetype (string)* - The type of the image to create (Valid only when width and height are specified), **Values:** *rgb, argb, grayscale*.\n\n*canvascolor (string)* - Color of the image canvas. Possible values are:\n\nHexadecimal value of RGB color. For example, specify the color white as ##FFFFFF or FFFFFF.\nString value of color (for example, 'black', 'red', 'green').\nList of three numbers for (R,G,B) values. Each value must be in the range 0-255.. **Default:** *black*.\n"
    },
    {
        "prefix": "imageOverlay",
        "body": "imageOverlay(${1:source1}, ${2:source2})",
        "documentation": " Reads two source ColdFusion images and overlays the second source image on the first source image.\n\n**USAGE:**\n*void imageOverlay(source1, source2 [, rule] [, alpha])*\n\n**PARAMETERS:**\n\n*source1 (string)* - The image that is the bottom layer in the image.\n\n*source2 (string)* - The image that is the top layer (overlaid on the source1 image) in the image.\n\n*rule (string)* - CF10+ Compositing Rule **Values:** *SRC, DST_IN, DST_OUT, DST_OVER, SRC_IN, SRC_OVER, SRC_OUT*.\n\n*alpha (string)* - CF10+ The percentage value of transparency\n"
    },
    {
        "prefix": "imagePaste",
        "body": "imagePaste(${1:image1}, ${2:image2}, ${3:x}, ${4:y})",
        "documentation": " Takes two images and an (x,y) coordinate and draws the second image over the first image with the upper-left corner at coordinate (x,y).\n\n**USAGE:**\n*void imagePaste(image1, image2, x, y)*\n\n**PARAMETERS:**\n\n*image1 (string)* - The bottom image.\n\n*image2 (string)* - The image that is pasted on top of image1.\n\n*x (numeric)* - The x coordinate where the upper-left corner of image2 is pasted.\n\n*y (numeric)* - The y coordinate where the upper-left corner of image2 is pasted.\n"
    },
    {
        "prefix": "imageRead",
        "body": "imageRead(${1:path})",
        "documentation": " Reads the source pathname or URL and creates a ColdFusion image.\n\n**USAGE:**\n*any imageRead(path)*\n\n**PARAMETERS:**\n\n*path (string)* - On-disk or in-memory pathname or URL of the source image.\n"
    },
    {
        "prefix": "imageReadBase64",
        "body": "imageReadBase64(${1:string})",
        "documentation": " Creates a ColdFusion image from a Base64 string.\n\n**USAGE:**\n*any imageReadBase64(string)*\n\n**PARAMETERS:**\n\n*string (string)* - a variable or Base64 string\n"
    },
    {
        "prefix": "imageResize",
        "body": "imageResize(${1:name}, ${2:width}, ${3:height})",
        "documentation": " Resizes a ColdFusion image.\n\n**USAGE:**\n*void imageResize(name, width, height [, interpolation] [, blurfactor])*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*width (numeric)* - New width of the image. If this value is blank, the width is calculated proportionately to the height.\n\n*height (numeric)* - New height of the image. If this value is blank, the height is calculated proportionately to the width.\n\n*interpolation (string)* - The interpolation method for resampling. You can specify a specific interpolation algorithm by name (for example, hamming), by image quality (for example, mediumQuality), or by performance (for example, highestPerformance).  **Values:** *highestQuality (default), highQuality, mediumQuality, highestPerformance, highPerformance, mediumPerformance, nearest, bilinear, bicubic, bessel, blackman, hamming, hanning, hermite, lanczos, mitchell, quadratic*.\n\n*blurfactor (boolean)* - The blur factor used for resampling. The higher the blur factor, the more blurred the image (also, the longer it takes to resize the image). **Values:** *1-10*.\n"
    },
    {
        "prefix": "imageRotate",
        "body": "imageRotate(${1:name}, ${2:angle})",
        "documentation": "Rotates a ColdFusion image at a specified point by a specified angle.\n\n**USAGE:**\n*void imageRotate(name, angle [, x] [, y] [, interpolation])*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*angle (numeric)* - The rotation angle in degrees.\n\n*x (numeric)* - The x coordinate for the point of rotation. **Default:** *2*.\n\n*y (numeric)* - The y coordinate for the point of rotation. **Default:** *2*.\n\n*interpolation (string)* - Type of interpolation **Values:** *nearest: Applies the nearest neighbor method of interpolation. Image quality is lower than the other interpolation methods, but processing is fastest (default)., bilinear: Applies the bilinear method of interpolation. The quality of the image is less pixelated than the default, but processing is slower., bicubic: Applies the bicubic method of interpolation. Generally, the quality of image is highest with this method and processing is slowest.*.\n"
    },
    {
        "prefix": "imageRotateDrawingAxis",
        "body": "imageRotateDrawingAxis(${1:name}, ${2:angle})",
        "documentation": " Rotates all subsequent drawing on a ColdFusion image at a specified point by a specified angle.\n\n**USAGE:**\n*void imageRotateDrawingAxis(name, angle [, x] [, y])*\n\n**PARAMETERS:**\n\n*name (string)* - The ColdFusion image on which this operation is performed.\n\n*angle (numeric)* - The rotation angle in degrees.\n\n*x (numeric)* - The x coordinate for the point of rotation.. **Default:** *0*.\n\n*y (numeric)* - The y coordinate for the point of rotation.. **Default:** *0*.\n"
    },
    {
        "prefix": "imageScaleTofit",
        "body": "imageScaleTofit(${1:name}, ${2:fitWidth}, ${3:fitHeight})",
        "documentation": " Creates a resized image with the aspect ratio maintained.\n\n**USAGE:**\n*void imageScaleTofit(name, fitWidth, fitHeight [, interpolation] [, blurfactor])*\n\n**PARAMETERS:**\n\n*name (string)* - The ColdFusion image on which this operation is performed.\n\n*fitWidth (numeric)* - The width of the bounding box in pixels. You can specify an integer, or an empty string ('') if the fitHeight is specified.\n\n*fitHeight (numeric)* - The height of the bounding box in pixels. You can specify an integer, or an empty string ('') if the fitWidth is specified.\n\n*interpolation (string)* - The interpolation method for resampling. You can specify a specific interpolation algorithm by name (for example, hamming), by image quality (for example, mediumQuality), or by performance (for example, highestPerformance).  **Values:** *highestQuality (default), highQuality, mediumQuality, highestPerformance, highPerformance, mediumPerformance, nearest, bilinear, bicubic, bessel, blackman, hamming, hanning, hermite, lanczos, mitchell, quadratic*.\n\n*blurfactor (boolean)* - The blur factor used for resampling. The higher the blur factor, the more blurred the image (also, the longer it takes to resize the image). **Values:** *1-10*.\n"
    },
    {
        "prefix": "imageSetAntialiasing",
        "body": "imageSetAntialiasing(${1:name})",
        "documentation": " Switches antialiasing on or off in rendered graphics.\n\n**USAGE:**\n*void imageSetAntialiasing(name [, antialias])*\n\n**PARAMETERS:**\n\n*name (string)* - The ColdFusion image on which this operation is performed.\n\n*antialias (boolean)* - Antialiasing switch. **Default:** *on*. **Values:** *on, off*.\n"
    },
    {
        "prefix": "imageSetBackgroundColor",
        "body": "imageSetBackgroundColor(${1:name}, ${2|Hexadecimal value of RGB color. For example, specify the color white as ##FFFFFF or FFFFFF.,String value of color (for example, 'black'', 'red'', 'green').,List of three numbers for (R,G,B) values. Each value must be in the range 0255.|})",
        "documentation": " Sets the background color for the ColdFusion image. The background color is used for clearing a region. Setting the background color only affects the subsequent imageClearRect calls\n\n**USAGE:**\n*void imageSetBackgroundColor(name, color)*\n\n**PARAMETERS:**\n\n*name ()* - The ColdFusion image on which this operation is performed.\n\n*color ()* - Background color. **Default:** *black*. **Values:** *Hexadecimal value of RGB color. For example, specify the color white as ##FFFFFF or FFFFFF., String value of color (for example, 'black'', 'red'', 'green')., List of three numbers for (R,G,B) values. Each value must be in the range 0255.*.\n"
    },
    {
        "prefix": "imageSetDrawingAlpha",
        "body": "imageSetDrawingAlpha(${1:name}, ${2:alpha})",
        "documentation": "\n\n**USAGE:**\n*void imageSetDrawingAlpha(name, alpha)*\n\n**PARAMETERS:**\n\n*name (any)*\n\n*alpha (numeric)*\n"
    },
    {
        "prefix": "imageSetDrawingColor",
        "body": "imageSetDrawingColor(${1:name}, ${2|Hexadecimal value of RGB color. For example, specify the color white as ##FFFFFF or FFFFFF.,String value of color (for example, 'black'', 'red'', 'green').,List of three numbers for (R,G,B) values. Each value must be in the range 0255.|})",
        "documentation": " Sets the current drawing color for ColdFusion images. All subsequent graphics operations use the specified color.\n\n**USAGE:**\n*void imageSetDrawingColor(name, color)*\n\n**PARAMETERS:**\n\n*name (string)* - The ColdFusion image on which this operation is performed.\n\n*color ()* - Color. **Default:** *black*. **Values:** *Hexadecimal value of RGB color. For example, specify the color white as ##FFFFFF or FFFFFF., String value of color (for example, 'black'', 'red'', 'green')., List of three numbers for (R,G,B) values. Each value must be in the range 0255.*.\n"
    },
    {
        "prefix": "imageSetDrawingStroke",
        "body": "imageSetDrawingStroke(${1:name})",
        "documentation": " Sets the drawing stroke for points and lines in subsequent ColdFusion images.\n\n**USAGE:**\n*void imageSetDrawingStroke(name [, attributecollection])*\n\n**PARAMETERS:**\n\n*name (string)* - The ColdFusion image on which this operation is performed.\n\n*attributecollection (struct)* - The structure used to specify the line attributes\r\n\r\nwidth: Pen width, which is measured perpendicularly to the pen trajectory.\r\n\r\nendcaps: Decoration applied to the ends of unclosed subpaths and dash segments. Subpaths that start and end on the same point are considered unclosed if they do not have a close segment: (butt,round,square)\r\n\r\nlineJoins: Type of line joins: (bevel,miter,join)\r\n\r\nmiterLimit: The limit to trim a line join that has a mitered join decoration. (Use only when lineJoins = 'miter'.) A line join is trimmed when the ratio of miter length to stroke width is greater than the miterLimit value. The miter length is the diagonal length of the miter, which is the distance between the inside corner and the outside corner of the intersection. The smaller the angle formed by two line segments, the longer the miter length and the sharper the angle of intersection. The default value is 10.0, which trims all angles less than 11 degrees. Trimming miters converts the decoration of the line join to bevel.\r\n\r\ndashArray: An array of numbers that indicates the dash pattern. For example. if dashArray is (8,4), the dash pattern is 8 pixels solid, 4 pixels blank, 8 pixels solid, 4 pixels blank, and so on.\r\n\r\ndash_phases: An offset into the dash pattern. For example, a dash_phase of 2, and a dashArray of (8,4) produces the dash pattern of 6 pixels solid, 4 pixels blank, 8 pixels solid, 4 pixels blank, and so on.\n"
    },
    {
        "prefix": "imageSetDrawingTransparency",
        "body": "imageSetDrawingTransparency(${1:name}, ${2:percent})",
        "documentation": " Specifies the degree of transparency of drawing functions.\n\n**USAGE:**\n*void imageSetDrawingTransparency(name, percent)*\n\n**PARAMETERS:**\n\n*name (Stirng)* - The image on which this operation is performed.\n\n*percent (numeric)* - Percent of transparency, a floating point number in range 0-100\n"
    },
    {
        "prefix": "imageSharpen",
        "body": "imageSharpen(${1:name})",
        "documentation": " Sharpens a ColdFusion image by using the unsharp mask filter.\n\n**USAGE:**\n*void imageSharpen(name [, gain])*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*gain (numeric)* - Gain values can be integers or real numbers.. **Default:** *1.0*. **Values:** *> 0: the image is sharpened., = 0: no effect, < 0: the image is blurred.*.\n"
    },
    {
        "prefix": "imageShear",
        "body": "imageShear(${1:name}, ${2:shear})",
        "documentation": " Shears an image either horizontally or vertically.\n\n**USAGE:**\n*void imageShear(name, shear [, direction] [, interpolation])*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*shear (numeric)* - Shear value. Coordinates can be integers or real numbers.\n\n*direction (string)* - Shear direction. **Default:** *horizontal*. **Values:** *horizontal, vertical*.\n\n*interpolation (string)* - Type of interpolation. **Default:** *nearest*. **Values:** *nearest: Applies the nearest neighbor method of interpolation. Image quality is lower than the other interpolation methods, but processing is fastest., bilinear: Applies the bilinear method of interpolation. The quality of the image is less pixelated than the default, but processing is slower., bicubic: Applies the bicubic method of interpolation. Generally, the quality of image is highest with this method and processing is slowest.*.\n"
    },
    {
        "prefix": "imageShearDrawingAxis",
        "body": "imageShearDrawingAxis(${1:name}, ${2:shrx}, ${3:shry})",
        "documentation": " Shears the drawing canvas.\n\n**USAGE:**\n*void imageShearDrawingAxis(name, shrx, shry)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*shrx (numeric)* - The multiplier by which coordinates are shifted in the positive x axis direction as a function of the y coordinate.e\n\n*shry (numeric)* - the multiplier by which coordinates are shifted in the positive y axis direction as a function of the x coordinate.\n"
    },
    {
        "prefix": "imageTranslate",
        "body": "imageTranslate(${1:name}, ${2:xTrans}, ${3:yTrans})",
        "documentation": " Copies an image to a new location on the plane.\n\n**USAGE:**\n*void imageTranslate(name, xTrans, yTrans [, interpolation])*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*xTrans (numeric)* - Displacement in the x direction.\n\n*yTrans (numeric)* - Displacement in the y direction.\n\n*interpolation (string)* - Type of interpolation. **Default:** *nearest*. **Values:** *nearest : Applies the nearest neighbor method of interpolation. Image quality is lower than the other interpolation methods, but processing is fastest., bilinear: Applies the bilinear method of interpolation. The quality of the image is less pixelated than the default, but processing is slower., bicubic: Applies the bicubic method of interpolation. Generally, the quality of image is highest with this method and processing is slowest.*.\n"
    },
    {
        "prefix": "imageTranslateDrawingAxis",
        "body": "imageTranslateDrawingAxis(${1:name}, ${2:x}, ${3:y})",
        "documentation": " Translates the origin of the image context to the point (x,y) in the current coordinate system. Modifies the image context so that its new origin corresponds to the point (x,y) in the image's original coordinate system.\n\n**USAGE:**\n*void imageTranslateDrawingAxis(name, x, y)*\n\n**PARAMETERS:**\n\n*name ()* - The image on which this operation is performed.\n\n*x (numeric)* - x coordinate\n\n*y (numeric)* - y coordinate\n"
    },
    {
        "prefix": "imageWrite",
        "body": "imageWrite(${1:name})",
        "documentation": " Writes a ColdFusion image to the specified filename or destination.\n\n**USAGE:**\n*void imageWrite(name [, destination] [, quality] [, overwrite])*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*destination (string)* - The path to write the file.\r\n\r\nIf you create the image with the ImageNew function or another operation where you do not specify the filename, specify the destination parameter. The file format is derived from the extension of the filename. The default value for this parameter is the filename of the original image source.\n\n*quality (string)* - Defines the JPEG quality used to encode the image. This parameter applies only to destination files with an extension of JPG or JPEG. Valid values are fractions that range from 0 through 1 (the lower the number, the lower the quality). The default value is 0.75.\n\n*overwrite (boolean)* - If set to true, overwrites the destination file. **Default:** *true*. **Values:** *false, true*.\n"
    },
    {
        "prefix": "imageWriteBase64",
        "body": "imageWriteBase64(${1:name}, ${2:destination}, ${3:format})",
        "documentation": " Writes Base64 images to the specified filename and destination.\n\n**USAGE:**\n*void imageWriteBase64(name, destination, format [, inHTMLFormat] [, overwrite])*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*destination (string)* - The path for the destination file.\n\n*format (string)* - the image format\n\n*inHTMLFormat (boolean)* - Specify whether Base64 output includes the headers used by the Base64 images in the HTML 'img' tag ('data:image/{format};base64,...') **Values:** *false, true*.\n\n*overwrite (boolean)* - If set to true, overwrites the destination file.. **Default:** *true*. **Values:** *false, true*.\n"
    },
    {
        "prefix": "imageXORDrawingMode",
        "body": "imageXORDrawingMode(${1:name}, ${2|Hexadecimal value of RGB color. For example, specify the color white as ##FFFFFF or FFFFFF.,String value of color (for example, 'black', 'red', 'green').,List of three numbers for (R,G,B) values. Each value must be in the range 0-255.|})",
        "documentation": " Sets the paint mode of the image to alternate between the image's current color and the new specified color.\n\n**USAGE:**\n*void imageXORDrawingMode(name, c1)*\n\n**PARAMETERS:**\n\n*name (string)* - The image on which this operation is performed.\n\n*c1 (string)* - The color. **Default:** *black*. **Values:** *Hexadecimal value of RGB color. For example, specify the color white as ##FFFFFF or FFFFFF., String value of color (for example, 'black', 'red', 'green')., List of three numbers for (R,G,B) values. Each value must be in the range 0-255.*.\n"
    },
    {
        "prefix": "incrementValue",
        "body": "incrementValue(${1:number})",
        "documentation": "Increment the integer part of a number.\nSame as x=x+1 or x++\n\n**USAGE:**\n*numeric incrementValue(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "inputBaseN",
        "body": "inputBaseN(${1:String}, ${2:radix})",
        "documentation": "Converts string, using the base specified by radix, to an integer.\n\n**USAGE:**\n*numeric inputBaseN(String, radix)*\n\n**PARAMETERS:**\n\n*String (string)*\n\n*radix (string)*\n"
    },
    {
        "prefix": "insert",
        "body": "insert(${1:substring}, ${2:String}, ${3:position})",
        "documentation": " Inserts a substring in a string after a specified character\n position. If position = 0, prefixes the substring to the\n string.\n\n**USAGE:**\n*string insert(substring, String, position)*\n\n**PARAMETERS:**\n\n*substring (string)* - A string to insert\n\n*String (string)* - A string, which to insert substring\n\n*position (numeric)* - Substring add after this postion value in given string\n"
    },
    {
        "prefix": "int",
        "body": "int(${1:number})",
        "documentation": " Calculates the closest integer that is smaller than number.\n\n**USAGE:**\n*numeric int(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "invalidateOauthAccesstoken",
        "body": "invalidateOauthAccesstoken(${1:token}, ${2:type})",
        "documentation": "Invalidates the access token generated by the OAUTH servers.\n\n**USAGE:**\n*void invalidateOauthAccesstoken(token, type)*\n\n**PARAMETERS:**\n\n*token ()* - The access token to invalidate.\n\n*type ()* - The type of the OAUTH server (facebook/google).\n"
    },
    {
        "prefix": "invoke",
        "body": "invoke(${1:cfcinstance}, ${2:methodname})",
        "documentation": "Invokes a component method and returns the result of the invoked method.\n\n**USAGE:**\n*any invoke(cfcinstance, methodname [, arguments])*\n\n**PARAMETERS:**\n\n*cfcinstance (string)* - Name or instance of a CFC.\n\n*methodname (string)* - The name of the method to invoke.\n\n*arguments (struct)* - A struct of arguments to pass into the method.\n"
    },
    {
        "prefix": "isArray",
        "body": "isArray(${1:value})",
        "documentation": " Determines whether a value is an array.\n True, if value is an array, a query column object, or xml.\n also number = Dimension; function tests whether the array has\n exactly this dimension\n\n**USAGE:**\n*boolean isArray(value [, number])*\n\n**PARAMETERS:**\n\n*value (any)* - The array in which to check.\n\n*number (numeric)* - Dimension of the array.\n"
    },
    {
        "prefix": "isBinary",
        "body": "isBinary(${1:value})",
        "documentation": " Determines whether a value is stored as binary data.\n\n**USAGE:**\n*boolean isBinary(value)*\n\n**PARAMETERS:**\n\n*value (any)*\n"
    },
    {
        "prefix": "isBoolean",
        "body": "isBoolean(${1:value})",
        "documentation": "Returns true when a value can be converted to Boolean\n\n**USAGE:**\n*boolean isBoolean(value)*\n\n**PARAMETERS:**\n\n*value (any)*\n"
    },
    {
        "prefix": "isClosure",
        "body": "isClosure(${1:object})",
        "documentation": "Checks if a given object is a closure.\n\n**USAGE:**\n*boolean isClosure(object)*\n\n**PARAMETERS:**\n\n*object (any)* - The object to check if it is a closure.\n"
    },
    {
        "prefix": "isCustomFunction",
        "body": "isCustomFunction(${1:Object})",
        "documentation": " Determines whether a name represents a custom function\n\n**USAGE:**\n*boolean isCustomFunction(Object)*\n\n**PARAMETERS:**\n\n*Object (any)*\n"
    },
    {
        "prefix": "isDate",
        "body": "isDate(${1:Object})",
        "documentation": " Determines whether a string or Java object can be converted\n to a date/time value.\n\n**USAGE:**\n*boolean isDate(Object)*\n\n**PARAMETERS:**\n\n*Object (any)* - A string or variable name\n"
    },
    {
        "prefix": "isDDX",
        "body": "isDDX(${1:path})",
        "documentation": " Determines whether a DDX file exists and is valid, or if a string contains valid DDX instructions.\n\n**USAGE:**\n*boolean isDDX(path)*\n\n**PARAMETERS:**\n\n*path (string)* - Pathname to the DDX file or a string of DDX instructions.\n"
    },
    {
        "prefix": "isDebugMode",
        "body": "isDebugMode()",
        "documentation": "Determines whether debugging output is enabled.\n\n**USAGE:**\n*boolean isDebugMode()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "isDefined",
        "body": "isDefined(${1:variable_name})",
        "documentation": " Evaluates a string value to determine whether the variable\n named in it exists.\n\n**USAGE:**\n*boolean isDefined(variable_name)*\n\n**PARAMETERS:**\n\n*variable_name (string)*\n"
    },
    {
        "prefix": "isEmpty",
        "body": "isEmpty(${1:value})",
        "documentation": "Returns whether or not a given value is \"empty\". \n\n**USAGE:**\n*boolean isEmpty(value)*\n\n**PARAMETERS:**\n\n*value (any)*\n"
    },
    {
        "prefix": "isFileObject",
        "body": "isFileObject(${1:filePath})",
        "documentation": "\n\n**USAGE:**\n*boolean isFileObject(filePath)*\n\n**PARAMETERS:**\n\n*filePath ()* - The path to the file you are checking.\n"
    },
    {
        "prefix": "isImage",
        "body": "isImage(${1:name})",
        "documentation": " Determines whether a variable returns a ColdFusion image.\n\n**USAGE:**\n*boolean isImage(name)*\n\n**PARAMETERS:**\n\n*name (string)* - No Help Available\n"
    },
    {
        "prefix": "isImageFile",
        "body": "isImageFile(${1:path})",
        "documentation": "Verifies whether an image file is valid.\n\n**USAGE:**\n*boolean isImageFile(path)*\n\n**PARAMETERS:**\n\n*path (string)* - Pathname to a image file.\n"
    },
    {
        "prefix": "isInstanceOf",
        "body": "isInstanceOf(${1:object}, ${2:typename})",
        "documentation": " Determines whether an object is an instance of a Coldfusion interface or component, or of a Java class.\n\n**USAGE:**\n*boolean isInstanceOf(object, typename)*\n\n**PARAMETERS:**\n\n*object (any)* - The CFC instance or Java object that you are testing\n\n*typename (string)* - The name of the interface, component, or Java class of which the object might be an instance\n"
    },
    {
        "prefix": "isIPInRange",
        "body": "isIPInRange(${1:ips}, ${2:ip})",
        "documentation": "\n\n**USAGE:**\n*boolean isIPInRange(ips, ip)*\n\n**PARAMETERS:**\n\n*ips (any)*\n\n*ip (string)*\n"
    },
    {
        "prefix": "isIPV6",
        "body": "isIPV6(${1:IP})",
        "documentation": " checks if given IP is of IPV6 format\n\n**USAGE:**\n*boolean isIPV6(IP)*\n\n**PARAMETERS:**\n\n*IP (string)* - No Help Available\n"
    },
    {
        "prefix": "isJSON",
        "body": "isJSON(${1:var})",
        "documentation": " Evaluates whether a string is in valid JSON (JavaScript Object Notation) data interchange format.\n\n**USAGE:**\n*boolean isJSON(var)*\n\n**PARAMETERS:**\n\n*var (string)* - A string or variable that represents one.\n"
    },
    {
        "prefix": "isLeapYear",
        "body": "isLeapYear(${1:year})",
        "documentation": " Determines whether a year is a leap year.\n\n**USAGE:**\n*boolean isLeapYear(year)*\n\n**PARAMETERS:**\n\n*year (numeric)*\n"
    },
    {
        "prefix": "isLocalhost",
        "body": "isLocalhost(${1:ipaddress})",
        "documentation": " Determines whether the specified IP address is the localhost.\n\n**USAGE:**\n*boolean isLocalhost(ipaddress)*\n\n**PARAMETERS:**\n\n*ipaddress (string)* - Valid IP address.\n"
    },
    {
        "prefix": "isNotMap",
        "body": "isNotMap(${1:obj})",
        "documentation": "\n\n**USAGE:**\n*boolean isNotMap(obj)*\n\n**PARAMETERS:**\n\n*obj (any)*\n"
    },
    {
        "prefix": "isNull",
        "body": "isNull(${1:object})",
        "documentation": "Returns true if the specified object is null.\n\n**USAGE:**\n*boolean isNull(object)*\n\n**PARAMETERS:**\n\n*object (variableName)*\n"
    },
    {
        "prefix": "isNumeric",
        "body": "isNumeric(${1:String})",
        "documentation": "Determines whether a string can be converted to a numeric value. Supports numbers in U.S. number format. For other number support use LSIsNumeric.\n\n**USAGE:**\n*boolean isNumeric(String)*\n\n**PARAMETERS:**\n\n*String (string)*\n"
    },
    {
        "prefix": "isNumericDate",
        "body": "isNumericDate(${1:number})",
        "documentation": " Evaluates whether a real number is a valid representation of a\n date (date/time object).\n\n**USAGE:**\n*boolean isNumericDate(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "isObject",
        "body": "isObject(${1:value})",
        "documentation": " Determines whether a value is an object.\n True, if the value represents a CFML object. False if\n the value is any other type of data, such as an integer, string,\n date, or struct.\n\n**USAGE:**\n*boolean isObject(value)*\n\n**PARAMETERS:**\n\n*value (any)*\n"
    },
    {
        "prefix": "isPDFArchive",
        "body": "isPDFArchive(${1:path}, ${2|1b,2b,3b|})",
        "documentation": "Returns `true` if the pdf file at the specified `path` meets the specified `standard`.\n\n**USAGE:**\n*boolean isPDFArchive(path, standard)*\n\n**PARAMETERS:**\n\n*path (string)* - Path to a PDF file.\n\n*standard (string)* - PDF Archiving Standard **Values:** *1b, 2b, 3b*.\n"
    },
    {
        "prefix": "isPDFFile",
        "body": "isPDFFile(${1:path})",
        "documentation": " Verifies whether a PDF file is valid.\n\n**USAGE:**\n*boolean isPDFFile(path)*\n\n**PARAMETERS:**\n\n*path (string)* - Pathname to a PDF file.\n"
    },
    {
        "prefix": "isPDFObject",
        "body": "isPDFObject(${1:value})",
        "documentation": " Determines whether a value is a PDF object.\n\n**USAGE:**\n*boolean isPDFObject(value)*\n\n**PARAMETERS:**\n\n*value (variableName)* - A value, typically the PDF object stored as a variable name.\n"
    },
    {
        "prefix": "isQuery",
        "body": "isQuery(${1:value})",
        "documentation": " Determines whether a value is a query.\n\n**USAGE:**\n*boolean isQuery(value)*\n\n**PARAMETERS:**\n\n*value (string)*\n"
    },
    {
        "prefix": "isSafeHTML",
        "body": "isSafeHTML(${1:inputString}, ${2:PolicyFile})",
        "documentation": "Checks a HTML string against antisamy policy file to determine if it may be vulnerable to XSS / Cross Site Scripting.\n\n**USAGE:**\n*boolean isSafeHTML(inputString, PolicyFile)*\n\n**PARAMETERS:**\n\n*inputString (string)* - String to be validated\n\n*PolicyFile (string)* - File path for custom antisamy policy file. Can be defined in the application scope or if not defined will use Coldfusion server default\n"
    },
    {
        "prefix": "isSimpleValue",
        "body": "isSimpleValue(${1:value})",
        "documentation": " Determines the type of a value.\n\n**USAGE:**\n*boolean isSimpleValue(value)*\n\n**PARAMETERS:**\n\n*value (any)*\n"
    },
    {
        "prefix": "isSOAPRequest",
        "body": "isSOAPRequest()",
        "documentation": " Determines whether a CFC is being called as a web service.\n\n**USAGE:**\n*boolean isSOAPRequest()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "isSpreadsheetFile",
        "body": "isSpreadsheetFile(${1:file})",
        "documentation": "Checks if given file is spreadsheet file or not\n\n**USAGE:**\n*boolean isSpreadsheetFile(file)*\n\n**PARAMETERS:**\n\n*file (string)* - Any file\n"
    },
    {
        "prefix": "isSpreadsheetObject",
        "body": "isSpreadsheetObject(${1:object})",
        "documentation": "Checks if given object is spreadsheet object or not\n\n**USAGE:**\n*boolean isSpreadsheetObject(object)*\n\n**PARAMETERS:**\n\n*object (variableName)* - Any Object\n"
    },
    {
        "prefix": "isStruct",
        "body": "isStruct(${1:variable})",
        "documentation": " Determines whether a variable is a structure.\n True, if variable is a CFML structure or is a Java object\n that implements the java.lang.Map interface. Returns False if the\n object in variable is a user-defined function (UDF).\n\n**USAGE:**\n*boolean isStruct(variable)*\n\n**PARAMETERS:**\n\n*variable (any)*\n"
    },
    {
        "prefix": "isUserInAnyRole",
        "body": "isUserInAnyRole(${1:roleList})",
        "documentation": " Determines whether an authenticated user belongs to any role in a list of roles.\n\n**USAGE:**\n*boolean isUserInAnyRole(roleList)*\n\n**PARAMETERS:**\n\n*roleList (string)* - No Help Available\n"
    },
    {
        "prefix": "isUserInRole",
        "body": "isUserInRole(${1:role_name})",
        "documentation": " Determines whether an authenticated user belongs to the\n specified Role.\n\n**USAGE:**\n*string isUserInRole(role_name)*\n\n**PARAMETERS:**\n\n*role_name (string)*\n"
    },
    {
        "prefix": "isUserLoggedIn",
        "body": "isUserLoggedIn()",
        "documentation": " Determines whether a user is logged in.\n\n**USAGE:**\n*boolean isUserLoggedIn()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "isValid",
        "body": "isValid(${1|Any,Array,Binary,boolean,creditcard,date,time,email,eurodate,float,Numeric,guid,integer,Query,range,Regex,regular_expression,ssn,social_security_number,String,Struct,telephone,URL,UUID,usdate,variablename,xml,zipcode,component|}, ${2:value}, ${3:min}, ${4:max}, ${5:pattern})",
        "documentation": "Tests whether a value meets a validation or data type rule.\n\n**USAGE:**\n*boolean isValid(type, value, min, max, pattern)*\n\n**PARAMETERS:**\n\n*type (string)* - The valid format for the data. **Values:** *Any, Array, Binary, boolean, creditcard, date, time, email, eurodate, float, Numeric, guid, integer, Query, range, Regex, regular_expression, ssn, social_security_number, String, Struct, telephone, URL, UUID, usdate, variablename, xml, zipcode, component*.\n\n*value (any)* - The value to test.\n\n*min (numeric)* - The minimum valid value; used only for range validation.\n\n*max (numeric)* - The maximum valid value; used only for range validation.\n\n*pattern (string)* - A regular expression that the parameter must match;\n used only for regex or regular_expression validation.\n"
    },
    {
        "prefix": "isValidOauthAccesstoken",
        "body": "isValidOauthAccesstoken(${1:token}, ${2:type})",
        "documentation": "Checks if the OAuth access token is still valid.\n\n**USAGE:**\n*boolean isValidOauthAccesstoken(token, type)*\n\n**PARAMETERS:**\n\n*token ()* - The access token to check.\n\n*type ()* - The type of the OAuth server (facebook/google).\n"
    },
    {
        "prefix": "isVideoFile",
        "body": "isVideoFile(${1:path})",
        "documentation": "Checks if given string is a video file\n\n**USAGE:**\n*boolean isVideoFile(path)*\n\n**PARAMETERS:**\n\n*path (string)* - Pathname to a video file.\n"
    },
    {
        "prefix": "isWDDX",
        "body": "isWDDX(${1:value})",
        "documentation": " Determines whether a value is a well-formed WDDX packet.\n\n**USAGE:**\n*boolean isWDDX(value)*\n\n**PARAMETERS:**\n\n*value (any)*\n"
    },
    {
        "prefix": "isXML",
        "body": "isXML(${1:value})",
        "documentation": " Determines whether a string is well-formed XML text.\n\n**USAGE:**\n*boolean isXML(value)*\n\n**PARAMETERS:**\n\n*value (string)* - A string containing the XML document text.\n"
    },
    {
        "prefix": "isXMLAttribute",
        "body": "isXMLAttribute(${1:value})",
        "documentation": " Determines whether the function parameter is an\n XML Document Object Model (DOM) attribute node.\n\n**USAGE:**\n*boolean isXMLAttribute(value)*\n\n**PARAMETERS:**\n\n*value (any)* - Name of an XML attribute.\n"
    },
    {
        "prefix": "isXMLDoc",
        "body": "isXMLDoc(${1:value})",
        "documentation": "Determines whether a function parameter is an Extended Markup\n language (XML) document object.\n\n**USAGE:**\n*boolean isXMLDoc(value)*\n\n**PARAMETERS:**\n\n*value (any)* - XML document\n"
    },
    {
        "prefix": "isXMLElem",
        "body": "isXMLElem(${1:value})",
        "documentation": "Determines whether a function parameter is an Extended Markup\n language (XML) document object element.\n\n**USAGE:**\n*boolean isXMLElem(value)*\n\n**PARAMETERS:**\n\n*value (any)* - XML Element\n"
    },
    {
        "prefix": "isXMLNode",
        "body": "isXMLNode(${1:value})",
        "documentation": " Determines whether the function parameter is\n an XML document object node.\n\n**USAGE:**\n*boolean isXMLNode(value)*\n\n**PARAMETERS:**\n\n*value (any)* - XML document object node.\n"
    },
    {
        "prefix": "isXMLRoot",
        "body": "isXMLRoot(${1:value})",
        "documentation": " Determines whether a function parameter is the root element of\n an Extended Markup language (XML) document object.\n\n**USAGE:**\n*boolean isXMLRoot(value)*\n\n**PARAMETERS:**\n\n*value (any)* - XML Element\n"
    },
    {
        "prefix": "isZipFile",
        "body": "isZipFile(${1:path})",
        "documentation": "\n\n**USAGE:**\n*boolean isZipFile(path)*\n\n**PARAMETERS:**\n\n*path (string)*\n"
    },
    {
        "prefix": "javacast",
        "body": "javacast(${1|boolean,double,float,int,long,string,null,byte,bigdecimal,char,short|}, ${2:variable})",
        "documentation": "Converts the data type of a CFML variable to pass as an argument to an overloaded method of a Java object.\n\n**USAGE:**\n*any javacast(type, variable)*\n\n**PARAMETERS:**\n\n*type (string)* - The name of a java primative or a Java class name. **Values:** *boolean, double, float, int, long, string, null, byte, bigdecimal, char, short*.\n\n*variable (string)* - A variable, java object or array.\n"
    },
    {
        "prefix": "jsStringFormat",
        "body": "jsStringFormat(${1:String})",
        "documentation": " Escapes special JavaScript characters, such as single quotation\n mark, double quotation mark, and newline\n\n**USAGE:**\n*string jsStringFormat(String)*\n\n**PARAMETERS:**\n\n*String (string)*\n"
    },
    {
        "prefix": "lCase",
        "body": "lCase(${1:String})",
        "documentation": " Converts the alphabetic characters in a string to lowercase.\n\n**USAGE:**\n*string lCase(String)*\n\n**PARAMETERS:**\n\n*String (string)*\n"
    },
    {
        "prefix": "left",
        "body": "left(${1:String}, ${2:count})",
        "documentation": " Returns the leftmost count characters in a string.\n\n**USAGE:**\n*string left(String, count)*\n\n**PARAMETERS:**\n\n*String (string)*\n\n*count (numeric)*\n"
    },
    {
        "prefix": "len",
        "body": "len(${1:Object})",
        "documentation": " Determines the length of a string or binary object\n\n**USAGE:**\n*numeric len(Object)*\n\n**PARAMETERS:**\n\n*Object (any)* - A string or variable name\n"
    },
    {
        "prefix": "listAppend",
        "body": "listAppend(${1:list}, ${2:value})",
        "documentation": " Concatenates a list or element to a list.\n\n**USAGE:**\n*string listAppend(list, value [, delimiters])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*value (string)* - An element or a list of elements.\n\n*delimiters (string)*. **Default:** *,*. **Values:** *,, |, _, ;, :*.\n"
    },
    {
        "prefix": "listAvg",
        "body": "listAvg(${1:list})",
        "documentation": "\n\n**USAGE:**\n*numeric listAvg(list [, delimiters] [, multiCharacterDelimiter])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*delimiters (string)*. **Default:** *,*.\n\n*multiCharacterDelimiter (boolean)*. **Default:** *false*.\n"
    },
    {
        "prefix": "listChangeDelims",
        "body": "listChangeDelims(${1:list}, ${2:new_delimiter})",
        "documentation": " Changes a list delimiter.\n Returns a copy of the list, with each delimiter character\n replaced by new_delimiter.\n\n**USAGE:**\n*string listChangeDelims(list, new_delimiter [, delimiters] [, includeEmptyValues])*\n\n**PARAMETERS:**\n\n*list (string)* - A list or a variable that contains one.\n\n*new_delimiter (string)* - Delimiter string or a variable that contains one. Can be an empty string. ColdFusion processes the string as one delimiter.\n\n*delimiters (string)* - A string or a variable that contains one. Characters that separate list elements. The default value is comma. If this parameter contains more than one character, ColdFusion processes each occurrence of each character as a delimiter.. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n\n*includeEmptyValues (string)* - CF10+ Set to yes to include empty values.. **Default:** *NO*. **Values:** *Yes, No*.\n"
    },
    {
        "prefix": "listCompact",
        "body": "listCompact(${1:list})",
        "documentation": "Remove empty elements from start and end of the list\n\n**USAGE:**\n*string listCompact(list [, delimiters] [, multiCharacterDelimiter])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*delimiters (string)*. **Default:** *,*.\n\n*multiCharacterDelimiter (boolean)*. **Default:** *false*.\n"
    },
    {
        "prefix": "listContains",
        "body": "listContains(${1:list}, ${2:substring})",
        "documentation": " Determines the index of the first list element that contains a\n specified substring.\n Returns the index of the first list element that contains\n substring. If not found, returns zero. The search for the substring is case-sensitive.\n\n**USAGE:**\n*numeric listContains(list, substring [, delimiters])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*substring (string)*\n\n*delimiters (string)*. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n"
    },
    {
        "prefix": "listContainsNoCase",
        "body": "listContainsNoCase(${1:list}, ${2:substring})",
        "documentation": " Determines the index of the first list element that contains a\n specified substring.\n\n**USAGE:**\n*numeric listContainsNoCase(list, substring [, delimiters])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*substring (string)*\n\n*delimiters (string)*. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n"
    },
    {
        "prefix": "listDeleteAt",
        "body": "listDeleteAt(${1:list}, ${2:position})",
        "documentation": " Deletes an element from a list.\n Returns a copy of the list, without the specified element.\n\n**USAGE:**\n*string listDeleteAt(list, position [, delimiters])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*position (numeric)*\n\n*delimiters (string)*. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n"
    },
    {
        "prefix": "listEach",
        "body": "listEach(${1:str}, ${2:function}, ${3:delim})",
        "documentation": "Iterates over every element of a List object and can call a UDF function, passed as the second argument.\n\n**USAGE:**\n*void listEach(str, function, delim [, includeEmptyFields])*\n\n**PARAMETERS:**\n\n*str ()* - An input list object.\n\n*function ()* - UDF or closure object.\n\n*delim ()* - A list delimiter to be used. The default value is comma (,).\n\n*includeEmptyFields ()* - Boolean. Whether to allow empty fields. Default is false.\n"
    },
    {
        "prefix": "listEvery",
        "body": "listEvery(${1:list}, ${2:closure})",
        "documentation": "\n\n**USAGE:**\n*boolean listEvery(list, closure [, delimiter] [, includeEmptyFields] [, multiCharacterDelimiter] [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*closure (function)*\n\n*delimiter (string)*. **Default:** *,*.\n\n*includeEmptyFields (boolean)*. **Default:** *false*.\n\n*multiCharacterDelimiter (boolean)*. **Default:** *true*.\n\n*parallel (boolean)*. **Default:** *false*.\n\n*maxThreads (numeric)*. **Default:** *20*.\n"
    },
    {
        "prefix": "listFilter",
        "body": "listFilter(${1:list}, ${2:function})",
        "documentation": "Used to filter an list to items for which the closure function returns true.\n\n**USAGE:**\n*string listFilter(list, function)*\n\n**PARAMETERS:**\n\n*list (List)*\n\n*function (function)* - Inline closure function executed for each element in the list. Returns true if the list element should be included in the filtered list. Support for passing the original list to the closure function added in CF11 Update 5.\n"
    },
    {
        "prefix": "listFind",
        "body": "listFind(${1:list}, ${2:value})",
        "documentation": "Determines the index of the first list element in which a specified value occurs. Returns 0 if not found. Case-sensitive\n\n**USAGE:**\n*numeric listFind(list, value [, delimiters] [, includeEmptyValues])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*value (string)*\n\n*delimiters (string)*. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n\n*includeEmptyValues (string)*. **Default:** *false*. **Values:** *true, false*.\n"
    },
    {
        "prefix": "listFindNoCase",
        "body": "listFindNoCase(${1:list}, ${2:value})",
        "documentation": "Determines the index of the first list element in which a specified value occurs. Returns 0 if not found. Case-insensitive.\n\n**USAGE:**\n*numeric listFindNoCase(list, value [, delimiters] [, includeEmptyValues])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*value (string)*\n\n*delimiters (string)*. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n\n*includeEmptyValues (string)*. **Default:** *false*. **Values:** *true, false*.\n"
    },
    {
        "prefix": "listFirst",
        "body": "listFirst(${1:list})",
        "documentation": " Gets the first element of a list.\n\n**USAGE:**\n*string listFirst(list [, delimiters])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*delimiters (string)*. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n"
    },
    {
        "prefix": "listGetAt",
        "body": "listGetAt(${1:list}, ${2:position})",
        "documentation": " Gets a list element at a specified position.\n\n**USAGE:**\n*string listGetAt(list, position [, delimiters] [, includeEmptyValues])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*position (numeric)*\n\n*delimiters (string)*. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n\n*includeEmptyValues (boolean)*. **Default:** *false*.\n"
    },
    {
        "prefix": "listIndexExists",
        "body": "listIndexExists(${1:list}, ${2:index})",
        "documentation": "\n\n**USAGE:**\n*boolean listIndexExists(list, index [, delimiter] [, includeEmptyFields])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*index (numeric)*\n\n*delimiter (string)*. **Default:** *,*.\n\n*includeEmptyFields (boolean)*\n"
    },
    {
        "prefix": "listInsertAt",
        "body": "listInsertAt(${1:list}, ${2:position}, ${3:value})",
        "documentation": " Inserts an element in a list.\n\n**USAGE:**\n*string listInsertAt(list, position, value [, delimiters])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*position (numeric)*\n\n*value (string)*\n\n*delimiters (string)*. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n"
    },
    {
        "prefix": "listItemTrim",
        "body": "listItemTrim(${1:list})",
        "documentation": "\n\n**USAGE:**\n*string listItemTrim(list [, delimiters] [, includeEmptyFields])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*delimiters (string)*. **Default:** *,*.\n\n*includeEmptyFields (boolean)*\n"
    },
    {
        "prefix": "listLast",
        "body": "listLast(${1:list})",
        "documentation": " Gets the last element of a list.\n\n**USAGE:**\n*string listLast(list [, delimiters])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*delimiters (string)*. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n"
    },
    {
        "prefix": "listLen",
        "body": "listLen(${1:list})",
        "documentation": " Determines the number of elements in a list.\n\n**USAGE:**\n*numeric listLen(list [, delimiters] [, includeEmptyValues])*\n\n**PARAMETERS:**\n\n*list (string)* - A list or a variable that contains one\n\n*delimiters (string)* - A string or a variable that contains one. Characters that separate list elements. The default value is comma. If this parameter contains more than one character, ColdFusion processes each occurrence of each character as a delimiter.. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n\n*includeEmptyValues (string)* - CF10+ If includeEmptyValues is set to true, all empty values in the list will be considered when computing length. If set to false, the empty list elements are ignored.. **Default:** *NO*. **Values:** *Yes, No*.\n"
    },
    {
        "prefix": "listMap",
        "body": "listMap(${1:list}, ${2:function}, ${3:intialValue}, ${4:delimiter}, ${5:includeEmptyFields})",
        "documentation": "Iterates over every entry of the List and calls the closure function to work on the item of the list. The returned value will be set at the same index in a new list and the new list will be returned.\n\n**USAGE:**\n*string listMap(list, function, intialValue, delimiter, includeEmptyFields)*\n\n**PARAMETERS:**\n\n*list (string)* - The input list.\n\n*function (any)* - Closure or a function reference that will be called for each of the iteration. The arguments passed to the callback are\r\n\r\nitem: value\r\nindex : current index for the iteration\r\nlist : reference of the original list\n\n*intialValue (any)* - Initial value which will be used for the reduce operation.\n\n*delimiter (string)* - The list delimiter.. **Default:** *,*.\n\n*includeEmptyFields (boolean)* - Include empty values. **Default:** *false*.\n"
    },
    {
        "prefix": "listPrepend",
        "body": "listPrepend(${1:list}, ${2:value})",
        "documentation": " Inserts an element at the beginning of a list.\n\n**USAGE:**\n*string listPrepend(list, value [, delimiters])*\n\n**PARAMETERS:**\n\n*list (string)* - A string list.\n\n*value (string)* - An element or list of elements.\n\n*delimiters (string)* - Characters that separate list elements.. **Default:** *,*. **Values:** *,, |, ;, -, chr(9), chr(10), chr(13)*.\n"
    },
    {
        "prefix": "listQualify",
        "body": "listQualify(${1:list}, ${2:qualifier})",
        "documentation": " Inserts a string at the beginning and end of list elements.\n\n**USAGE:**\n*string listQualify(list, qualifier [, delimiters] [, elements] [, includeEmptyFields])*\n\n**PARAMETERS:**\n\n*list (string)* - A list or variable name\n\n*qualifier (string)* - A string or character in which to insert before and after the list elements\n\n*delimiters (string)*. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n\n*elements (string)*. **Default:** *all*. **Values:** *all, char*.\n\n*includeEmptyFields (boolean)* - If includeEmptyFields is true, empty value add in list elements **Values:** *true, false*.\n"
    },
    {
        "prefix": "listReduce",
        "body": "listReduce(${1:list}, ${2:function}, ${3:intialValue}, ${4:delimiter}, ${5:includeEmptyFields})",
        "documentation": "Iterates over each item of the list and calls the closure to work on the item. This function will reduce the list to a single value and will return the value.\n\n**USAGE:**\n*any listReduce(list, function, intialValue, delimiter, includeEmptyFields)*\n\n**PARAMETERS:**\n\n*list (string)* - Input list\n\n*function (any)* - Closure or a function reference that will be called for each of the iteration. The arguments passed to the callback are\r\n\r\nitem: value\r\nindex : current index for the iteration\r\nlist : reference of the original list\n\n*intialValue (any)* - Initial value which will be used for the reduce operation. The type is any.\n\n*delimiter (string)* - The list delimiter.. **Default:** *comma*.\n\n*includeEmptyFields (boolean)* - Include empty values.. **Default:** *false*.\n"
    },
    {
        "prefix": "listRemoveDuplicates",
        "body": "listRemoveDuplicates(${1:list})",
        "documentation": "Removes duplicate values (if they exist) in a list.\n\n**USAGE:**\n*string listRemoveDuplicates(list [, delimiter] [, ignoreCase])*\n\n**PARAMETERS:**\n\n*list (string)* - Required. List of objects.\n\n*delimiter (string)* - Optional. Character(s) that separate list elements. The default value is comma.. **Default:** *,*.\n\n*ignoreCase (boolean)* - Optional. If true, ignores the case of strings in the list. By default the value is set to false.\n"
    },
    {
        "prefix": "listRest",
        "body": "listRest(${1:list})",
        "documentation": " Gets a list, without its first element.\n\n**USAGE:**\n*string listRest(list [, delimiters])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*delimiters (string)*. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n"
    },
    {
        "prefix": "listSetAt",
        "body": "listSetAt(${1:list}, ${2:position}, ${3:value})",
        "documentation": " Replaces the contents of a list element.\n\n**USAGE:**\n*string listSetAt(list, position, value [, delimiters])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*position (numeric)*\n\n*value (string)*\n\n*delimiters (string)*. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n"
    },
    {
        "prefix": "listSome",
        "body": "listSome(${1:list}, ${2:closure})",
        "documentation": "\n\n**USAGE:**\n*boolean listSome(list, closure [, delimiter] [, includeEmptyFields] [, multiCharacterDelimiter] [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*closure (function)*\n\n*delimiter (string)*. **Default:** *,*.\n\n*includeEmptyFields (boolean)*. **Default:** *false*.\n\n*multiCharacterDelimiter (boolean)*. **Default:** *true*.\n\n*parallel (boolean)*. **Default:** *false*.\n\n*maxThreads (numeric)*. **Default:** *20*.\n"
    },
    {
        "prefix": "listSort",
        "body": "listSort(${1:list}, ${2:sort_type})",
        "documentation": " Sorts list elements according to a sort type and sort order.\n Returns a sorted copy of the list.\n [sort_type - quicky]\n numeric: sorts numbers\n text: sorts text alphabetically, taking case into account\n - aabzABZ, if sort_order = \"asc\"\n - ZBAzbaa, if sort_order = \"desc\"\n textnocase: sorts text alphabetically, without regard to case\n - aAaBbBzzZ, in an asc sort;\n - ZzzBbBaAa, in a desc sort;\n\n**USAGE:**\n*string listSort(list, sort_type [, sort_order] [, delimiters])*\n\n**PARAMETERS:**\n\n*list (string)* - A list or variable name\n\n*sort_type (string)* - numeric: sorts numbers\n text: sorts text alphabetically, taking case into account\n (also known as case sensitive).\n - aabzABZ for ascending sort(sort_order = \"asc\")\n - ZBAzbaa for descending sort(sort_order = \"desc\")\n\n textnocase: sorts text alphabetically, without regard to\n case (also known as case-insensitive).\n - aAaBbBzzZ for ascending sort(sort_order = \"asc\")\n - ZzzBbBaAa for descending sort(sort_order = \"desc\")\n\n*sort_order (string)*. **Default:** *asc*. **Values:** *asc: ascending (a to z) sort order., desc: descending (z to a) sort order*.\n\n*delimiters (string)*. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n"
    },
    {
        "prefix": "listToArray",
        "body": "listToArray(${1:list})",
        "documentation": " Copies the elements of a list to an array.\n\n**USAGE:**\n*array listToArray(list [, delimiters] [, includeEmptyFields] [, multiCharacterDelimiter])*\n\n**PARAMETERS:**\n\n*list (string)* - A list or variable name\n\n*delimiters (string)*. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n\n*includeEmptyFields (boolean)* - A Boolean value specifying whether to create empty array entries if there are two delimiters in a row. **Values:** *true, false*.\n\n*multiCharacterDelimiter (boolean)* - A Boolean value specifying whether the delimiters parameter specifies a multi-character delimiter. **Values:** *true, false*.\n"
    },
    {
        "prefix": "listTrim",
        "body": "listTrim(${1:list})",
        "documentation": "\n\n**USAGE:**\n*string listTrim(list [, delimiters])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*delimiters (string)*. **Default:** *,*.\n"
    },
    {
        "prefix": "listValueCount",
        "body": "listValueCount(${1:list}, ${2:value})",
        "documentation": "Counts instances of a specified value in a list.\nThe search is case-sensitive. For case-insensitive search use listValueNoCase.\n\n**USAGE:**\n*numeric listValueCount(list, value [, delimiters])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*value (string)*\n\n*delimiters (string)*. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n"
    },
    {
        "prefix": "listValueCountNoCase",
        "body": "listValueCountNoCase(${1:list}, ${2:value})",
        "documentation": "Counts instances of a specified value in a list.\nThe search is case-insensitive. For case-sensitive search use listValue.\n\n**USAGE:**\n*numeric listValueCountNoCase(list, value [, delimiters])*\n\n**PARAMETERS:**\n\n*list (string)*\n\n*value (string)*\n\n*delimiters (string)*. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n"
    },
    {
        "prefix": "lJustify",
        "body": "lJustify(${1:String}, ${2:length})",
        "documentation": " Left justifies characters in a string of a specified length.\n\n**USAGE:**\n*string lJustify(String, length)*\n\n**PARAMETERS:**\n\n*String (string)*\n\n*length (numeric)*\n"
    },
    {
        "prefix": "location",
        "body": "location(${1:url})",
        "documentation": " Stops execution of the current page and opens a CFML page or HTML file.\n\n**USAGE:**\n*void location(url [, addtoken] [, statuscode])*\n\n**PARAMETERS:**\n\n*url (string)* - URL of HTML file or CFML page to open.\n\n*addtoken (boolean)* - clientManagement must be enabled (see cfapplication). **Values:** *true, false*.\n\n*statuscode (numeric)* - The HTTP status code\n"
    },
    {
        "prefix": "log",
        "body": "log(${1:number})",
        "documentation": " Calculates the natural logarithm of a number. Natural\n logarithms are based on the constant e (2.71828182845904).\n\n**USAGE:**\n*numeric log(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "log10",
        "body": "log10(${1:number})",
        "documentation": " Calculates the logarithm of number, to base 10.\n\n**USAGE:**\n*numeric log10(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "lsCurrencyFormat",
        "body": "lsCurrencyFormat(${1:number})",
        "documentation": "Formats a number in a locale-specific currency format. For countries that use the euro, the result depends on the JVM.\n [type - quicky]\n local: the currency format and currency symbol used locally.\n - With JDK 1.3, the default for Euro Zone: local currency.\n - With JDK 1.4, the default for Euro Zone: euro.\n international: the international standard currency format\n none: the local currency format; no currency symbol\n\n**USAGE:**\n*string lsCurrencyFormat(number [, type])*\n\n**PARAMETERS:**\n\n*number (numeric)*\n\n*type (string)* **Values:** *local, international, none*.\n"
    },
    {
        "prefix": "lsDateFormat",
        "body": "lsDateFormat(${1:date})",
        "documentation": "Formats the date part of a date/time value in a locale-specific format.\n [mask - quicky]\n d,dd,ddd,dddd: Day of month / week\n m,mm,mmm,mmmm: Month\n y,yy,yyyy: Year\n gg: Period/era string\n short / medium / long / full\n\n**USAGE:**\n*string lsDateFormat(date [, mask])*\n\n**PARAMETERS:**\n\n*date (date)*\n\n*mask (string)* **Values:** *short, medium, long, full*.\n"
    },
    {
        "prefix": "lsDateTimeFormat",
        "body": "lsDateTimeFormat(${1:date}, ${2:timeZone})",
        "documentation": " Formats date and time values using locale-specific date and time formatting conventions.\n\n**USAGE:**\n*string lsDateTimeFormat(date [, mask], timeZone [, locale])*\n\n**PARAMETERS:**\n\n*date ()* - A date/time object, in the range 100 AD-9999 AD.\n\n*mask ()* - Mask that has to be used for formatting.\n\n*timeZone ()* - The time-zone information. You can specify in either of the following formats. Abbreviation and Full Name.\n\n*locale ()* - Locale to use instead of the locale of the page when processing the function..\n"
    },
    {
        "prefix": "lsDayOfWeek",
        "body": "lsDayOfWeek(${1:date})",
        "documentation": "\n\n**USAGE:**\n*numeric lsDayOfWeek(date [, locale] [, timezone])*\n\n**PARAMETERS:**\n\n*date (date)*\n\n*locale (string)*\n\n*timezone (string)*\n"
    },
    {
        "prefix": "lsEuroCurrencyFormat",
        "body": "lsEuroCurrencyFormat(${1:currency}, ${2|local,international,none|})",
        "documentation": "Formats a number in a locale-specific currency format.\n [type - quicky]\n local: the currency format used in the locale. (Default.)\n international: the international standard currency format\n none: the currency format used; no currency symbol\n\n**USAGE:**\n*string lsEuroCurrencyFormat(currency, type)*\n\n**PARAMETERS:**\n\n*currency (string)*\n\n*type (string)* **Values:** *local, international, none*.\n"
    },
    {
        "prefix": "lsIsCurrency",
        "body": "lsIsCurrency(${1:String})",
        "documentation": "Determines whether a string is a valid representation of a currency amount in the current locale.\n\n**USAGE:**\n*boolean lsIsCurrency(String)*\n\n**PARAMETERS:**\n\n*String (string)*\n"
    },
    {
        "prefix": "lsIsDate",
        "body": "lsIsDate(${1:String})",
        "documentation": "Determines whether a string is a valid representation of a date/time value in the current locale.\n\n**USAGE:**\n*boolean lsIsDate(String)*\n\n**PARAMETERS:**\n\n*String (string)*\n"
    },
    {
        "prefix": "lsIsNumeric",
        "body": "lsIsNumeric(${1:String})",
        "documentation": " Determines whether a string is a valid representation of a\n number in the current locale.\n\n**USAGE:**\n*boolean lsIsNumeric(String)*\n\n**PARAMETERS:**\n\n*String (string)*\n"
    },
    {
        "prefix": "lsNumberFormat",
        "body": "lsNumberFormat(${1:number})",
        "documentation": "Formats a number in a locale-specific format.\n [mask - quicky]\n _,9 Digit placeholder; . decimal point; 0 Pads with zeros;\n ( ) less than zero, puts parentheses around the mask\n + plus sign before positive number minus before negative\n - a space before positive minus sign before negative\n , Separates every third decimal place with a comma.\n L,C Left-justifies or center-justifies number\n $ dollar sign before formatted number.\n ^ Separates left and right formatting.\n\n**USAGE:**\n*string lsNumberFormat(number [, mask])*\n\n**PARAMETERS:**\n\n*number (numeric)*\n\n*mask (string)*\n"
    },
    {
        "prefix": "lsParseCurrency",
        "body": "lsParseCurrency(${1:String})",
        "documentation": "Converts a locale-specific currency string into a formatted number. Attempts conversion by comparing the string with each the three supported currency formats (none, local, international) and using the first that matches.\n\n**USAGE:**\n*string lsParseCurrency(String)*\n\n**PARAMETERS:**\n\n*String (string)*\n"
    },
    {
        "prefix": "lsParseDateTime",
        "body": "lsParseDateTime(${1:dt_string})",
        "documentation": "Converts a string that is a valid date/time representation in the current locale into a date/time object.\n\n**USAGE:**\n*date lsParseDateTime(dt_string)*\n\n**PARAMETERS:**\n\n*dt_string (string)*\n"
    },
    {
        "prefix": "lsParseEuroCurrency",
        "body": "lsParseEuroCurrency(${1:currency_string})",
        "documentation": "Formats a locale-specific currency string as a number. Attempts conversion through each of the default currency formats (none, local, international). Ensures correct handling of euro currency for Euro zone countries.\n\n**USAGE:**\n*numeric lsParseEuroCurrency(currency_string)*\n\n**PARAMETERS:**\n\n*currency_string (string)*\n"
    },
    {
        "prefix": "lsParseNumber",
        "body": "lsParseNumber(${1:String})",
        "documentation": "Converts a string that is a valid numeric representation in the current locale into a formatted number.\n\n**USAGE:**\n*numeric lsParseNumber(String)*\n\n**PARAMETERS:**\n\n*String (string)*\n"
    },
    {
        "prefix": "lsTimeFormat",
        "body": "lsTimeFormat(${1:time})",
        "documentation": "Formats the time part of a date/time string into a string in a locale-specific format.\n [mask - quicky]\n h,hh,H,HH: Hours; m,mm: Minutes; s,ss: Seconds;\n l: Milliseconds; t: A or P; tt: AM or PM\n \"short\" = h:mm tt; \"medium\" = h:mm:ss tt\n\n**USAGE:**\n*string lsTimeFormat(time [, mask])*\n\n**PARAMETERS:**\n\n*time (date)*\n\n*mask (string)* **Values:** *short, medium, long*.\n"
    },
    {
        "prefix": "lsWeek",
        "body": "lsWeek(${1:date})",
        "documentation": "\n\n**USAGE:**\n*numeric lsWeek(date [, locale] [, timezone])*\n\n**PARAMETERS:**\n\n*date (date)*\n\n*locale (string)*\n\n*timezone (string)*\n"
    },
    {
        "prefix": "lTrim",
        "body": "lTrim(${1:String})",
        "documentation": " Removes leading spaces from a string.\n\n**USAGE:**\n*string lTrim(String)*\n\n**PARAMETERS:**\n\n*String (string)*\n"
    },
    {
        "prefix": "manifestRead",
        "body": "manifestRead(${1:path})",
        "documentation": "reads a manifest file and returns the content as struct\n\n**USAGE:**\n*structure manifestRead(path)*\n\n**PARAMETERS:**\n\n*path (string)* - Path to\n a jar file containing a \"MANIFEST.MF\" file in the directory \"/META-INF/\"\n a Manifest file\n\nor the content of a Manifest File\n"
    },
    {
        "prefix": "max",
        "body": "max(${1:number1}, ${2:number2})",
        "documentation": " Determines the greater of two numbers.\n\n**USAGE:**\n*numeric max(number1, number2)*\n\n**PARAMETERS:**\n\n*number1 (numeric)*\n\n*number2 (numeric)*\n"
    },
    {
        "prefix": "metaphone",
        "body": "metaphone(${1:str})",
        "documentation": "Metaphone is a phonetic algorithm, an algorithm published in 1990 for indexing words by their English pronunciation. The algorithm produces variable length keys as its output, as opposed to Soundex's fixed-length keys. Similar sounding words share the same keys.\n\n**USAGE:**\n*string metaphone(str)*\n\n**PARAMETERS:**\n\n*str (string)*\n"
    },
    {
        "prefix": "mid",
        "body": "mid(${1:String}, ${2:start}, ${3:count})",
        "documentation": " Extracts a substring from a string.\n\n**USAGE:**\n*string mid(String, start, count)*\n\n**PARAMETERS:**\n\n*String (string)* - The string from which the substring will be extracted.\n\n*start (numeric)* - The position of the first character to retrieve.\n\n*count (numeric)* - The number of characters to retrieve.\n"
    },
    {
        "prefix": "millisecond",
        "body": "millisecond(${1:date})",
        "documentation": "\n\n**USAGE:**\n*numeric millisecond(date [, timezone])*\n\n**PARAMETERS:**\n\n*date (date)*\n\n*timezone (string)*\n"
    },
    {
        "prefix": "min",
        "body": "min(${1:number1}, ${2:number2})",
        "documentation": " Determines the lesser of two numbers.\n\n**USAGE:**\n*numeric min(number1, number2)*\n\n**PARAMETERS:**\n\n*number1 (numeric)*\n\n*number2 (numeric)*\n"
    },
    {
        "prefix": "minute",
        "body": "minute(${1:date})",
        "documentation": " Extracts the minute value from a date/time object.\n\n**USAGE:**\n*numeric minute(date)*\n\n**PARAMETERS:**\n\n*date (date)*\n"
    },
    {
        "prefix": "month",
        "body": "month(${1:date})",
        "documentation": " Extracts the month value from a date/time object.\n\n**USAGE:**\n*numeric month(date)*\n\n**PARAMETERS:**\n\n*date (date)*\n"
    },
    {
        "prefix": "monthAsString",
        "body": "monthAsString(${1:month_number})",
        "documentation": " \n\n**USAGE:**\n*string monthAsString(month_number)*\n\n**PARAMETERS:**\n\n*month_number (numeric)*\n"
    },
    {
        "prefix": "monthShortAsString",
        "body": "monthShortAsString(${1:monthnumber})",
        "documentation": "\n\n**USAGE:**\n*string monthShortAsString(monthnumber)*\n\n**PARAMETERS:**\n\n*monthnumber (numeric)*\n"
    },
    {
        "prefix": "newLine",
        "body": "newLine()",
        "documentation": "returns a new line\n\n**USAGE:**\n*string newLine()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "now",
        "body": "now()",
        "documentation": " Gets the current date and time of the computer running\n the CFML server.\n\n**USAGE:**\n*date now()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "nowServer",
        "body": "nowServer()",
        "documentation": "Returns the current time on the server independent of Lucee timezone definition.\n\n**USAGE:**\n*date nowServer()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "nullValue",
        "body": "nullValue()",
        "documentation": "returns null\n\n**USAGE:**\n*any nullValue()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "numberFormat",
        "body": "numberFormat(${1:number})",
        "documentation": " Creates a custom-formatted number value. For international\n number formatting use LSNumberFormat.\n The mask is made up of:\n _,9 Digit placeholder; . decimal point; 0 Pads with zeros;\n ( ) less than zero, puts parentheses around the mask\n + plus sign before positive number minus before negative\n - a space before positive minus sign before negative\n , Separates every third decimal place with a comma.\n L,C Left-justifies or center-justifies number\n $ dollar sign before formatted number.\n ^ Separates left and right formatting.\n\n**USAGE:**\n*string numberFormat(number [, mask])*\n\n**PARAMETERS:**\n\n*number (numeric)*\n\n*mask (string)*\n"
    },
    {
        "prefix": "objectEquals",
        "body": "objectEquals(${1:Param1}, ${2:Param2})",
        "documentation": " No Help Available\n\n**USAGE:**\n*boolean objectEquals(Param1, Param2)*\n\n**PARAMETERS:**\n\n*Param1 ()* - New instance of the CFC on the client.\n\n*Param2 ()* - Original instance of the CFC.\n"
    },
    {
        "prefix": "objectLoad",
        "body": "objectLoad(${1:binaryObject}, ${2:filepath})",
        "documentation": "Load object from binary obj\n\n**USAGE:**\n*any objectLoad(binaryObject, filepath)*\n\n**PARAMETERS:**\n\n*binaryObject (binary)* - A binary object returned by objectSave function\n\n*filepath (string)* - A file path to a serialized object\n"
    },
    {
        "prefix": "objectSave",
        "body": "objectSave(${1:object})",
        "documentation": " Serialize object to file or convert it to binary format\n\n**USAGE:**\n*binary objectSave(object [, file])*\n\n**PARAMETERS:**\n\n*object (variableName)* - Object to be serialized\n\n*file (string)* - File in which serialized object will be stored\n"
    },
    {
        "prefix": "onApplicationEnd",
        "body": "onApplicationEnd(${1:ApplicationScope})",
        "documentation": "Defined in Application.cfc, invoked when the application times out or when the server is shutting down.\n\n**USAGE:**\n*boolean onApplicationEnd(ApplicationScope)*\n\n**PARAMETERS:**\n\n*ApplicationScope (struct)* - The application scope of the application that is ending.\n"
    },
    {
        "prefix": "onApplicationStart",
        "body": "onApplicationStart()",
        "documentation": "Defined in Application.cfc, invoked once when the application is initialized.\n\n**USAGE:**\n*boolean onApplicationStart()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "onError",
        "body": "onError(${1:exception}, ${2|onApplicationStart,onApplicationEnd,onRequest,onRequestStart,onSessionStart,onSessionEnd,[empty string]|})",
        "documentation": "Defined in Application.cfc, invoked when an exception occurrs that was not caught by a cftry or cfcatch statement.\n\n**USAGE:**\n*void onError(exception, eventName)*\n\n**PARAMETERS:**\n\n*exception (struct)* - A structure containing the exception similar to what the cfcatch tag has.\n\n*eventName (string)* - The name of the application event at which the exception occurred. If no onRequest method is defined then an empty string may be passed. **Values:** *onApplicationStart, onApplicationEnd, onRequest, onRequestStart, onSessionStart, onSessionEnd, [empty string]*.\n"
    },
    {
        "prefix": "onMissingMethod",
        "body": "onMissingMethod(${1:missingMethodName}, ${2:missingMethodArguments})",
        "documentation": "This method is invoked in a CFC when a method call exists that is not defined by cffunction or with a function statement.\n\n**USAGE:**\n*void onMissingMethod(missingMethodName, missingMethodArguments)*\n\n**PARAMETERS:**\n\n*missingMethodName (string)* - The name of the missing method.\n\n*missingMethodArguments (struct)* - The arguments that were passed on the function call to the missing method.\n"
    },
    {
        "prefix": "onMissingTemplate",
        "body": "onMissingTemplate(${1:targetPage})",
        "documentation": "Defined in Application.cfc, invoked when a request is made for a cfml template that does not exist.\n\n**USAGE:**\n*boolean onMissingTemplate(targetPage)*\n\n**PARAMETERS:**\n\n*targetPage (string)* - Requested template path relative to the webroot\n"
    },
    {
        "prefix": "onRequest",
        "body": "onRequest(${1:targetPage})",
        "documentation": "Defined in Application.cfc, invoked when the request starts after onRequestStart.\n\n**USAGE:**\n*void onRequest(targetPage)*\n\n**PARAMETERS:**\n\n*targetPage (string)* - Requested template path relative to the webroot\n"
    },
    {
        "prefix": "onRequestEnd",
        "body": "onRequestEnd(${1:targetPage})",
        "documentation": "Defined in Application.cfc, invoked at the end of the request before the request is terminated. It can generate output.\n\n**USAGE:**\n*void onRequestEnd(targetPage)*\n\n**PARAMETERS:**\n\n*targetPage (string)* - Requested template path relative to the webroot\n"
    },
    {
        "prefix": "onRequestStart",
        "body": "onRequestStart(${1:targetPage})",
        "documentation": "Defined in Application.cfc, invoked when the request starts before onRequest.\n\n**USAGE:**\n*boolean onRequestStart(targetPage)*\n\n**PARAMETERS:**\n\n*targetPage (string)* - Requested template path relative to the webroot\n"
    },
    {
        "prefix": "onServerStart",
        "body": "onServerStart()",
        "documentation": "Called upon startup of the server. Typically defined in server.cfc and placed at the webroot. In the ColdFusion Administrator > Setting check 'Component with onServerStart() method' and specify the file. The function is useful for application-independent tasks, and specifying the server specific environment variables and other general tasks.\n\n**USAGE:**\n*void onServerStart()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "onSessionEnd",
        "body": "onSessionEnd(${1:sessionScope}, ${2:applicationScope})",
        "documentation": "Defined in Application.cfc, invoked when a session expires or times out.\n\n**USAGE:**\n*void onSessionEnd(sessionScope, applicationScope)*\n\n**PARAMETERS:**\n\n*sessionScope (struct)* - The session scope of the session that is ending.\n\n*applicationScope (struct)* - The application scope of the session that is ending.\n"
    },
    {
        "prefix": "onSessionStart",
        "body": "onSessionStart()",
        "documentation": "Defined in Application.cfc, invoked upon initialization of a session.\n\n**USAGE:**\n*void onSessionStart()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "ormClearSession",
        "body": "ormClearSession()",
        "documentation": "ORMClearSession removes all the entities that are loaded or created in the session. This clears the first level cache and removes the objects that are not yet saved to the database.\n\n**USAGE:**\n*void ormClearSession( [datasource])*\n\n**PARAMETERS:**\n\n*datasource (string)* - datasource used for the session, if nor defined the datasource defined in application.cfc/cfapplication is used.\n"
    },
    {
        "prefix": "ormCloseAllSessions",
        "body": "ormCloseAllSessions(${1:region})",
        "documentation": " Closes all Hibernate sessions in the request.\n\n**USAGE:**\n*void ormCloseAllSessions(region)*\n\n**PARAMETERS:**\n\n*region ()* - Name of the cache region.\n"
    },
    {
        "prefix": "ormCloseSession",
        "body": "ormCloseSession()",
        "documentation": "Closes the current ORM session for the given datasource. When the datasource argument is not passed then it uses the default datasource defined in Application.cfc.\n\n**USAGE:**\n*void ormCloseSession( [datasource])*\n\n**PARAMETERS:**\n\n*datasource (string)* - Name of the datasource for the ORM session\n"
    },
    {
        "prefix": "ormEvictCollection",
        "body": "ormEvictCollection(${1:componentName}, ${2:relationName})",
        "documentation": "This will remove all the entries with the specified relation/collection name in the specified component. \normEvictCollection(componentName,relationName,[id])\n\n**USAGE:**\n*void ormEvictCollection(componentName, relationName [, id])*\n\n**PARAMETERS:**\n\n*componentName (string)* - No Help Available\n\n*relationName (string)* - No Help Available\n\n*id (string)* - No Help Available\n"
    },
    {
        "prefix": "ormEvictEntity",
        "body": "ormEvictEntity(${1:componentName})",
        "documentation": " This will remove all the entries for the specified component name from the entity cache.\normEvictEntity(componentName,[id])\n\n**USAGE:**\n*void ormEvictEntity(componentName [, id])*\n\n**PARAMETERS:**\n\n*componentName (string)* - No Help Available\n\n*id (string)* - No Help Available\n"
    },
    {
        "prefix": "ormEvictQueries",
        "body": "ormEvictQueries()",
        "documentation": "This will remove all the queries from the named query cache. \nIf name is not specified, all queries from default cache will be removed.\normEvictQueries([cacheName])\n\n**USAGE:**\n*void ormEvictQueries( [cacheName])*\n\n**PARAMETERS:**\n\n*cacheName (string)* - No Help Available\n"
    },
    {
        "prefix": "ormExecuteQuery",
        "body": "ormExecuteQuery(${1:hql})",
        "documentation": "Runs the HQL on the default data source specified for the application.\n\n**USAGE:**\n*any ormExecuteQuery(hql [, params] [, unique] [, queryoptions])*\n\n**PARAMETERS:**\n\n*hql (string)* - A HQL query statement\n\n*params (any)* - A struct or array of query params.\n\n*unique (boolean)* - If true returns a single entity instead of an array.\n\n*queryoptions (string)* - A struct with possible keys: ignorecase, maxResults, cacheable, timeout, datasource\n"
    },
    {
        "prefix": "ormFlush",
        "body": "ormFlush()",
        "documentation": "Flushes the current ORM session. ORMFlush flushes all the pending CRUD operations in that request. Any changes made in the objects, in the current ORM session, are saved to the database.\n\n**USAGE:**\n*void ormFlush( [datasource])*\n\n**PARAMETERS:**\n\n*datasource (string)* - datasource used for the session, if nor defined the datasource defined in application.cfc/cfapplication is used.\n"
    },
    {
        "prefix": "ormFlushAll",
        "body": "ormFlushAll(${1:region})",
        "documentation": "Flushes all the current Hibernate sessions in the request.\n\n**USAGE:**\n*void ormFlushAll(region)*\n\n**PARAMETERS:**\n\n*region ()* - Name of the cache region.\n"
    },
    {
        "prefix": "ormGetSession",
        "body": "ormGetSession()",
        "documentation": "Get the current ORM session object\n\n**USAGE:**\n*any ormGetSession()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "ormGetSessionFactory",
        "body": "ormGetSessionFactory()",
        "documentation": " Returns ORM session factory instance\n\n**USAGE:**\n*any ormGetSessionFactory()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "ormIndex",
        "body": "ormIndex()",
        "documentation": " Performs offline indexing - using this function without specifying parameters, all persistent entities of a given application are indexed.\n\n**USAGE:**\n*void ormIndex()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "ormIndexPurge",
        "body": "ormIndexPurge(${1:region})",
        "documentation": "Clears all indexed data for all entities or specified entities in the current application scope.\n\n**USAGE:**\n*void ormIndexPurge(region)*\n\n**PARAMETERS:**\n\n*region ()* - Name of the cache region.\n"
    },
    {
        "prefix": "ormReload",
        "body": "ormReload()",
        "documentation": "Reinitializes ORM for the application.If you make any change to the persistent metadata of the CFCs, then you might want to reload the ORM.  Returns ORM session factory instance\n\n**USAGE:**\n*void ormReload()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "ormSearch",
        "body": "ormSearch(${1:query_text}, ${2:entityName}, ${3:fields}, ${4:optionMap})",
        "documentation": "Searches for given text in specific properties or entities.\n\n**USAGE:**\n*struct ormSearch(query_text, entityName, fields, optionMap)*\n\n**PARAMETERS:**\n\n*query_text ()* - The text to be searched for or a complete Lucene query.In the case of ORMSearch('query_text', 'entityName'), only Lucene query is supported.For details of Lucene query, see http://lucene.apache.org/core/old_versioned_docs/versions/3_0_0/queryparsersyntax.html\n\n*entityName ()* - Name of the entity to be searched.\n\n*fields ()* - Fields in which search has to be performed. This can be an array of strings.If you are performing a Lucene query, you need not specify this field. In other words, if you do not specify this value, a Lucene query is performed.Field name is case-sensitive.\n\n*optionMap ()* - Extra options that can be passed while executing Lucene query.The options are: Sort, Offset, maxResults\n"
    },
    {
        "prefix": "ormSearchOffline",
        "body": "ormSearchOffline(${1:query_text}, ${2:entityName}, ${3:fields_to_be_selected}, ${4:fields})",
        "documentation": " Performs search on the indexed properties but returns only the stored fields.For this function to work, specify indexStore=true on the properties on which you want to perform the search.\n\n**USAGE:**\n*struct ormSearchOffline(query_text, entityName, fields_to_be_selected, fields [, optionMap] [, extra options])*\n\n**PARAMETERS:**\n\n*query_text ()* - The text to be searched for or a complete Lucene query.For details of Lucene query, see http://lucene.apache.org/core/old_versioned_docs/versions/.\n\n*entityName ()* - Name of the entity to be searched.\n\n*fields_to_be_selected ()* - Fields to be returned as keys in the resultant struct.\n\n*fields ()* - Fields in which search has to be performed.\n\n*optionMap ()*\n\n*extra options ()* -  can be passed while executing Lucene query. The options can be: sort, offset, maxResults\n"
    },
    {
        "prefix": "pagePoolClear",
        "body": "pagePoolClear()",
        "documentation": "clear pages in pools\n\n**USAGE:**\n*boolean pagePoolClear()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "pagePoolList",
        "body": "pagePoolList()",
        "documentation": "list all pages in pools\n\n**USAGE:**\n*array pagePoolList()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "paragraphFormat",
        "body": "paragraphFormat(${1:String})",
        "documentation": " Replaces characters in a string:\n * Single newline characters (CR/LF sequences) with spaces\n * Double newline characters with HTML paragraph tags (<code>&lt;p&gt;</code>)\n\n**USAGE:**\n*string paragraphFormat(String)*\n\n**PARAMETERS:**\n\n*String (string)*\n"
    },
    {
        "prefix": "parameterExists",
        "body": "parameterExists(${1:region})",
        "documentation": "This function is deprecated. Use the IsDefined or StructKeyExists functions. Determines whether a parameter exists. ColdFusion does not evaluate the argument.\n\n**USAGE:**\n*boolean parameterExists(region)*\n\n**PARAMETERS:**\n\n*region ()* - Name of the cache region.\n"
    },
    {
        "prefix": "parseDateTime",
        "body": "parseDateTime(${1:dt_string})",
        "documentation": " Parses a date/time string according to the English (U.S.)\n locale conventions. (To format a date/time string for other\n locales, use the LSParseDateTime function.)\n\n**USAGE:**\n*date parseDateTime(dt_string [, pop_conversion])*\n\n**PARAMETERS:**\n\n*dt_string (string)*\n\n*pop_conversion (string)* - - standard: (the default) function does no conversion.\n - pop: specifies that the date/time string is in POP format,\n which includes the local time of the sender and a time-zone\n offset from UTC. ColdFusion applies the offset and returns\n a value with the UTC time.. **Default:** *standard*. **Values:** *standard, pop*.\n"
    },
    {
        "prefix": "parseNumber",
        "body": "parseNumber(${1:number})",
        "documentation": "Converts string to number in numeral system\n\n**USAGE:**\n*numeric parseNumber(number [, radix])*\n\n**PARAMETERS:**\n\n*number (string)*\n\n*radix (string)* **Values:** *bin, oct, dec, hex*.\n"
    },
    {
        "prefix": "pi",
        "body": "pi()",
        "documentation": "Gets the mathematical constant p, accurate to 15 digits\n, but only shows 11 when simply outputted.\n\n**USAGE:**\n*numeric pi()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "precisionEvaluate",
        "body": "precisionEvaluate(${1:expressions})",
        "documentation": " Evaluates one or more string expressions using BigDecimal precision arithmetic.  If the results ends in a infinitely repeating decimal value only the first 20 digits of the decimal portion will be used.  BigDecimal precision results only work with addition, subtraction, multiplication and division.  The use of ^, MOD, % or \\ arithmetic operators will result in normal integer precision.\n\n**USAGE:**\n*numeric precisionEvaluate(expressions)*\n\n**PARAMETERS:**\n\n*expressions (string)* - Expressions to evaluate\n"
    },
    {
        "prefix": "preserveSingleQuotes",
        "body": "preserveSingleQuotes(${1:variable})",
        "documentation": " Prevents CFML from automatically escaping single\n quotation mark characters that are contained in a variable.\n CFML does not evaluate the argument.\n\n Note: ColdFusion automatically escapes simple-variable,\n array-variable, and structure-variable references within a\n cfquery tag body or block.\n\n**USAGE:**\n*void preserveSingleQuotes(variable)*\n\n**PARAMETERS:**\n\n*variable (string)* - Variable that contains a string in which to preserve\n single quotation marks.\n"
    },
    {
        "prefix": "quarter",
        "body": "quarter(${1:date})",
        "documentation": " Calculates the quarter of the year in which a date falls.\n\n**USAGE:**\n*numeric quarter(date)*\n\n**PARAMETERS:**\n\n*date (date)*\n"
    },
    {
        "prefix": "query",
        "body": "query()",
        "documentation": "\n\n**USAGE:**\n*query query()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "queryAddColumn",
        "body": "queryAddColumn(${1:query}, ${2:column_name}, ${3:array_name})",
        "documentation": " Adds a column to a query and populates its rows with the\n contents of a one-dimensional array. Pads query columns,\n if necessary, to ensure that all columns have the same number\n of rows.\n\n**USAGE:**\n*numeric queryAddColumn(query, column_name [, datatype], array_name)*\n\n**PARAMETERS:**\n\n*query (query)*\n\n*column_name (string)*\n\n*datatype (string)* - Column data type. **Values:** *Integer, Bigint, Double, Decimal, Varchar, Binary, Bit, Time, Date*.\n\n*array_name (array)*\n"
    },
    {
        "prefix": "queryAddRow",
        "body": "queryAddRow(${1:query})",
        "documentation": " Adds a specified number of empty rows to a query.\n\n**USAGE:**\n*numeric queryAddRow(query [, number/row(s)])*\n\n**PARAMETERS:**\n\n*query (query)*\n\n*number/row(s) (Numeric / Array / Struct)* - As of CF10+ you can pass a Structure whose keys map to the query column names to insert a row of data; or an Array of those Structures to insert multiple rows at once.\n"
    },
    {
        "prefix": "queryColumnArray",
        "body": "queryColumnArray(${1:query})",
        "documentation": "return the column names as array, in the orders of the column in the database\n\n**USAGE:**\n*array queryColumnArray(query)*\n\n**PARAMETERS:**\n\n*query (query)*\n"
    },
    {
        "prefix": "queryColumnCount",
        "body": "queryColumnCount(${1:query})",
        "documentation": "\n\n**USAGE:**\n*numeric queryColumnCount(query)*\n\n**PARAMETERS:**\n\n*query (query)*\n"
    },
    {
        "prefix": "queryColumnData",
        "body": "queryColumnData(${1:query}, ${2:columnName})",
        "documentation": "Returns the data in a query column. See also valueArray for use in ACF.\n\n**USAGE:**\n*array queryColumnData(query, columnName [, closure])*\n\n**PARAMETERS:**\n\n*query (query)*\n\n*columnName (string)*\n\n*closure (function)*\n"
    },
    {
        "prefix": "queryColumnExists",
        "body": "queryColumnExists(${1:query}, ${2:column})",
        "documentation": "\n\n**USAGE:**\n*boolean queryColumnExists(query, column)*\n\n**PARAMETERS:**\n\n*query (query)*\n\n*column (string)*\n"
    },
    {
        "prefix": "queryColumnList",
        "body": "queryColumnList(${1:query})",
        "documentation": "Returns the column names of a query as a list.\n\n**USAGE:**\n*string queryColumnList(query [, delimiter])*\n\n**PARAMETERS:**\n\n*query (query)*\n\n*delimiter (string)*. **Default:** *,*.\n"
    },
    {
        "prefix": "queryConvertForGrid",
        "body": "queryConvertForGrid(${1:query}, ${2:page}, ${3:pageSize})",
        "documentation": " Converts query data to a structure that contains a paged subset of the query.\n\n**USAGE:**\n*struct queryConvertForGrid(query, page, pageSize)*\n\n**PARAMETERS:**\n\n*query (string)* - No Help Available\n\n*page (numeric)* - No Help Available\n\n*pageSize (numeric)* - No Help Available\n"
    },
    {
        "prefix": "queryCurrentRow",
        "body": "queryCurrentRow(${1:query})",
        "documentation": "\n\n**USAGE:**\n*numeric queryCurrentRow(query)*\n\n**PARAMETERS:**\n\n*query (query)*\n"
    },
    {
        "prefix": "queryDeleteColumn",
        "body": "queryDeleteColumn(${1:query}, ${2:column})",
        "documentation": "\n\n**USAGE:**\n*array queryDeleteColumn(query, column)*\n\n**PARAMETERS:**\n\n*query (query)*\n\n*column (string)*\n"
    },
    {
        "prefix": "queryDeleteRow",
        "body": "queryDeleteRow(${1:query})",
        "documentation": "\n\n**USAGE:**\n*boolean queryDeleteRow(query [, row])*\n\n**PARAMETERS:**\n\n*query (query)*\n\n*row (numeric)*. **Default:** *-9999*.\n"
    },
    {
        "prefix": "queryEach",
        "body": "queryEach(${1:query}, ${2:closure})",
        "documentation": "\n\n**USAGE:**\n*void queryEach(query, closure [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*query (query)*\n\n*closure (function)*\n\n*parallel (boolean)* - Lucee-only\n\n*maxThreads (numeric)* - Lucee-only. **Default:** *20*.\n"
    },
    {
        "prefix": "queryEvery",
        "body": "queryEvery(${1:query}, ${2:closure})",
        "documentation": "\n\n**USAGE:**\n*boolean queryEvery(query, closure [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*query (query)*\n\n*closure (function)*\n\n*parallel (boolean)*\n\n*maxThreads (numeric)*. **Default:** *20*.\n"
    },
    {
        "prefix": "queryExecute",
        "body": "queryExecute(${1:sql}, ${2|cfsqltype,list|}, ${3|datasource,cachename,dbtype|})",
        "documentation": "Executes a SQL query, returns the result.\n\n**USAGE:**\n*query queryExecute(sql, params, options)*\n\n**PARAMETERS:**\n\n*sql (string)* - SQL string to execute.\n\n*params (any)* - Array or Struct of parameter values. When passing an array use ? as place holders. When passing a struct use :keyName where keyName is the name of the key in the structure corresponding to the parameter. The struct or array can be a struct with keys such as the following. **Values:** *cfsqltype, list*.\n\n*options (struct)* - Struct containing query options, all cfquery tag attributes are supported except the name attribute. **Values:** *datasource, cachename, dbtype*.\n"
    },
    {
        "prefix": "queryFilter",
        "body": "queryFilter(${1:query}, ${2:filter})",
        "documentation": "Filters query rows specified in filter criteria\n\n**USAGE:**\n*query queryFilter(query, filter [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*query (query)*\n\n*filter (function)*\n\n*parallel (boolean)* - Lucee-only\n\n*maxThreads (numeric)* - Lucee-only. **Default:** *20*.\n"
    },
    {
        "prefix": "queryGetCell",
        "body": "queryGetCell(${1:query}, ${2:column_name})",
        "documentation": "\n\n**USAGE:**\n*any queryGetCell(query, column_name [, row_number])*\n\n**PARAMETERS:**\n\n*query (query)*\n\n*column_name (string)*\n\n*row_number (numeric)*. **Default:** *-9999*.\n"
    },
    {
        "prefix": "queryGetResult",
        "body": "queryGetResult(${1:query})",
        "documentation": " Returns the metadata of a query.\n\n**USAGE:**\n*struct queryGetResult(query)*\n\n**PARAMETERS:**\n\n*query (query)* - The query whose metadata is to be returned.\n"
    },
    {
        "prefix": "queryGetRow",
        "body": "queryGetRow(${1:query}, ${2:rowNumber})",
        "documentation": "Returns a struct having all the columns as keys and their corresponding values.\n\n**USAGE:**\n*struct queryGetRow(query, rowNumber)*\n\n**PARAMETERS:**\n\n*query ()* - query object do get data from.\n\n*rowNumber ()* - position of the row to be returned.\n"
    },
    {
        "prefix": "queryKeyExists",
        "body": "queryKeyExists(${1:query}, ${2:key})",
        "documentation": "Determines whether the specified column (key) is present in a query.\n\n**USAGE:**\n*boolean queryKeyExists(query, key)*\n\n**PARAMETERS:**\n\n*query (query)* - Query Object to test.\n\n*key (string)* - Key to test\n"
    },
    {
        "prefix": "queryMap",
        "body": "queryMap(${1:query}, ${2:closure})",
        "documentation": "Maps each query row using a function to manipulate the rows fields\n\n**USAGE:**\n*query queryMap(query, closure [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*query (query)*\n\n*closure (function)*\n\n*parallel (boolean)*\n\n*maxThreads (numeric)*. **Default:** *20*.\n"
    },
    {
        "prefix": "queryNew",
        "body": "queryNew(${1:columnList})",
        "documentation": "Creates a new query object. The query can be populated with data using functions queryAddRow, querySetCell, or by passing it in to the rowData argument.\n\n**USAGE:**\n*query queryNew(columnList [, columnTypeList] [, rowData])*\n\n**PARAMETERS:**\n\n*columnList (string)* - A string or a variable that contains one. Delimited list\n of column names, or an empty string.\n\n*columnTypeList (string)* - CF7+ Comma-delimited list specifying column data types. **Values:** *Integer, BigInt, Double, Decimal, VarChar, Binary, Bit, Time, Data*.\n\n*rowData (any)* - CF10+ Data to populate the query. Can be a struct (with keys matching column names), an array of structs, or an array of arrays (in same order as columnList)\n"
    },
    {
        "prefix": "queryRecordCount",
        "body": "queryRecordCount(${1:query})",
        "documentation": "\n\n**USAGE:**\n*numeric queryRecordCount(query)*\n\n**PARAMETERS:**\n\n*query (query)*\n"
    },
    {
        "prefix": "queryReduce",
        "body": "queryReduce(${1:query}, ${2:closure})",
        "documentation": "Reduces query columns just like in array or collection\n\n**USAGE:**\n*any queryReduce(query, closure [, initialValue])*\n\n**PARAMETERS:**\n\n*query (query)*\n\n*closure (function)*\n\n*initialValue (any)*\n"
    },
    {
        "prefix": "queryRowData",
        "body": "queryRowData(${1:query}, ${2:rowNumber})",
        "documentation": "\n\n**USAGE:**\n*struct queryRowData(query, rowNumber)*\n\n**PARAMETERS:**\n\n*query (query)*\n\n*rowNumber (numeric)*\n"
    },
    {
        "prefix": "querySetCell",
        "body": "querySetCell(${1:query}, ${2:column}, ${3:value})",
        "documentation": " Sets a cell to a value. If no row number is specified,\n the cell on the last row is set.\n\n**USAGE:**\n*boolean querySetCell(query, column, value [, row])*\n\n**PARAMETERS:**\n\n*query (query)*\n\n*column (string)*\n\n*value (any)*\n\n*row (numeric)*\n"
    },
    {
        "prefix": "querySlice",
        "body": "querySlice(${1:query}, ${2:offset})",
        "documentation": "Returns a query containing a subset of another query\n\n**USAGE:**\n*query querySlice(query, offset [, length])*\n\n**PARAMETERS:**\n\n*query (query)*\n\n*offset (numeric)* - The first row to include in the new query\n\n*length (numeric)* - The number of rows to include in the new query, defaults to all remaining rows\n"
    },
    {
        "prefix": "querySome",
        "body": "querySome(${1:query}, ${2:closure})",
        "documentation": "This function calls a given closure/function with every element in a given query and returns true, if one of the closure calls returns true\n\n**USAGE:**\n*boolean querySome(query, closure [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*query (query)*\n\n*closure (function)*\n\n*parallel (boolean)*\n\n*maxThreads (numeric)*. **Default:** *20*.\n"
    },
    {
        "prefix": "querySort",
        "body": "querySort(${1:query}, ${2:sortFunction})",
        "documentation": "Sorts a query.\n\n**USAGE:**\n*boolean querySort(query, sortFunction [, direction])*\n\n**PARAMETERS:**\n\n*query (query)* - The query you want to sort\n\n*sortFunction (function)* - CF2016+ or Lucee5.1.0.13+ a function with two arguments each corresponding to a query row. The function returns -1 if first row is less than second, 0 if equal, or 1 if first row is greater than second. Lucee4.5+ accepts a column name to sort by instead of a function.\n\n*direction (string)* - Lucee4.5+ Only supported on Lucee when second argument is a column name instead of a callback function.\n"
    },
    {
        "prefix": "quotedValueList",
        "body": "quotedValueList(${1:column})",
        "documentation": " Gets the values of each record returned from an executed query.\n CFML does not evaluate the arguments\n\n**USAGE:**\n*string quotedValueList(column [, delimiter])*\n\n**PARAMETERS:**\n\n*column (QueryColumn)*\n\n*delimiter (string)*. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n"
    },
    {
        "prefix": "rand",
        "body": "rand()",
        "documentation": " Generates a pseudo-random number in the range 0 - 1.\n\n**USAGE:**\n*numeric rand( [algorithm])*\n\n**PARAMETERS:**\n\n*algorithm (string)* - The algorithm to use to generated the random number.. **Default:** *CFMX_COMPAT*. **Values:** *CFMX_COMPAT, SHA1PRNG, IBMSecureRandom*.\n"
    },
    {
        "prefix": "randomize",
        "body": "randomize(${1:number})",
        "documentation": " Seeds the pseudo-random number generator with an\n integer number, ensuring repeatable number patterns.\n\n**USAGE:**\n*numeric randomize(number [, algorithm])*\n\n**PARAMETERS:**\n\n*number (numeric)*\n\n*algorithm (string)* - The algorithm to use to generated the random number.. **Default:** *CFMX_COMPAT*. **Values:** *CFMX_COMPAT, SHA1PRNG, IBMSecureRandom*.\n"
    },
    {
        "prefix": "randRange",
        "body": "randRange(${1:number1}, ${2:number2})",
        "documentation": "Generates a random integer between two specified numbers.\n Requests for random integers that are greater than 100,000,000\n result in non-random numbers, to prevent overflow during\n internal computations.\n\n**USAGE:**\n*numeric randRange(number1, number2 [, algorithm])*\n\n**PARAMETERS:**\n\n*number1 (numeric)*\n\n*number2 (numeric)*\n\n*algorithm (string)* - CF7+ The algorithm to use to generated the random number.. **Default:** *CFMX_COMPAT*. **Values:** *CFMX_COMPAT, SHA1PRNG, IBMSecureRandom, NativePRNG, NativePRNGBlocking, NativePRNGNonBlocking*.\n"
    },
    {
        "prefix": "reEscape",
        "body": "reEscape(${1:string})",
        "documentation": "Escapes regular expression control characters within a string.\n\n**USAGE:**\n*string reEscape(string)*\n\n**PARAMETERS:**\n\n*string ()* - The string you that to escape.\n"
    },
    {
        "prefix": "reFind",
        "body": "reFind(${1:reg_expression}, ${2:String})",
        "documentation": "Uses a regular expression (RE) to search a string for a pattern, starting from a specified position. The search is case sensitive.\n\n**USAGE:**\n*any reFind(reg_expression, String [, start] [, returnsubexpressions] [, scope])*\n\n**PARAMETERS:**\n\n*reg_expression (Regex)*\n\n*String (string)* - A string or a variable that contains one. String in which\n to search.\n\n*start (numeric)*. **Default:** *1*.\n\n*returnsubexpressions (boolean)* - True: if the regular expression is found, the first array\n element contains the length and position, respectively,\n of the first match.\n If the regular expression contains parentheses that\n group subexpressions, each subsequent array element\n contains the length and position, respectively, of\n the first occurrence of each group.\n If the regular expression is not found, the arrays each\n contain one element with the value 0.\n False: the function returns the position in the string\n where the match begins. Default. **Values:** *true, false*.\n\n*scope (string)* - CF2016+ * one: returns the first value that matches the regex.\n * all: returns all values that match the regex.. **Default:** *one*. **Values:** *one, all*.\n"
    },
    {
        "prefix": "reFindNoCase",
        "body": "reFindNoCase(${1:reg_expression}, ${2:string})",
        "documentation": "Uses a regular expression (RE) to search a string for a pattern, starting from a specified position. The search is case-insensitive.\n\n**USAGE:**\n*any reFindNoCase(reg_expression, string [, start] [, returnsubexpressions] [, scope])*\n\n**PARAMETERS:**\n\n*reg_expression (Regex)*\n\n*string (string)* - A string or a variable that contains one. String in which\n to search.\n\n*start (numeric)*. **Default:** *1*.\n\n*returnsubexpressions (boolean)* - True: if the regular expression is found, the first array\n element contains the length and position, respectively,\n of the first match.\n If the regular expression contains parentheses that\n group subexpressions, each subsequent array element\n contains the length and position, respectively, of\n the first occurrence of each group.\n If the regular expression is not found, the arrays each\n contain one element with the value 0.\n False: the function returns the position in the string\n where the match begins. Default. **Values:** *true, false*.\n\n*scope (string)* - CF2016+ * one: returns the first value that matches the regex.\n * all: returns all values that match the regex.. **Default:** *one*. **Values:** *one, all*.\n"
    },
    {
        "prefix": "releaseCOMObject",
        "body": "releaseCOMObject(${1:objectName})",
        "documentation": " Releases a COM Object and frees up resources that it used.\n\n**USAGE:**\n*void releaseCOMObject(objectName)*\n\n**PARAMETERS:**\n\n*objectName (any)*\n"
    },
    {
        "prefix": "reMatch",
        "body": "reMatch(${1:reg_expression}, ${2:string})",
        "documentation": "Uses a regular expression (RE) to search a string for a pattern, starting from a specified position.\n\n**USAGE:**\n*array reMatch(reg_expression, string)*\n\n**PARAMETERS:**\n\n*reg_expression (string)* - Regular expression for which to search. Case sensitive.\n\n*string (string)* - A string or a variable that contains one. String in which to search.\n"
    },
    {
        "prefix": "reMatchNoCase",
        "body": "reMatchNoCase(${1:reg_expression}, ${2:string})",
        "documentation": "Uses a regular expression (RE) to search a string for a pattern, starting from a specified position.\n\n**USAGE:**\n*array reMatchNoCase(reg_expression, string)*\n\n**PARAMETERS:**\n\n*reg_expression (string)* - Regular expression for which to search. Case insensitive.\n\n*string (string)* - A string or a variable that contains one. String in which to search.\n"
    },
    {
        "prefix": "removeCachedQuery",
        "body": "removeCachedQuery(${1:SQL}, ${2:datasource})",
        "documentation": " Removes the query with the details you provide from query cache.\n\n**USAGE:**\n*void removeCachedQuery(SQL, datasource [, params] [, region])*\n\n**PARAMETERS:**\n\n*SQL ()* - The Query SQL.\n\n*datasource ()* - The datasource you ran the query on..\n\n*params ()* -  Array of parameter values passed to SQL.\n\n*region ()* - Specifies the cache region where you can place the cache object.\n"
    },
    {
        "prefix": "removeChars",
        "body": "removeChars(${1:String}, ${2:start}, ${3:count})",
        "documentation": " Removes characters from a string.\n\n**USAGE:**\n*string removeChars(String, start, count)*\n\n**PARAMETERS:**\n\n*String (string)* - The string or variable containing a string to process.\n\n*start (numeric)* - The starting position in the string to process.\n\n*count (numeric)* - Number of characters to remove.\n"
    },
    {
        "prefix": "render",
        "body": "render(${1||})",
        "documentation": "Executes CFML/Lucee code that you provide as a string.\n\n**USAGE:**\n*void render(CFML [, dialect])*\n\n**PARAMETERS:**\n\n*CFML (string)* - String to evaluate including some CFML/Lucee code **Values:** **.\n\n*dialect (string)* - The dialect you want details for. **Default:** *current template's dialect*. **Values:** *CFML, Lucee*.\n"
    },
    {
        "prefix": "repeatString",
        "body": "repeatString(${1:String}, ${2:count})",
        "documentation": " Creates a string that contains a specified number of\n repetitions of the specified string.\n\n**USAGE:**\n*string repeatString(String, count)*\n\n**PARAMETERS:**\n\n*String (string)*\n\n*count (numeric)*\n"
    },
    {
        "prefix": "replace",
        "body": "replace(${1:String}, ${2:substring1}, ${3:substring2})",
        "documentation": "Replaces occurrences of substring1 in a string with substring2,\n in a specified scope. The search is case-sensitive. Function returns original string with replacements made.\n\n**USAGE:**\n*string replace(String, substring1, substring2 [, scope])*\n\n**PARAMETERS:**\n\n*String (string)* - String to search\n\n*substring1 (string)* - Substring to find within string\n\n*substring2 (string)* - Substring to replace substring1 with. As of CF2016+ you can also pass a callback function in this argument `function(pattern, position, originalString)`.\n\n*scope (string)* - * one: replace the first occurrence\n * all: replace all occurrences. **Default:** *one*. **Values:** *one, all*.\n"
    },
    {
        "prefix": "replaceList",
        "body": "replaceList(${1:String}, ${2:list1}, ${3:list2})",
        "documentation": "Replaces occurrences of the elements from a delimited list\n in a string with corresponding elements from another delimited\n list. The search is case-sensitive.\n\n**USAGE:**\n*string replaceList(String, list1, list2 [, delimiter] [, delimiterList1] [, delimiterList2] [, includeEmptyFields])*\n\n**PARAMETERS:**\n\n*String (string)* - A string, or a variable that contains one, within which to replace substring\n\n*list1 (string)* - List of substrings for which to search\n\n*list2 (string)* - List of replacement substrings\n\n*delimiter (string)* - Common delimiter for both search and replacement.. **Default:** *,*.\n\n*delimiterList1 (string)* - Delimiter for search.. **Default:** *,*.\n\n*delimiterList2 (string)* - Delimiter for replacement.. **Default:** *,*.\n\n*includeEmptyFields (boolean)* - When true, zero-length list elements are preserved.. **Default:** *false*.\n"
    },
    {
        "prefix": "replaceListNoCase",
        "body": "replaceListNoCase(${1:String}, ${2:list1}, ${3:list2})",
        "documentation": "Replaces occurrences of the elements from a delimited list\n in a string with corresponding elements from another delimited\n list. The search is case-insensitive.\n\n**USAGE:**\n*string replaceListNoCase(String, list1, list2 [, delimiter] [, delimiterList1] [, delimiterList2] [, includeEmptyFields])*\n\n**PARAMETERS:**\n\n*String (string)* - A string, or a variable that contains one, within which to replace substring\n\n*list1 (string)* - List of substrings for which to search\n\n*list2 (string)* - List of replacement substrings\n\n*delimiter (string)* - Common delimiter for both search and replacement.. **Default:** *,*.\n\n*delimiterList1 (string)* - Delimiter for search.. **Default:** *,*.\n\n*delimiterList2 (string)* - Delimiter for replacement.. **Default:** *,*.\n\n*includeEmptyFields (boolean)* - When true, zero-length list elements are preserved.. **Default:** *false*.\n"
    },
    {
        "prefix": "replaceNoCase",
        "body": "replaceNoCase(${1:String}, ${2:substring1}, ${3:substring2})",
        "documentation": " Replaces occurrences of substring1 with substring2, in the\n specified scope. The search is case-insensitive.\n\n**USAGE:**\n*string replaceNoCase(String, substring1, substring2 [, scope])*\n\n**PARAMETERS:**\n\n*String (string)* - A string (or variable that contains one) within which to\n replace substring\n\n*substring1 (string)*\n\n*substring2 (string)*\n\n*scope (string)* - * one: Replace the first occurrence (default)\n * all: Replace all occurrences **Values:** *one, all*.\n"
    },
    {
        "prefix": "reReplace",
        "body": "reReplace(${1:string}, ${2:regex}, ${3:substring})",
        "documentation": "Uses a regular expression (regex) to search a string for a string pattern and replace it with another. The search is case-sensitive.\n\n**USAGE:**\n*string reReplace(string, regex, substring [, scope])*\n\n**PARAMETERS:**\n\n*string (string)* - A string or a variable that contains one\n\n*regex (Regex)* - Regular expression to replace.\n\n*substring (string)* - A string or a variable that contains one. Replaces substring with the regex match\n\n*scope (string)* - * one: Replace the first occurrence of the regular\n expression. Default.\n * all: Replace all occurrences of the regular expression.. **Default:** *one*. **Values:** *one, all*.\n"
    },
    {
        "prefix": "reReplaceNoCase",
        "body": "reReplaceNoCase(${1:String}, ${2:reg_expression}, ${3:substring})",
        "documentation": "Uses a regular expression to search a string for a string\n pattern and replace it with another. The search is\n case-insensitive.\n\n**USAGE:**\n*string reReplaceNoCase(String, reg_expression, substring [, scope])*\n\n**PARAMETERS:**\n\n*String (string)* - A string or a variable that contains one\n\n*reg_expression (Regex)* - Regular expression to replace.\n\n*substring (string)* - A string or a variable that contains one. Replaces\n reg_expression\n\n*scope (string)* - * one: Replace the first occurrence of the regular\n expression. Default.\n * all: Replace all occurrences of the regular expression. **Values:** *one, all*.\n"
    },
    {
        "prefix": "restDeleteApplication",
        "body": "restDeleteApplication(${1:dirPath})",
        "documentation": " Unregisters the directory path if it is already registered.\n\n**USAGE:**\n*void restDeleteApplication(dirPath)*\n\n**PARAMETERS:**\n\n*dirPath ()* - Path to the directory to be unregistered. If the path is not valid, it results in an error.\n"
    },
    {
        "prefix": "restInitApplication",
        "body": "restInitApplication(${1:dirPath}, ${2:serviceMapping}, ${3:password})",
        "documentation": "Scans all the CFCs in dirPath, and places those that are REST enabled at the serviceMapping URL. Requires the web admin password under Lucee.\n\n**USAGE:**\n*void restInitApplication(dirPath, serviceMapping [, default], password)*\n\n**PARAMETERS:**\n\n*dirPath (string)* - The path to a folder of CFCs to scan. Should be a full file system path\n\n*serviceMapping (string)* - The root of the exposed API, minus the server-wide prefix. E.g. to expose at '/rest/api/' you should set this to 'api'.\n\n*default (string)* - If the mapping is a default mapping set this to true (Lucee only)\n\n*password (string)* - The password for the web admin (Lucee only)\n"
    },
    {
        "prefix": "restSetResponse",
        "body": "restSetResponse(${1:response})",
        "documentation": " Sets the custom responses.\n\n**USAGE:**\n*void restSetResponse(response)*\n\n**PARAMETERS:**\n\n*response ()* - A struct that contains the response details.\n"
    },
    {
        "prefix": "reverse",
        "body": "reverse(${1:String})",
        "documentation": " Reverses the order of items, such as the characters in a\n string and the digits in a number\n\n**USAGE:**\n*string reverse(String)*\n\n**PARAMETERS:**\n\n*String (string)* - A string or a variable that contains one\n"
    },
    {
        "prefix": "right",
        "body": "right(${1:String}, ${2:count})",
        "documentation": " Gets a specified number of characters from a string,\n beginning at the right.\n\n**USAGE:**\n*string right(String, count)*\n\n**PARAMETERS:**\n\n*String (string)*\n\n*count (numeric)* - A positive integer or a variable that contains one.\n Number of characters to return.\n"
    },
    {
        "prefix": "rJustify",
        "body": "rJustify(${1:String}, ${2:length})",
        "documentation": " Right justifies characters of a string.\n\n**USAGE:**\n*string rJustify(String, length)*\n\n**PARAMETERS:**\n\n*String (string)*\n\n*length (numeric)*\n"
    },
    {
        "prefix": "round",
        "body": "round(${1:number})",
        "documentation": " Rounds a number to the closest integer.\n\n**USAGE:**\n*numeric round(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "rTrim",
        "body": "rTrim(${1:String})",
        "documentation": " Removes spaces from the end of a string.\n\n**USAGE:**\n*string rTrim(String)*\n\n**PARAMETERS:**\n\n*String (string)* - A string or a variable that contains one\n"
    },
    {
        "prefix": "second",
        "body": "second(${1:date})",
        "documentation": " Extracts the ordinal for the second from a date/time object.\n\n**USAGE:**\n*numeric second(date)*\n\n**PARAMETERS:**\n\n*date (date)* - A date/time object\n"
    },
    {
        "prefix": "sendGatewayMessage",
        "body": "sendGatewayMessage(${1:gatewayID}, ${2:data})",
        "documentation": " Sends an outgoing message through a ColdFusion MX event gateway.\n\n**USAGE:**\n*string sendGatewayMessage(gatewayID, data)*\n\n**PARAMETERS:**\n\n*gatewayID (string)* - Identifier of the gateway to send the message.\n\n*data (struct)* - A ColdFusion structure.\n"
    },
    {
        "prefix": "serialize",
        "body": "serialize(${1:objToBeSerialized}, ${2:type}, ${3:useCustomSerializer})",
        "documentation": "Serializes the object to a specified type\n\n**USAGE:**\n*string serialize(objToBeSerialized, type, useCustomSerializer)*\n\n**PARAMETERS:**\n\n*objToBeSerialized ()* - An object to be serialized.\n\n*type ()* - A type to which the object will be serialized. ColdFusion, by default supports XML and JSON formats. You can also implement support for other types in the CustomSerializer CFC.\n\n*useCustomSerializer ()* - Boolean. Whether to use the custom serializer or not. The default value is true. The custom serializer will be always used for XML deserialization. If false, the XML/JSON deserialization will be done using the default ColdFusion behavior. If any other type is passed with useCustomSerializer as false, then TypeNotSupportedException will be thrown.\n"
    },
    {
        "prefix": "serializeJSON",
        "body": "serializeJSON(${1:var})",
        "documentation": "Converts a ColdFusion variable into a JSON (JavaScript Object Notation) string.\n\n**USAGE:**\n*string serializeJSON(var [, serializeQueryByColumns] [, useCustomSerializer])*\n\n**PARAMETERS:**\n\n*var (variableName)* - A ColdFusion variable.\n\n*serializeQueryByColumns (boolean)* - A Boolean value that specifies how to serialize ColdFusion queries.. **Default:** *false*.\n\n*useCustomSerializer (boolean)* - CF11+ Use custom serializer if defined. See: https://helpx.adobe.com/coldfusion/developing-applications/changes-in-coldfusion/restful-web-services-in-coldfusion.html. **Default:** *true*.\n"
    },
    {
        "prefix": "serializeXML",
        "body": "serializeXML(${1:objToBeSerialized}, ${2:useCustomSerializer})",
        "documentation": "Serializes a ColdFusion object to XML.\n\n**USAGE:**\n*string serializeXML(objToBeSerialized, useCustomSerializer)*\n\n**PARAMETERS:**\n\n*objToBeSerialized ()* - An object to be serialized.\n\n*useCustomSerializer ()* - Boolean. Whether to use the custom serializer or not. The default value is true. The custom serializer will be always used for XML deserialization. If false, the XML/JSON deserialization will be done using the default ColdFusion behavior. If any other type is passed with useCustomSerializer as false, then TypeNotSupportedException will be thrown..\n"
    },
    {
        "prefix": "sessionGetMetadata",
        "body": "sessionGetMetadata(${1:region})",
        "documentation": " Returns meta data related to the current session.\n\n**USAGE:**\n*struct sessionGetMetadata(region)*\n\n**PARAMETERS:**\n\n*region ()* - Name of the cache region.\n"
    },
    {
        "prefix": "sessionInvalidate",
        "body": "sessionInvalidate()",
        "documentation": "Clears session scope and makes the current session identifiers no longer valid. This function does not invalidate J2EE sessions, only CF sessions (CFID/CFToken)\n\n**USAGE:**\n*void sessionInvalidate()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "sessionRotate",
        "body": "sessionRotate()",
        "documentation": "Creates a new session (using new session ids) and copies session scope into this new session, then invalidates the old session. Used after a valid login to prevent session fixation.\n\n**USAGE:**\n*void sessionRotate()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "sessionstartTime",
        "body": "sessionstartTime()",
        "documentation": "Provides information about the time when the current users session scope was created\n\n**USAGE:**\n*date sessionstartTime()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "setEncoding",
        "body": "setEncoding(${1:scope_name}, ${2|utf-8,iso-8859-1,windows-1252,us-ascii,shift_jis,iso-2022-jp,euc-jp,euc-kr,big5,euc-cn,utf-16|})",
        "documentation": " Sets the character encoding (character set) of Form and URL\n scope variable values; used when the character encoding of\n the input to a form, or the character encoding of a URL, is\n not in UTF-8 encoding.\n\n**USAGE:**\n*void setEncoding(scope_name, charset)*\n\n**PARAMETERS:**\n\n*scope_name (string)*\n\n*charset (string)* - The character encoding in which text in the scope\n variables is encoded. **Values:** *utf-8, iso-8859-1, windows-1252, us-ascii, shift_jis, iso-2022-jp, euc-jp, euc-kr, big5, euc-cn, utf-16*.\n"
    },
    {
        "prefix": "setLocale",
        "body": "setLocale(${1|Chinese (China),Chinese (Hong Kong),Chinese (Taiwan),Dutch (Belgian),Dutch (Standard),English (Australian),English (Canadian),English (New Zealand),English (US),English (UK),French (Belgian),French (Canadian),French (Standard),French (Swiss),German (Austrian),German (Standard),German (Swiss),Italian (Standard),Italian (Swiss),Japanese,Korean,Norwegian (Bokmal),Norwegian (Nynorsk),Portuguese (Brazilian),Portuguese (Standard),Spanish (Modern),Spanish (Standard),Swedish|})",
        "documentation": " Sets the country/language locale for CFML processing\n and the page returned to the client. The locale value\n determines the default format of date, time, number, and\n currency values, according to language and regional\n conventions.\n\n**USAGE:**\n*string setLocale(new_locale)*\n\n**PARAMETERS:**\n\n*new_locale (string)* - The name of a locale; for example, \"English (US)\" **Values:** *Chinese (China), Chinese (Hong Kong), Chinese (Taiwan), Dutch (Belgian), Dutch (Standard), English (Australian), English (Canadian), English (New Zealand), English (US), English (UK), French (Belgian), French (Canadian), French (Standard), French (Swiss), German (Austrian), German (Standard), German (Swiss), Italian (Standard), Italian (Swiss), Japanese, Korean, Norwegian (Bokmal), Norwegian (Nynorsk), Portuguese (Brazilian), Portuguese (Standard), Spanish (Modern), Spanish (Standard), Swedish*.\n"
    },
    {
        "prefix": "setProfileString",
        "body": "setProfileString(${1:inipath}, ${2:section}, ${3:entry}, ${4:value})",
        "documentation": "Sets the value of a profile entry in an initialization file.\n\n**USAGE:**\n*string setProfileString(inipath, section, entry, value)*\n\n**PARAMETERS:**\n\n*inipath (string)* - Absolute path of initialization file\n\n*section (string)* - Section of the initialization file in which the entry is\n to be set\n\n*entry (string)* - Name of the entry to set\n\n*value (string)* - Value to which to set the entry\n"
    },
    {
        "prefix": "setTimezone",
        "body": "setTimezone(${1:timezone})",
        "documentation": "Change the timezone defintion for the current request\n\n**USAGE:**\n*string setTimezone(timezone)*\n\n**PARAMETERS:**\n\n*timezone (string)*\n"
    },
    {
        "prefix": "setVariable",
        "body": "setVariable(${1:name}, ${2:value})",
        "documentation": "Sets a variable in the name parameter to the value of the value parameter.\n\n**USAGE:**\n*void setVariable(name, value)*\n\n**PARAMETERS:**\n\n*name (string)* - Variable name\n\n*value (string)* - A string, the name of a string, or a number\n"
    },
    {
        "prefix": "sgn",
        "body": "sgn(${1:number})",
        "documentation": " Determines the sign of a number.\n\n**USAGE:**\n*numeric sgn(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "sin",
        "body": "sin(${1:number})",
        "documentation": " Calculates the sine of an angle that is entered in radians.\n\n**USAGE:**\n*numeric sin(number)*\n\n**PARAMETERS:**\n\n*number (numeric)*\n"
    },
    {
        "prefix": "sizeOf",
        "body": "sizeOf(${1:obj})",
        "documentation": "Returns the size in bytes of a given object\n\n**USAGE:**\n*any sizeOf(obj [, complex])*\n\n**PARAMETERS:**\n\n*obj (any)*\n\n*complex (boolean)*\n"
    },
    {
        "prefix": "sleep",
        "body": "sleep(${1:duration})",
        "documentation": "Causes the current thread to stop processing for a specified period of time.\n\n**USAGE:**\n*void sleep(duration)*\n\n**PARAMETERS:**\n\n*duration ()* - Time, in milliseconds, to stop processing the current thread\n"
    },
    {
        "prefix": "soundEx",
        "body": "soundEx(${1:str})",
        "documentation": "Soundex is a phonetic algorithm for indexing names by sound, as pronounced in English.\nThe goal is for homophones to be encoded to the same representation so that they can be matched despite minor differences in spelling.\nThe algorithm mainly encodes consonants; a vowel will not be encoded unless it is the first letter.\n\nSoundex is the most widely known of all phonetic algorithms, as it is a standard feature of MS SQL and Oracle, and is often used (incorrectly) as a synonym for 'phonetic algorithm'\n\n**USAGE:**\n*String soundEx(str)*\n\n**PARAMETERS:**\n\n*str (string)*\n"
    },
    {
        "prefix": "spanExcluding",
        "body": "spanExcluding(${1:String}, ${2:set})",
        "documentation": " Gets characters from a string, from the beginning to a\n character that is in a specified set of characters. The\n search is case-sensitive.\n\n**USAGE:**\n*string spanExcluding(String, set)*\n\n**PARAMETERS:**\n\n*String (string)*\n\n*set (string)* - A string or a variable that contains a set of characters.\n Must contain one or more characters\n"
    },
    {
        "prefix": "spanIncluding",
        "body": "spanIncluding(${1:String}, ${2:set})",
        "documentation": " Gets characters from a string, from the beginning to a\n character that is not in a specified set of characters. The\n search is case-sensitive.\n\n**USAGE:**\n*string spanIncluding(String, set)*\n\n**PARAMETERS:**\n\n*String (string)*\n\n*set (string)* - A string or a variable that contains a set of characters.\n Must contain one or more characters\n"
    },
    {
        "prefix": "spreadsheetAddAutoFilter",
        "body": "spreadsheetAddAutoFilter(${1:spreadsheetObj}, ${2:autofilter})",
        "documentation": "A function to add auto filters to the spreadsheet.\n\n**USAGE:**\n*void spreadsheetAddAutoFilter(spreadsheetObj, autofilter)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (any)* - Excel spreadsheet object\n\n*autofilter (string)* - The Excel filter that needs to be applied to the sheet. Note that the vale should not contain spaces or invalid characters.\n"
    },
    {
        "prefix": "spreadsheetAddColumn",
        "body": "spreadsheetAddColumn(${1:spreadsheetObj}, ${2:data}, ${3:startrow}, ${4:startcolumn}, ${5:insert})",
        "documentation": " Adds a column or column data to an Excel spreadsheet object.\n\n**USAGE:**\n*void spreadsheetAddColumn(spreadsheetObj, data, startrow, startcolumn, insert [, insert])*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*data (string)* - No Help Available\n\n*startrow (numeric)* - No Help Available\n\n*startcolumn (numeric)* - No Help Available\n\n*insert (boolean)* - No Help Available\n\n*insert (boolean)* - No Help Available **Values:** *true, false*.\n"
    },
    {
        "prefix": "spreadsheetAddFreezePane",
        "body": "spreadsheetAddFreezePane(${1:spreadsheetObj}, ${2:column}, ${3:row})",
        "documentation": " Adds freeze pane to spreadsheet\n\n**USAGE:**\n*void spreadsheetAddFreezePane(spreadsheetObj, column, row [, endColumn] [, endRow])*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - Spreadsheet variable\n\n*column (numeric)* - No Help Available\n\n*row (numeric)* - No Help Available\n\n*endColumn (numeric)* - No Help Available\n\n*endRow (numeric)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetAddimage",
        "body": "spreadsheetAddimage(${1:spreadsheetObj}, ${2:imagefilepath}, ${3:anchor})",
        "documentation": " Adds an image to an Excel spreadsheet object.\n\n**USAGE:**\n*void spreadsheetAddimage(spreadsheetObj, imagefilepath, anchor)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*imagefilepath (string)* - No Help Available\n\n*anchor (string)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetAddInfo",
        "body": "spreadsheetAddInfo(${1:spreadsheetObj}, ${2:info})",
        "documentation": " Adds information to an Excel spreadsheet object.\n\n**USAGE:**\n*void spreadsheetAddInfo(spreadsheetObj, info)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*info (struct)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetAddPagebreaks",
        "body": "spreadsheetAddPagebreaks(${1:SpreadsheetObj}, ${2:rowbreaks}, ${3:colbreaks})",
        "documentation": "A function to add page breaks for rows and columns to a Spreadsheet Object.\n\n**USAGE:**\n*void spreadsheetAddPagebreaks(SpreadsheetObj, rowbreaks, colbreaks)*\n\n**PARAMETERS:**\n\n*SpreadsheetObj (any)* - Excel spreadsheet object to apply page break to.\n\n*rowbreaks (string)* - Comma-delimited row numbers where the page breaks will be applied.\n\n*colbreaks (string)* - Comma-delimited column numbers where the page breaks will be applied.\n"
    },
    {
        "prefix": "spreadsheetAddRow",
        "body": "spreadsheetAddRow(${1:spreadsheetObj}, ${2:data})",
        "documentation": "Adds a row to an Excel spreadsheet object.\n\n**USAGE:**\n*void spreadsheetAddRow(spreadsheetObj, data [, row] [, column] [, insert] [, datatype])*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - The speadsheet\n\n*data (string)* - A comma seperated list of cell values.\n\n*row (numeric)* - Row number at which to insert, if omitted appended.\n\n*column (numeric)* - Column number at which to insert data.. **Default:** *1*.\n\n*insert (boolean)* - When true appends data to spreadsheetObj, when false attempts to update rows.. **Default:** *true*. **Values:** *true, false*.\n\n*datatype (array)* - CF11+ List of datatype expressions with values such as `STRING` `NUMERIC` or `DATE`. For example use `DATE:1;NUMERIC:2-2;STRING\n"
    },
    {
        "prefix": "spreadsheetAddRows",
        "body": "spreadsheetAddRows(${1:spreadsheetObj}, ${2:data})",
        "documentation": "Adds multiple rows from a query or array to an Excel spreadsheet object.\n\n**USAGE:**\n*void spreadsheetAddRows(spreadsheetObj, data [, row] [, column] [, insert] [, datatype] [, includeColumnNames])*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - The spreadsheet object variable\n\n*data (any)* - A query or array\n\n*row (numeric)* - The row number in the spreadsheet at which to insert the data. If omitted rows are appended.\n\n*column (numeric)* - The column number to start, all columns to the left will be empty.\n\n*insert (boolean)* - When true appends the row `data` to the `spreadsheetObj`. When `false` attempts to update the spreadsheet object rows.. **Default:** *true*. **Values:** *true, false*.\n\n*datatype (array)* - CF11+ An array of datatype expressions with values `STRING` `NUMERIC` or `DATE`. For example use `DATE:1;NUMERIC:2-2;STRING\n\n*includeColumnNames (boolean)* - CF2016+ When `true` writes column names as headers in the spreadsheet.. **Default:** *false*.\n"
    },
    {
        "prefix": "spreadsheetAddSplitPane",
        "body": "spreadsheetAddSplitPane(${1:spreadsheetObj}, ${2:x}, ${3:y}, ${4:splitColumn}, ${5:splitRow})",
        "documentation": " Adds split pane to spreadsheet.\n\n**USAGE:**\n*void spreadsheetAddSplitPane(spreadsheetObj, x, y, splitColumn, splitRow [, position])*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - Spreadsheet variable\n\n*x (numeric)* - X position for split\n\n*y (numeric)* - Y position for split\n\n*splitColumn (numeric)* - Split Column\n\n*splitRow (numeric)* - Split Row\n\n*position (string)* - Specify which pane has the focus **Values:** *LOWER_LEFT, LOWER_RIGHT, UPPER_LEFT, UPPER_RIGHT*.\n"
    },
    {
        "prefix": "spreadsheetCreateSheet",
        "body": "spreadsheetCreateSheet(${1:spreadsheetObj}, ${2:name})",
        "documentation": " Create spreadsheet from given spreadsheet object\n\n**USAGE:**\n*void spreadsheetCreateSheet(spreadsheetObj, name)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*name (string)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetDeleteColumn",
        "body": "spreadsheetDeleteColumn(${1:spreadsheetObj}, ${2:column})",
        "documentation": " Deletes the data from a column of an Excel spreadsheet object. It does not delete the column.\n\n**USAGE:**\n*void spreadsheetDeleteColumn(spreadsheetObj, column)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*column (numeric)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetDeleteColumns",
        "body": "spreadsheetDeleteColumns(${1:spreadsheetObj}, ${2:range})",
        "documentation": " Deletes the data from multiple columns of an Excel spreadsheet object. This function does not remove the columns.\n\n**USAGE:**\n*void spreadsheetDeleteColumns(spreadsheetObj, range)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*range (numeric)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetDeleteRow",
        "body": "spreadsheetDeleteRow(${1:spreadsheetObj}, ${2:row})",
        "documentation": " Deletes all data from a row of an Excel spreadsheet object. It does not delete the row.\n\n**USAGE:**\n*void spreadsheetDeleteRow(spreadsheetObj, row)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*row (numeric)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetDeleteRows",
        "body": "spreadsheetDeleteRows(${1:spreadsheetObj}, ${2:range})",
        "documentation": " Deletes all data from multiple rows of an Excel spreadsheet object. It does not delete the row.\n\n**USAGE:**\n*void spreadsheetDeleteRows(spreadsheetObj, range)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*range (numeric)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetFormatCell",
        "body": "spreadsheetFormatCell(${1:spreadsheetObj}, ${2:format}, ${3:row}, ${4:column})",
        "documentation": " Formats the contents of a single cell of an Excel spreadsheet object.\n\n**USAGE:**\n*void spreadsheetFormatCell(spreadsheetObj, format, row, column)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*format (string)* - No Help Available\n\n*row (numeric)* - No Help Available\n\n*column (numeric)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetFormatCellRange",
        "body": "spreadsheetFormatCellRange(${1:spreadsheetObj}, ${2:format}, ${3:startRow}, ${4:startColumn}, ${5:endRow}, ${6:endColumn})",
        "documentation": " Formats the cells within the given range.\n\n**USAGE:**\n*void spreadsheetFormatCellRange(spreadsheetObj, format, startRow, startColumn, endRow, endColumn)*\n\n**PARAMETERS:**\n\n*spreadsheetObj ()* - The Excel spreadsheet object for which you want to format the cells.\n\n*format ()* - A structure that contains format information.\n\n*startRow ()* - The number of the first row to format.\n\n*startColumn ()* - The number of the first column to format.\n\n*endRow ()* - The number of the last row to format.\n\n*endColumn ()* - The number of the last column to format.\n"
    },
    {
        "prefix": "spreadsheetFormatColumn",
        "body": "spreadsheetFormatColumn(${1:spreadsheetObj}, ${2:format}, ${3:column})",
        "documentation": " Formats the contents of a single column of an Excel spreadsheet object.\n\n**USAGE:**\n*void spreadsheetFormatColumn(spreadsheetObj, format, column)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*format (string)* - No Help Available\n\n*column (numeric)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetFormatColumns",
        "body": "spreadsheetFormatColumns(${1:spreadsheetObj}, ${2:format}, ${3:columns})",
        "documentation": " Formats the contents of a multipe columns of an Excel spreadsheet object.\n\n**USAGE:**\n*void spreadsheetFormatColumns(spreadsheetObj, format, columns)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*format (string)* - No Help Available\n\n*columns (string)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetFormatRow",
        "body": "spreadsheetFormatRow(${1:spreadsheetObj}, ${2:format}, ${3:row})",
        "documentation": " Formats the contents of a single row of an Excel spreadsheet object.\n\n**USAGE:**\n*void spreadsheetFormatRow(spreadsheetObj, format, row)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*format (string)* - No Help Available\n\n*row (numeric)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetFormatRows",
        "body": "spreadsheetFormatRows(${1:spreadsheetObj}, ${2:format}, ${3:row})",
        "documentation": " Formats the contents of a multipe rows of an Excel spreadsheet object.\n\n**USAGE:**\n*void spreadsheetFormatRows(spreadsheetObj, format, row)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*format (string)* - No Help Available\n\n*row (numeric)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetGetCellComment",
        "body": "spreadsheetGetCellComment(${1:author})",
        "documentation": " Gets the comment for an Excel spreadsheet object cell as a structure with formatting information, or all comments for the object.\n\n**USAGE:**\n*array spreadsheetGetCellComment(author [, column] [, comment] [, row])*\n\n**PARAMETERS:**\n\n*author (string)* - No Help Available\n\n*column (numeric)* - No Help Available\n\n*comment (string)* - No Help Available\n\n*row (string)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetGetCellFormula",
        "body": "spreadsheetGetCellFormula(${1:spreadsheetObj}, ${2:row}, ${3:column})",
        "documentation": " Gets the formula for a for an Excel spreadsheet object cell, or all formulas for the object.\n\n**USAGE:**\n*string spreadsheetGetCellFormula(spreadsheetObj, row, column)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*row (numeric)* - No Help Available\n\n*column (numeric)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetGetCellValue",
        "body": "spreadsheetGetCellValue(${1:spreadsheetObj}, ${2:row}, ${3:column})",
        "documentation": " Gets the Value for a for an Excel spreadsheet object cell.\n\n**USAGE:**\n*string spreadsheetGetCellValue(spreadsheetObj, row, column)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*row (string)* - No Help Available\n\n*column (string)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetGetColumnCount",
        "body": "spreadsheetGetColumnCount(${1:spreadsheetObj})",
        "documentation": "Returns the number of columns in a given spreadsheet.\n\n**USAGE:**\n*numeric spreadsheetGetColumnCount(spreadsheetObj [, sheet])*\n\n**PARAMETERS:**\n\n*spreadsheetObj (any)* - The spreadsheet object\n\n*sheet (string)* - The sheet name or sheet number\n"
    },
    {
        "prefix": "spreadsheetInfo",
        "body": "spreadsheetInfo(${1:spreadsheetObj})",
        "documentation": " Returns spreadsheet property\n\n**USAGE:**\n*struct spreadsheetInfo(spreadsheetObj)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetMergeCells",
        "body": "spreadsheetMergeCells(${1:spreadsheetObj}, ${2:startrow}, ${3:endrow}, ${4:startcolumn}, ${5:endcolumn})",
        "documentation": " Merges a rectangular block of two or more Excel spreadsheet object cells.\n\n**USAGE:**\n*void spreadsheetMergeCells(spreadsheetObj, startrow, endrow, startcolumn, endcolumn)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*startrow (numeric)* - No Help Available\n\n*endrow (numeric)* - No Help Available\n\n*startcolumn (numeric)* - No Help Available\n\n*endcolumn (numeric)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetNew",
        "body": "spreadsheetNew()",
        "documentation": " Creates a ColdFusion spreadsheet object, which represents a single sheet of an Excel document.\n\n**USAGE:**\n*any spreadsheetNew( [sheetname] [, xmlFormat])*\n\n**PARAMETERS:**\n\n*sheetname (string)* - String value to be used as the sheet name.\n\n*xmlFormat (boolean)* - Boolean value to indicate the use of Excels xlsx format.. **Default:** *false*. **Values:** *true, false*.\n"
    },
    {
        "prefix": "spreadsheetRead",
        "body": "spreadsheetRead(${1:fileName}, ${2:spreadsheetObj})",
        "documentation": " Create a new spreadsheet variable from specified file\n\n**USAGE:**\n*void spreadsheetRead(fileName, spreadsheetObj)*\n\n**PARAMETERS:**\n\n*fileName (string)* - No Help Available\n\n*spreadsheetObj (variableName)* - Spreadsheet name or number\n"
    },
    {
        "prefix": "spreadsheetReadBinary",
        "body": "spreadsheetReadBinary(${1:spreadsheetObj})",
        "documentation": " Reads spreadsheet file into a binary object\n\n**USAGE:**\n*void spreadsheetReadBinary(spreadsheetObj)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - Spreadsheet file\n"
    },
    {
        "prefix": "spreadsheetRemoveSheet",
        "body": "spreadsheetRemoveSheet(${1:spreadsheetObj}, ${2:sheetname})",
        "documentation": "Deletes a spreadsheet.\n\n**USAGE:**\n*void spreadsheetRemoveSheet(spreadsheetObj, sheetname)*\n\n**PARAMETERS:**\n\n*spreadsheetObj ()* - The Excel spreadsheet object from which you delete the sheet.\n\n*sheetname ()* - Name of the sheet that must be removed.\n"
    },
    {
        "prefix": "spreadsheetSetActiveSheet",
        "body": "spreadsheetSetActiveSheet(${1:spreadsheetObj})",
        "documentation": " Sets active sheet in given spreadsheet\n\n**USAGE:**\n*void spreadsheetSetActiveSheet(spreadsheetObj [, name])*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*name (string)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetSetActiveSheetNumber",
        "body": "spreadsheetSetActiveSheetNumber(${1:spreadsheetObj})",
        "documentation": " Sets number of active sheet in given spreadsheet\n\n**USAGE:**\n*void spreadsheetSetActiveSheetNumber(spreadsheetObj [, number])*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*number (numeric)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetSetCellComment",
        "body": "spreadsheetSetCellComment(${1:spreadsheetObj}, ${2:comment}, ${3:row}, ${4:column})",
        "documentation": " Specifies the comment for an Excel spreadsheet object cell.\n\n**USAGE:**\n*void spreadsheetSetCellComment(spreadsheetObj, comment, row, column)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*comment (string)* - No Help Available\n\n*row (numeric)* - No Help Available\n\n*column (numeric)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetSetCellFormula",
        "body": "spreadsheetSetCellFormula(${1:spreadsheetObj}, ${2:formula}, ${3:row}, ${4:column})",
        "documentation": " Specifies the formula for an Excel spreadsheet object cell.\n\n**USAGE:**\n*void spreadsheetSetCellFormula(spreadsheetObj, formula, row, column)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*formula (string)* - No Help Available\n\n*row (numeric)* - No Help Available\n\n*column (numeric)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetSetCellValue",
        "body": "spreadsheetSetCellValue(${1:spreadsheetObj}, ${2:value}, ${3:row}, ${4:column})",
        "documentation": " Specifies the value of an Excel spreadsheet object cell.\n\n**USAGE:**\n*void spreadsheetSetCellValue(spreadsheetObj, value, row, column)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*value (string)* - No Help Available\n\n*row (numeric)* - No Help Available\n\n*column (numeric)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetSetColumnWidth",
        "body": "spreadsheetSetColumnWidth(${1:spreadsheetObj}, ${2:columnNumber}, ${3:width})",
        "documentation": " Sets the width of a column in a worksheet.\n\n**USAGE:**\n*void spreadsheetSetColumnWidth(spreadsheetObj, columnNumber, width)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - The Excel spreadsheet object to which to set the column width.\n\n*columnNumber (numeric)* - Specifies the column to set the width.\n\n*width (numeric)* - Specifies the width in points.\n"
    },
    {
        "prefix": "spreadsheetSetFooter",
        "body": "spreadsheetSetFooter(${1:spreadsheetObj}, ${2:leftFooter}, ${3:centerFooter}, ${4:rightFooter})",
        "documentation": " Adds a footer to the specified worksheet.\n\n**USAGE:**\n*void spreadsheetSetFooter(spreadsheetObj, leftFooter, centerFooter, rightFooter)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - The Excel spreadsheet object to which to add the footer.\n\n*leftFooter (string)* - Adds the footer in the left side of the worksheet.\n\n*centerFooter (string)* - Adds the footer in the center of the worksheet.\n\n*rightFooter (string)* - Adds the footer in the right side of the worksheet.\n"
    },
    {
        "prefix": "spreadsheetSetHeader",
        "body": "spreadsheetSetHeader(${1:spreadsheetObj}, ${2:leftHeader}, ${3:centerHeader}, ${4:rightHeader})",
        "documentation": " Adds a header to the specified worksheet.\n\n**USAGE:**\n*void spreadsheetSetHeader(spreadsheetObj, leftHeader, centerHeader, rightHeader)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - The Excel spreadsheet object to which to add the header.\n\n*leftHeader (string)* - Adds the header in the left side of the worksheet.\n\n*centerHeader (string)* - Adds the header in the center of the worksheet.\n\n*rightHeader (string)* - Adds the header in the right side of the worksheet.\n"
    },
    {
        "prefix": "spreadsheetSetRowHeight",
        "body": "spreadsheetSetRowHeight(${1:spreadsheetObj}, ${2:rowNumber}, ${3:height})",
        "documentation": " Sets the height of a row in a worksheet.\n\n**USAGE:**\n*void spreadsheetSetRowHeight(spreadsheetObj, rowNumber, height)*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - The Excel spreadsheet object to which to set the column width.\n\n*rowNumber (numeric)* - Specifies the row to set the height.\n\n*height (numeric)* - Specifies the height in points.\n"
    },
    {
        "prefix": "spreadsheetShiftColumns",
        "body": "spreadsheetShiftColumns(${1:spreadsheetObj}, ${2:start})",
        "documentation": " shifts one or more columns in Excel spreadsheet object left or right.\n\n**USAGE:**\n*void spreadsheetShiftColumns(spreadsheetObj, start [, end] [, start])*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*start (numeric)* - No Help Available\n\n*end (numeric)* - No Help Available\n\n*start (numeric)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetShiftRows",
        "body": "spreadsheetShiftRows(${1:spreadsheetObj}, ${2:start}, ${3:end})",
        "documentation": " shifts one or more rows in Excel spreadsheet object up or down. . The contents of the shifted row, including empty cells, overwrites data in the column to which it is shfted.\n\n**USAGE:**\n*void spreadsheetShiftRows(spreadsheetObj, start, end [, rows])*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*start (numeric)* - No Help Available\n\n*end (numeric)* - No Help Available\n\n*rows (numeric)* - No Help Available\n"
    },
    {
        "prefix": "spreadsheetwrite",
        "body": "spreadsheetwrite(${1:spreadsheetObj}, ${2:fileName})",
        "documentation": " Writes Spreadsheet object into file\n\n**USAGE:**\n*void spreadsheetwrite(spreadsheetObj, fileName [, password] [, overwrite])*\n\n**PARAMETERS:**\n\n*spreadsheetObj (variableName)* - No Help Available\n\n*fileName (string)* - No Help Available\n\n*password (string)* - No Help Available\n\n*overwrite (boolean)* - No Help Available\n"
    },
    {
        "prefix": "sqr",
        "body": "sqr(${1:number})",
        "documentation": " Calculates the square root of a number.\n\n**USAGE:**\n*numeric sqr(number)*\n\n**PARAMETERS:**\n\n*number (numeric)* - A positive integer or a variable that contains one.\n Number whose square root to get.\n"
    },
    {
        "prefix": "sslCertificateInstall",
        "body": "sslCertificateInstall(${1:host})",
        "documentation": "Installs certificates of a specific host into the JVM certificate store\n\n**USAGE:**\n*void sslCertificateInstall(host [, port])*\n\n**PARAMETERS:**\n\n*host (string)*\n\n*port (numeric)*. **Default:** *443*.\n"
    },
    {
        "prefix": "sslCertificateList",
        "body": "sslCertificateList(${1:host})",
        "documentation": "List all Certificates available on a specific host\n\n**USAGE:**\n*query sslCertificateList(host [, port])*\n\n**PARAMETERS:**\n\n*host (string)*\n\n*port (numeric)*. **Default:** *443*.\n"
    },
    {
        "prefix": "storeAddACL",
        "body": "storeAddACL(${1:url}, ${2:ACLObject})",
        "documentation": "Adds ACL to existing ACL for object or bucket.\n\n**USAGE:**\n*void storeAddACL(url, ACLObject)*\n\n**PARAMETERS:**\n\n*url ()* - Amazon S3 URLs (content or object).\n\n*ACLObject ()* - An array of struct where each struct represents a permission or grant as discussed in ACLObject.\n"
    },
    {
        "prefix": "storeGetACL",
        "body": "storeGetACL(${1:ulr}, ${2:ACLObject})",
        "documentation": " Gets the ACL object or bucket.\n\n**USAGE:**\n*any storeGetACL(ulr, ACLObject)*\n\n**PARAMETERS:**\n\n*ulr ()* - Amazon S3 URLs (content or object)\n\n*ACLObject ()* - An array of struct where each struct represents a permission or grant as discussed in ACLObject.\n"
    },
    {
        "prefix": "storeGetMetadata",
        "body": "storeGetMetadata(${1:url})",
        "documentation": " Returns the metadata related to the object or bucket.\n\n**USAGE:**\n*struct storeGetMetadata(url)*\n\n**PARAMETERS:**\n\n*url ()* - Amazon S3 URLs (bucket or object).\n"
    },
    {
        "prefix": "storeSetACL",
        "body": "storeSetACL(${1:url}, ${2:ACLObject})",
        "documentation": " Sets the ACL for object or bucket.\n\n**USAGE:**\n*void storeSetACL(url, ACLObject)*\n\n**PARAMETERS:**\n\n*url ()* - Amazon S3 URLs (content or object).\n\n*ACLObject ()* - An array of struct where each struct represents a permission or grant as discussed in ACLObject.\n"
    },
    {
        "prefix": "storeSetMetadata",
        "body": "storeSetMetadata(${1:url}, ${2:region})",
        "documentation": "Sets the metadata on bucket or object.\n\n**USAGE:**\n*void storeSetMetadata(url, region)*\n\n**PARAMETERS:**\n\n*url ()* - Amazon S3 URLs (bucket or object).\n\n*region ()* - Represents the metadata. See Standard keys for a list of standard keys in metadata.You can also have custom metadata apart from the standard ones.\n"
    },
    {
        "prefix": "stringLen",
        "body": "stringLen(${1:string})",
        "documentation": "Get the length of a string.\n\n**USAGE:**\n*numeric stringLen(string)*\n\n**PARAMETERS:**\n\n*string (string)*\n"
    },
    {
        "prefix": "stripCR",
        "body": "stripCR(${1:String})",
        "documentation": " Deletes return characters from a string.\n\n**USAGE:**\n*string stripCR(String)*\n\n**PARAMETERS:**\n\n*String (string)* - A string or a variable that contains one\n"
    },
    {
        "prefix": "structAppend",
        "body": "structAppend(${1:destStruct}, ${2:sourceStruct})",
        "documentation": "Appends one structure to another.\n\n**USAGE:**\n*boolean structAppend(destStruct, sourceStruct [, overwriteFlag])*\n\n**PARAMETERS:**\n\n*destStruct (struct)* - Structure to append.\n\n*sourceStruct (struct)* - Structure that contains the data to append to destStruct\n\n*overwriteFlag (boolean)* - Yes: values in sourceStruct overwrite corresponding values in\n destStruct. Default.. **Default:** *true*. **Values:** *true, false*.\n"
    },
    {
        "prefix": "structClear",
        "body": "structClear(${1:structure})",
        "documentation": " Removes all data from a structure.\n\n**USAGE:**\n*boolean structClear(structure)*\n\n**PARAMETERS:**\n\n*structure (struct)* - Structure to clear\n"
    },
    {
        "prefix": "structCopy",
        "body": "structCopy(${1:structure})",
        "documentation": " Copies a structure. Copies top-level keys, values, and arrays\n in the structure by value; copies nested structures by\n reference.\n\n**USAGE:**\n*struct structCopy(structure)*\n\n**PARAMETERS:**\n\n*structure (struct)* - Structure to copy\n"
    },
    {
        "prefix": "structCount",
        "body": "structCount(${1:structure})",
        "documentation": " Counts the keys in a structure.\n\n**USAGE:**\n*numeric structCount(structure)*\n\n**PARAMETERS:**\n\n*structure (struct)* - Structure to access\n"
    },
    {
        "prefix": "structDelete",
        "body": "structDelete(${1:structure}, ${2:key})",
        "documentation": "Removes an element from a structure.\n\n**USAGE:**\n*boolean structDelete(structure, key [, indicateNotExisting])*\n\n**PARAMETERS:**\n\n*structure (string)* - Structure or a variable that contains one. Contains element\n to remove\n\n*key (string)* - Element to remove\n\n*indicateNotExisting (boolean)* - When true this function will return true only if they key that will be deleted existed. When false (default) this function will return true if the key is successfully removed. **Values:** *true, false*.\n"
    },
    {
        "prefix": "structEach",
        "body": "structEach(${1:structure}, ${2:callback})",
        "documentation": "Used to loop over elements in a structure by accessing key-value pairs.\n\n**USAGE:**\n*void structEach(structure, callback)*\n\n**PARAMETERS:**\n\n*structure (string)* - Structure or a variable that contains one.\n\n*callback (UDF)* - Closure or function reference that will be called for each iteration. The arguments passed to the callback are:\n\n<strong>key:</strong> Name of the key in the struct\n<strong>value:</strong> Value of the key in the struct\n<strong>struct:</strong> Lucee4.5+ A reference to the original struct\n"
    },
    {
        "prefix": "structEvery",
        "body": "structEvery(${1:struct}, ${2:closure})",
        "documentation": "This function calls a given closure/function with every element in a given struct and returns true, if all of the closure calls returns true\n\n**USAGE:**\n*boolean structEvery(struct, closure [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*struct (struct)*\n\n*closure (function)*\n\n*parallel (boolean)*\n\n*maxThreads (numeric)*. **Default:** *20*.\n"
    },
    {
        "prefix": "structFilter",
        "body": "structFilter(${1:structure}, ${2:function})",
        "documentation": "Used to filter the key-value pairs in a structure.\n\n**USAGE:**\n*struct structFilter(structure, function)*\n\n**PARAMETERS:**\n\n*structure (struct)* - Name of the structure to filter\n\n*function (function)* - Inline function/closure executed for each key in the structure. Returns true if the key-value pair in the structure should be included in the filtered struct. Support for passing the original struct to the closure function added in CF11 Update 5.\n"
    },
    {
        "prefix": "structFind",
        "body": "structFind(${1:structure}, ${2:key})",
        "documentation": " Determines the value associated with a key in a structure.\n\n**USAGE:**\n*any structFind(structure, key)*\n\n**PARAMETERS:**\n\n*structure (struct)* - Structure that contains the value to return\n\n*key (string)* - Key whose value to return\n"
    },
    {
        "prefix": "structFindKey",
        "body": "structFindKey(${1:top}, ${2:value}, ${3|one,all|})",
        "documentation": " Searches recursively through a substructure of nested arrays,\n structures, and other elements, for structures whose keys\n match the search key in the value parameter.\n\n**USAGE:**\n*array structFindKey(top, value, scope)*\n\n**PARAMETERS:**\n\n*top (any)* - CFML object (structure or array) from which to start\n search. This attribute requires an object, not a name of\n an object.\n\n*value (string)* - String or a variable that contains one for which to search.\n\n*scope (string)* - * one: returns one matching key. Default.\n * all: returns all matching keys **Values:** *one, all*.\n"
    },
    {
        "prefix": "structFindValue",
        "body": "structFindValue(${1:top}, ${2:value})",
        "documentation": " Searches recursively through a substructure of nested arrays,\n structures, and other elements for structures with values that\n match the search key in the value parameter.\n\n**USAGE:**\n*array structFindValue(top, value [, scope])*\n\n**PARAMETERS:**\n\n*top (any)* - CFML object (a structure or an array) from which to\n start search. This attribute requires an object, not a\n name of an object.\n\n*value (string)* - String or a variable that contains one for which to search.\n The type must be a simple object. Arrays and structures\n are not supported.\n\n*scope (string)* - one: function returns one matching key (default)\n all: function returns all matching keys **Values:** *one, all*.\n"
    },
    {
        "prefix": "structGet",
        "body": "structGet(${1:path})",
        "documentation": "Returns a value in a structure or a structure in the specified path.\n\n**USAGE:**\n*any structGet(path)*\n\n**PARAMETERS:**\n\n*path (string)* - Pathname of variable that contains structure or array from which CFML retrieves the value. If there is no structure or array present in the path, this function creates structures or arrays to make it a valid variable path.\n"
    },
    {
        "prefix": "structInsert",
        "body": "structInsert(${1:structure}, ${2:key}, ${3:value})",
        "documentation": " Inserts a key-value pair into a structure.\n\n**USAGE:**\n*boolean structInsert(structure, key, value [, allowoverwrite])*\n\n**PARAMETERS:**\n\n*structure (struct)* - Structure to contain the new key-value pair.\n\n*key (string)* - Key that contains the inserted value.\n\n*value (any)* - Value to add.\n\n*allowoverwrite (boolean)* - Whether to allow overwriting a key. Default: False. **Values:** *true, false*.\n"
    },
    {
        "prefix": "structIsEmpty",
        "body": "structIsEmpty(${1:structure})",
        "documentation": " Determines whether a structure contains data.\n\n**USAGE:**\n*boolean structIsEmpty(structure)*\n\n**PARAMETERS:**\n\n*structure (struct)* - Structure to test\n"
    },
    {
        "prefix": "structKeyArray",
        "body": "structKeyArray(${1:structure})",
        "documentation": "Returns the keys in a CFML structure as an array. If structure does not exist throws an exception.\n\n**USAGE:**\n*array structKeyArray(structure)*\n\n**PARAMETERS:**\n\n*structure (struct)*\n"
    },
    {
        "prefix": "structKeyExists",
        "body": "structKeyExists(${1:structure}, ${2:key})",
        "documentation": "Determines whether a specific key is present in a structure.\n\n**USAGE:**\n*boolean structKeyExists(structure, key)*\n\n**PARAMETERS:**\n\n*structure (struct)* - Name of structure to test\n\n*key (string)* - Key to test\n"
    },
    {
        "prefix": "structKeyList",
        "body": "structKeyList(${1:structure})",
        "documentation": " Extracts keys from a CFML structure.\n\n**USAGE:**\n*string structKeyList(structure [, delimiter])*\n\n**PARAMETERS:**\n\n*structure (struct)* - Structure from which to extract a list of keys\n\n*delimiter (string)* - Character that separates keys in list. Default: comma.. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n"
    },
    {
        "prefix": "structKeyTranslate",
        "body": "structKeyTranslate(${1:structure})",
        "documentation": "Converts structure key/value pairs where the key contains a period (.) into nested structures key / value pairs\n\n**USAGE:**\n*numeric structKeyTranslate(structure [, deepTranslation] [, leaveOriginalKey])*\n\n**PARAMETERS:**\n\n*structure (struct)*\n\n*deepTranslation (boolean)*\n\n*leaveOriginalKey (boolean)*\n"
    },
    {
        "prefix": "structMap",
        "body": "structMap(${1:struct}, ${2:function})",
        "documentation": "Iterates over every entry of the Struct and calls the closure function to work on the key value pair of the struct. The returned value will be set for the same key in a new struct and the new struct will be returned.\n\n**USAGE:**\n*struct structMap(struct, function)*\n\n**PARAMETERS:**\n\n*struct (struct)* - The input struct.\n\n*function (any)* - Closure or a function reference that will be called for each of the iteration. The arguments passed to the callback are\r\n\r\nkey: key for the current iteration\r\nvalue: the value for the current iteration\r\nstruct: a reference of the original struct\n"
    },
    {
        "prefix": "structNew",
        "body": "structNew()",
        "documentation": "Creates a structure.\n\n**USAGE:**\n*struct structNew( [structType])*\n\n**PARAMETERS:**\n\n*structType (string)* - CF2016+ Lucee4.5+ If set to `ordered` the order in which elements are added to the structure will be maintained. In Lucee `linked` can be used in place of `ordered`. **Values:** *ordered*.\n"
    },
    {
        "prefix": "structReduce",
        "body": "structReduce(${1:struct}, ${2:function}, ${3:initialVal})",
        "documentation": "Iterates over every entry of the struct and calls the closure to work on the key value pair of the struct. This function will reduce the struct to a single value and will return the value.\n\n**USAGE:**\n*any structReduce(struct, function, initialVal)*\n\n**PARAMETERS:**\n\n*struct (struct)* - The input struct.\n\n*function (any)* - Closure or a function reference that will be called for each of the iteration. The arguments passed to the callback are\r\n\r\nresult: the result of the reduce operation after the previous iteration\r\nkey: key for the current iteration\r\nvalue: the value for the current iteration\r\nstruct: a reference of the original struct\n\n*initialVal (any)* - Initial value which will be used for the reduce operation. The type is any.\n"
    },
    {
        "prefix": "structSome",
        "body": "structSome(${1:struct}, ${2:closure})",
        "documentation": "This function calls a given closure/function with every element in a given struct and returns true, if one of the closure calls returns true\n\n**USAGE:**\n*boolean structSome(struct, closure [, parallel] [, maxThreads])*\n\n**PARAMETERS:**\n\n*struct (struct)*\n\n*closure (function)*\n\n*parallel (boolean)*\n\n*maxThreads (numeric)*. **Default:** *20*.\n"
    },
    {
        "prefix": "structSort",
        "body": "structSort(${1:base}, ${2|numeric,text,textnocase|}, ${3:sortorder}, ${4:pathtosubelement})",
        "documentation": " Returns a sorted array of the top level keys in a structure.\n Sorts using alphabetic or numeric sorting, and can sort based\n on the values of any structure element.\n\n**USAGE:**\n*array structSort(base, sorttype, sortorder, pathtosubelement)*\n\n**PARAMETERS:**\n\n*base (struct)*\n\n*sorttype (string)* - * numeric\n * text: case sensitive Default.\n * textnocase **Values:** *numeric, text, textnocase*.\n\n*sortorder (string)* - * asc: ascending (a to z) sort order. Default.\n * desc: descending (z to a) sort order\n\n*pathtosubelement (string)* - String or a variable that contains one\n"
    },
    {
        "prefix": "structUpdate",
        "body": "structUpdate(${1:structure}, ${2:key}, ${3:value})",
        "documentation": " Updates a key with a value.\n\n**USAGE:**\n*boolean structUpdate(structure, key, value)*\n\n**PARAMETERS:**\n\n*structure (struct)* - Structure to update\n\n*key (string)* - Key, the value of which to update\n\n*value (any)* - New value\n"
    },
    {
        "prefix": "systemCacheClear",
        "body": "systemCacheClear()",
        "documentation": "Clears all caches or the specified cache\n\n**USAGE:**\n*void systemCacheClear( [cacheName])*\n\n**PARAMETERS:**\n\n*cacheName (string)*\n"
    },
    {
        "prefix": "systemOutput",
        "body": "systemOutput(${1:obj})",
        "documentation": "Writes the given string to the output stream\n\n**USAGE:**\n*boolean systemOutput(obj [, addNewLine] [, doErrorStream])*\n\n**PARAMETERS:**\n\n*obj (any)*\n\n*addNewLine (boolean)*\n\n*doErrorStream (boolean)*\n"
    },
    {
        "prefix": "tan",
        "body": "tan(${1:number})",
        "documentation": " Calculates the tangent of an angle that is entered in radians.\n\n**USAGE:**\n*numeric tan(number)*\n\n**PARAMETERS:**\n\n*number (numeric)* - Angle, in radians, for which to calculate the tangent\n"
    },
    {
        "prefix": "threadJoin",
        "body": "threadJoin(${1:Param1})",
        "documentation": " No Help Available\n\n**USAGE:**\n*void threadJoin(Param1)*\n\n**PARAMETERS:**\n\n*Param1 ()* - No Help Available\n"
    },
    {
        "prefix": "threadTerminate",
        "body": "threadTerminate(${1:threadname})",
        "documentation": " Terminates the thread specified by the threadName parameter.\n\n**USAGE:**\n*void threadTerminate(threadname)*\n\n**PARAMETERS:**\n\n*threadname (string)* - No Help Available\n"
    },
    {
        "prefix": "throw",
        "body": "throw()",
        "documentation": "Throws a developer-specified exception, which can be caught\n with a catch block.\n\n**USAGE:**\n*numeric throw( [message] [, type] [, detail] [, errorcode] [, extendedinfo] [, object])*\n\n**PARAMETERS:**\n\n*message (string)* - Message that describes exception event.\n\n*type (string)* - * A custom type\n * Application\n Do not enter another predefined type; types are not\n generated by CFML applications. If you specify\n Application, you need not specify a type for cfcatch.. **Default:** *Custom*. **Values:** *Custom, Application, Database, Template, Security, Object, MissingInclude, Expression, Lock, SearchEngine*.\n\n*detail (string)* - Description of the event. CFML appends error position\n to description; server uses this parameter if an error is\n not caught by your code.\n\n*errorcode (string)* - A custom error code that you supply.\n\n*extendedinfo (string)* - Additional custom error data that you supply.\n\n*object (any)* - Requires the value of the cfobject tag name attribute.\n\n Throws a Java exception from a CFML tag.\n\n This attribute is mutually exclusive with all other\n attributes of this tag.\n"
    },
    {
        "prefix": "timeFormat",
        "body": "timeFormat(${1:time})",
        "documentation": "Formats a time value using US English time formatting conventions. If no mask is specified, returns a time value using the hh:mm tt format. For international time formatting, see LSTimeFormat.\n\n**USAGE:**\n*string timeFormat(time [, mask])*\n\n**PARAMETERS:**\n\n*time (date)* - A date/time value or string to convert\n\n*mask (string)* - Masking characters that determine the format.\n `h`,`hh`,`H`,`HH`: Hours\n `m`,`mm`: Minutes\n`s`,`ss`: Seconds\n `l`: Milliseconds\n`t`: A or P\n`tt`: AM or PM\n`z`: Time zone in literal format, for example GMT\n`Z`: Time zone in hours offset (RFC822), for example +0400\n`X`,`XX`,`XXX`: Time zone in hourse of offset in ISO 8601 format\n`\"short\"`: `h:mm tt`\n`\"medium\"`: `h:mm:ss tt`. **Default:** *hh:mm tt*. **Values:** *short, medium, long, full*.\n"
    },
    {
        "prefix": "toBase64",
        "body": "toBase64(${1:string_or_object})",
        "documentation": " Calculates the Base64 representation of a string or binary\n object. The Base64 format uses printable characters, allowing\n binary data to be sent in forms and e-mail, and stored in a\n database or file.\n\n**USAGE:**\n*string toBase64(string_or_object [, encoding])*\n\n**PARAMETERS:**\n\n*string_or_object (any)* - A string, the name of a string, or a binary object.\n\n*encoding (string)* - For a string, defines how characters are represented in a\n byte array. **Values:** *utf-8, iso-8859-1, windows-1252, us-ascii, shift_jis, iso-2022-jp, euc-jp, euc-kr, big5, euc-cn, utf-16*.\n"
    },
    {
        "prefix": "toBinary",
        "body": "toBinary(${1:base64_or_object})",
        "documentation": " Calculates the binary representation of Base64-encoded data.\n\n**USAGE:**\n*binary toBinary(base64_or_object)*\n\n**PARAMETERS:**\n\n*base64_or_object (any)* - A string or a variable that contains one:\n * In Base64 format to convert to binary\n * In binary format to test whether it is valid\n"
    },
    {
        "prefix": "toNumeric",
        "body": "toNumeric(${1:value})",
        "documentation": "Cast a value to a number.\n\n**USAGE:**\n*numeric toNumeric(value [, radix])*\n\n**PARAMETERS:**\n\n*value (any)*\n\n*radix (any)* - The base of the value.. **Default:** *10*. **Values:** *2, ..., 36, bin, oct, dec, hex*.\n"
    },
    {
        "prefix": "toScript",
        "body": "toScript(${1:cfvar}, ${2:javascriptvar})",
        "documentation": " Creates a JavaScript or ActionScript expression that\n assigns the value of a ColdFusion variable to a JavaScript\n or ActionScript variable. This function can convert\n ColdFusion strings, numbers, arrays, structures, and\n queries to JavaScript or ActionScript syntax that defines\n equivalent variables and values.\n\n**USAGE:**\n*string toScript(cfvar, javascriptvar [, outputformat] [, asformat])*\n\n**PARAMETERS:**\n\n*cfvar (any)* - A ColdFusion variable. This can contain one of the following:\n String, Number, Array, Structure or Query.\n\n*javascriptvar (string)* - A string that specifies the name of the JavaScript variable\n that the toScript function creates.\n\n*outputformat (boolean)* - A Boolean value that determines whether to create\n WDDX (JavaScript) or ActionScript style output for\n structures and queries.\n Default: true. **Default:** *true*. **Values:** *true, false*.\n\n*asformat (boolean)* - A Boolean value that specifies whether to use\n ActionScript shortcuts in the script.\n Default: false **Values:** *true, false*.\n"
    },
    {
        "prefix": "toString",
        "body": "toString(${1:any_value})",
        "documentation": " Converts a value to a string.\nLucee parses numbers with one decimal place.\ncomplex object types can only be used in combination with the member syntax.\n\n**USAGE:**\n*string toString(any_value [, encoding])*\n\n**PARAMETERS:**\n\n*any_value (any)* - Value to convert to a string\n\n*encoding (string)* - The character encoding (character set) of the string.. **Default:** *The default value is the encoding of the page on which the function is called.*. **Values:** *utf-8, iso-8859-1, windows-1252, us-ascii, shift_jis, iso-2022-jp, euc-jp, euc-kr, big5, euc-cn, utf-16*.\n"
    },
    {
        "prefix": "trace",
        "body": "trace()",
        "documentation": " Displays and logs debugging data about the state of an\n application at the time the cftrace tag executes. Tracks\n runtime logic flow, variable values, and execution time.\n Displays output at the end of the request or in the debugging\n section at the end of the request;\n\n CFML logs cftrace output to the file logs\\cftrace.log, in\n the CFML installation directory.\n\n Note: To permit this tag to execute, you must enable debugging\n in the CFML Administrator. Optionally, to report trace\n summaries, enable the trace section.\n\n**USAGE:**\n*void trace( [abort] [, category] [, inline] [, text] [, type] [, var])*\n\n**PARAMETERS:**\n\n*abort (boolean)* - Calls cfabort tag when the tag is executed **Values:** *true, false*.\n\n*category (string)* - User-defined string for identifying trace groups\n\n*inline (boolean)* - Displays trace code in line on the page in the\n location of the cftrace tag, addition to the debugging\n information output. **Values:** *true, false*.\n\n*text (string)* - User-defined string, which can include simple variable,\n but not complex variables such as arrays. Outputs to cflog\n text attribute\n\n*type (string)* - Corresponds to the cflog type attribute; displays an\n appropriate icon.\n\n * Information\n * Warning\n * Error\n * Fatal Information. **Default:** *information*. **Values:** *information, warning, error, fatal information*.\n\n*var (string)* - The name of a simple or complex variable to display.\n\n Useful for displaying a temporary value, or a value that\n does not display on any CFM page.\n"
    },
    {
        "prefix": "transactionCommit",
        "body": "transactionCommit()",
        "documentation": " No Help Available\n\n**USAGE:**\n*void transactionCommit()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "transactionRollback",
        "body": "transactionRollback()",
        "documentation": " Rollback current transaction\n\n**USAGE:**\n*void transactionRollback( [savepoint])*\n\n**PARAMETERS:**\n\n*savepoint (string)* - No Help Available\n"
    },
    {
        "prefix": "transactionSetSavepoint",
        "body": "transactionSetSavepoint(${1:savepoint})",
        "documentation": " Set savepoint for transaction\n\n**USAGE:**\n*void transactionSetSavepoint(savepoint)*\n\n**PARAMETERS:**\n\n*savepoint (string)* - No Help Available\n"
    },
    {
        "prefix": "trim",
        "body": "trim(${1:String})",
        "documentation": " Removes leading and trailing spaces from a string.\n\n**USAGE:**\n*string trim(String)*\n\n**PARAMETERS:**\n\n*String (string)* - A string or a variable that contains one\n"
    },
    {
        "prefix": "trueFalseFormat",
        "body": "trueFalseFormat(${1:value})",
        "documentation": "True, for a non-zero value; False, otherwise\n\n**USAGE:**\n*string trueFalseFormat(value)*\n\n**PARAMETERS:**\n\n*value (any)*\n"
    },
    {
        "prefix": "uCase",
        "body": "uCase(${1:String})",
        "documentation": " Converts the alphabetic characters in a string to uppercase.\n\n**USAGE:**\n*string uCase(String)*\n\n**PARAMETERS:**\n\n*String (string)* - A string or a variable that contains one\n"
    },
    {
        "prefix": "ucFirst",
        "body": "ucFirst(${1:string})",
        "documentation": "Transforms the first letter of a string to uppercase\n\n**USAGE:**\n*string ucFirst(string [, doAll] [, doLowerIfAllUppercase])*\n\n**PARAMETERS:**\n\n*string (string)*\n\n*doAll (boolean)*\n\n*doLowerIfAllUppercase (boolean)*\n"
    },
    {
        "prefix": "unserializeJava",
        "body": "unserializeJava(${1:string})",
        "documentation": "literal defintion of a serialized Java Object by function serialize\n\n**USAGE:**\n*any unserializeJava(string)*\n\n**PARAMETERS:**\n\n*string (string)*\n"
    },
    {
        "prefix": "urlDecode",
        "body": "urlDecode(${1:urlencodedstring})",
        "documentation": "Decodes a URL-encoded string.\n\n**USAGE:**\n*string urlDecode(urlencodedstring [, charset])*\n\n**PARAMETERS:**\n\n*urlencodedstring (string)*\n\n*charset (string)* - The character encoding in which the string is encoded. **Values:** *utf-8, iso-8859-1, windows-1252, us-ascii, shift_jis, iso-2022-jp, euc-jp, euc-kr, big5, euc-cn, utf-16*.\n"
    },
    {
        "prefix": "urlEncode",
        "body": "urlEncode(${1:string})",
        "documentation": "Returns an url-encoded string with respect to charset.\n\n**USAGE:**\n*string urlEncode(string [, charset] [, force])*\n\n**PARAMETERS:**\n\n*string (string)*\n\n*charset (string)* - The character encoding in which the string will be encoded.. **Default:** *utf-8*. **Values:** *utf-8, iso-8859-1, windows-1252, us-ascii, shift_jis, iso-2022-jp, euc-jp, euc-kr, big5, euc-cn, utf-16*.\n\n*force (boolean)*. **Default:** *true*.\n"
    },
    {
        "prefix": "urlEncodedFormat",
        "body": "urlEncodedFormat(${1:String})",
        "documentation": "Generates a URL-encoded string. For example, it replaces spaces\n with %20, and non-alphanumeric characters with equivalent\n hexadecimal escape sequences. Passes arbitrary strings within a\n URL.\n\n**USAGE:**\n*string urlEncodedFormat(String [, charset])*\n\n**PARAMETERS:**\n\n*String (string)* - A string or a variable that contains one\n\n*charset (string)* - The character encoding in which the string is encoded. **Values:** *utf-8, iso-8859-1, windows-1252, us-ascii, shift_jis, iso-2022-jp, euc-jp, euc-kr, big5, euc-cn, utf-16*.\n"
    },
    {
        "prefix": "urlSessionFormat",
        "body": "urlSessionFormat(${1|cgi.script_name|})",
        "documentation": "If the client does not accept cookies appends session identifiers `CFID`, `CFTOKEN` and / or `JSESSIONID` to the URL.\n\n**USAGE:**\n*string urlSessionFormat(requesturl)*\n\n**PARAMETERS:**\n\n*requesturl (URL)* - URL of a CFML page **Values:** *cgi.script_name*.\n"
    },
    {
        "prefix": "val",
        "body": "val(${1:String})",
        "documentation": " Converts numeric characters that occur at the beginning of a\n string to a number. If conversion fails, returns zero.\n\n**USAGE:**\n*numeric val(String)*\n\n**PARAMETERS:**\n\n*String (string)* - A string or a variable that contains one\n"
    },
    {
        "prefix": "valueArray",
        "body": "valueArray(${1:query}, ${2:column})",
        "documentation": "Returns an array of values for the given query and column.\n\n**USAGE:**\n*array valueArray(query, column)*\n\n**PARAMETERS:**\n\n*query (query)* - A query object\n\n*column (string)* - The column name whose values you want\n"
    },
    {
        "prefix": "valueList",
        "body": "valueList(${1:column})",
        "documentation": "Returns each value from a column of an executed query.\n CFML does not evaluate the arguments.\n A delimited list of the values of each record returned from an\n executed query column\n\n**USAGE:**\n*string valueList(column [, delimiter])*\n\n**PARAMETERS:**\n\n*column (QueryColumn)* - Name of an executed query and column. Separate query name\n and column name with a period.\n\n*delimiter (string)* - A delimiter character to separate column data items.\n Default: comma (,).. **Default:** *,*. **Values:** *,, |, ;, chr(9), chr(10), chr(13)*.\n"
    },
    {
        "prefix": "verifyClient",
        "body": "verifyClient()",
        "documentation": " Verifies whether request is from valid client or not\n\n**USAGE:**\n*void verifyClient()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "webserviceNew",
        "body": "webserviceNew(${1:url})",
        "documentation": "Creates a web service proxy object, a reference to a remote webservice. This function is a replacement for <code>createObject(\"webservice\",...)</code>.\n\n**USAGE:**\n*webserviceProxy webserviceNew(url [, arguments])*\n\n**PARAMETERS:**\n\n*url (string)* - URL of the Webservice\n\n*arguments (struct)* - Additional arguments\n(URL params are not allowed in url itself and must be set here)\n"
    },
    {
        "prefix": "week",
        "body": "week(${1:date})",
        "documentation": " From a date/time object, determines the week number within\n the year. An integer in the range 1-53; the ordinal of the\n week, within the year.\n\n**USAGE:**\n*numeric week(date)*\n\n**PARAMETERS:**\n\n*date (date)* - A date/time object in the range 100 AD-9999 AD.\n"
    },
    {
        "prefix": "wrap",
        "body": "wrap(${1:String}, ${2:limit})",
        "documentation": " Wraps text so that each line has a specified maximum number\n of characters.\n\n**USAGE:**\n*string wrap(String, limit [, strip])*\n\n**PARAMETERS:**\n\n*String (string)* - String or variable that contains one. The text to wrap.\n\n*limit (numeric)* - Positive integer maximum number of characters to allow on\n a line.\n\n*strip (boolean)* - whether to remove all existing newline and carriage return\n characters in the input string with spaces before wrapping\n the text. Default: False. **Values:** *true, false*.\n"
    },
    {
        "prefix": "writeBody",
        "body": "writeBody()",
        "documentation": " n/a\n\n**USAGE:**\n*void writeBody()*\n\n**PARAMETERS:**\n\n"
    },
    {
        "prefix": "writeDump",
        "body": "writeDump(${1:var})",
        "documentation": "Outputs the elements, variables and values of most kinds of CFML objects. Useful for debugging. You can display the contents of simple and complex variables, objects, components, user-defined functions, and other elements. Equivalent to the cfdump tag, useful in cfscript.\n\n**USAGE:**\n*void writeDump(var [, expand] [, format] [, abort] [, hide] [, keys] [, label] [, metainfo] [, output] [, show] [, showUDfs] [, top])*\n\n**PARAMETERS:**\n\n*var (variableName)* - Variable to display. Enclose a variable name in pound\n signs.\n\n*expand (boolean)* - Yes: In Internet Explorer and Mozilla, expands views. **Default:** *true*. **Values:** *true, false*.\n\n*format (string)* - specify whether to save the results of a cfdump to a file in text or HTML format. **Default:** *text*. **Values:** *html, text*.\n\n*abort (boolean)* - Boolean value to immediately abort after displaying the dump. **Values:** *true, false*.\n\n*hide (string)* - hide column or keys.\n\n*keys (numeric)* - For a structure, number of keys to display.\n\n*label (string)* - A string; header for the dump output.\n\n*metainfo (boolean)* - Includes information about the query in the cfdump results.. **Default:** *true*. **Values:** *true, false*.\n\n*output (string)* - Where to send the results of cfdump.. **Default:** *browser*. **Values:** *browser, console, filename*.\n\n*show (string)* - show column or keys.\n\n*showUDfs (boolean)* - show UDFs in cfdump output.. **Default:** *true*. **Values:** *true, false*.\n\n*top (numeric)* - The number of rows to display.\n"
    },
    {
        "prefix": "writeLog",
        "body": "writeLog(${1:text})",
        "documentation": "Writes a message to a log file.\n\n**USAGE:**\n*void writeLog(text [, type] [, application] [, file] [, log])*\n\n**PARAMETERS:**\n\n*text (string)* - Message to log. The date / time will be logged automatically for you.\n\n*type (string)* - Type or severity of the log message **Values:** *information, warning, error, fatal*.\n\n*application (boolean)* - Logs the application name, if it is specified in Application.cfc or a cfapplication tag.. **Default:** *true*. **Values:** *true, false*.\n\n*file (string)* - The file name to log to. You cannot specify a directory path or file extension (extension will be `.log`). If the file does not exist, it is created automatically. The log file will be located in your CF server logs directory.\n\n*log (string)* - If you omit the file attribute, writes messages to standard\n log file. Ignored, if you specify file attribute.\n\n Application: writes to Application.log, normally used for\n application-specific messages.\n Scheduler: writes to Scheduler.log, normally used to log\n the execution of scheduled tasks. **Values:** *Application, Scheduler*.\n"
    },
    {
        "prefix": "writeOutput",
        "body": "writeOutput(${1:string})",
        "documentation": " Appends text to the page-output stream.\n This function writes to the page-output stream regardless of\n conditions established by the cfsetting tag.\n\n**USAGE:**\n*string writeOutput(string [, encodeFor])*\n\n**PARAMETERS:**\n\n*string (string)* - A string, or a variable that contains one\n\n*encodeFor (string)* - CF2016+ Wraps the result with an encodeFor function. **Values:** *html, htmlattribute, javascript, css, xml, xmlattribute, url, xpath, ldap, dn*.\n"
    },
    {
        "prefix": "wsGetAllChannels",
        "body": "wsGetAllChannels()",
        "documentation": "Provides all the channels defined in the Application.cfc as an array.\n\n**USAGE:**\n*void wsGetAllChannels( [channelName])*\n\n**PARAMETERS:**\n\n*channelName ()* - If specified, returns all sub-channels listed under the entered channel name. If left unspecified, the function returns all channels registered under the current application.\n"
    },
    {
        "prefix": "wsGetSubscribers",
        "body": "wsGetSubscribers(${1:channel})",
        "documentation": "Returns an array of struct with clientID and subscriberInfo as the keys.\n\n**USAGE:**\n*array wsGetSubscribers(channel)*\n\n**PARAMETERS:**\n\n*channel ()* - Channel whose list of subscribers you wish to retrieve.\n"
    },
    {
        "prefix": "wsPublish",
        "body": "wsPublish(${1:channel}, ${2:message})",
        "documentation": " Sends messages to a specific channel based on the filter criteria (which is a struct).\n\n**USAGE:**\n*void wsPublish(channel, message [, filterCriteria])*\n\n**PARAMETERS:**\n\n*channel ()* - Specific channel to which the server publishes its response.\n\n*message ()* - Response sent by the server to all clients subscribed to a specific channel.\n\n*filterCriteria ()* - Conditions to filter eligible clients that need to be notified for a given channel.\n"
    },
    {
        "prefix": "wsSendMessage",
        "body": "wsSendMessage(${1:message})",
        "documentation": " Sends messages to a specific client that invokes the method. This can be included as a part of the function that is called by the invoke WebSocket JavaScript method.\n\n**USAGE:**\n*void wsSendMessage(message)*\n\n**PARAMETERS:**\n\n*message ()* - The message object. This can be of type Any.\n"
    },
    {
        "prefix": "xmlChildPos",
        "body": "xmlChildPos(${1:elem}, ${2:childname}, ${3:n})",
        "documentation": "Gets the position of a child element within an XML document\n object.\n The position, in an XmlChildren array, of the Nth child that\n has the specified name.\n\n**USAGE:**\n*numeric xmlChildPos(elem, childname, n)*\n\n**PARAMETERS:**\n\n*elem (xml)* - XML element within which to search\n\n*childname (string)* - XML child element for which to search\n\n*n (numeric)* - Index of XML child element for which to search\n"
    },
    {
        "prefix": "xmlElemNew",
        "body": "xmlElemNew(${1:xmlobj}, ${2:childname})",
        "documentation": "Creates an XML document object element\n\n**USAGE:**\n*xml xmlElemNew(xmlobj [, namespace], childname)*\n\n**PARAMETERS:**\n\n*xmlobj (xml)* - The name of an XML object. An XML document or an element.\n\n*namespace (string)* - URI of the namespace to which this element belongs.\n\n*childname (string)* - The name of the element to create. This element becomes a\n child element of xmlObj in the tree.\n"
    },
    {
        "prefix": "xmlFormat",
        "body": "xmlFormat(${1:String})",
        "documentation": "Escapes XML special characters in a string, so that the string is safe to use with XML.\n\n**USAGE:**\n*string xmlFormat(String [, escapeChars])*\n\n**PARAMETERS:**\n\n*String (string)* - The string to escape\n\n*escapeChars (boolean)* - When true escapes restricted characters according to the W3C XML standard.\n"
    },
    {
        "prefix": "xmlGetNodeType",
        "body": "xmlGetNodeType(${1:xmlNode})",
        "documentation": "Determines the type of an XML document object node.\n\n**USAGE:**\n*string xmlGetNodeType(xmlNode)*\n\n**PARAMETERS:**\n\n*xmlNode (xml)* - An XML DOM object node.\n"
    },
    {
        "prefix": "xmlNew",
        "body": "xmlNew()",
        "documentation": "Creates an XML document object.\n\n**USAGE:**\n*xml xmlNew( [casesensitive])*\n\n**PARAMETERS:**\n\n*casesensitive (boolean)* - Maintains the case of document elements and attributes.\n Default: false **Values:** *true, false*.\n"
    },
    {
        "prefix": "xmlParse",
        "body": "xmlParse(${1:xmlString})",
        "documentation": "Converts an XML document that is represented as a string\n variable into an XML document object.\n\n**USAGE:**\n*xml xmlParse(xmlString [, caseSensitive] [, validator])*\n\n**PARAMETERS:**\n\n*xmlString (string)* - Any of the following:\n - A string containing XML text.\n - The name of an XML file.\n - The URL of an XML file; valid protocol identifiers\n include http, https, ftp, and file.\n\n*caseSensitive (boolean)* - Maintains the case of document elements and attributes.\n Default: false **Values:** *true, false*.\n\n*validator (string)* - Any of the following:\n - The name of a Document Type Definition (DTD) or\n XML Schema file.\n - The URL of a DTD or Schema file; valid protocol\n identifiers include http, https, ftp, and file.\n - A string representation of a DTD or Schema.\n - An empty string; in this case, the XML file must\n contain an embedded DTD or Schema identifier, which\n is used to validate the document.\n"
    },
    {
        "prefix": "xmlSearch",
        "body": "xmlSearch(${1:xmldoc}, ${2:xpathstring})",
        "documentation": "Get XML values according to given XPath\n\n**USAGE:**\n*array xmlSearch(xmldoc, xpathstring)*\n\n**PARAMETERS:**\n\n*xmldoc (xml)* - XML document object\n\n*xpathstring (string)* - XPath expression\n"
    },
    {
        "prefix": "xmlTransform",
        "body": "xmlTransform(${1:xml}, ${2:xsl})",
        "documentation": "Applies an Extensible Stylesheet Language Transformation (XSLT)\n to an XML document object that is represented as a string\n variable. An XSLT converts an XML document to another format\n or representation by applying an Extensible Stylesheet\n Language (XSL) stylesheet to it.\n\n**USAGE:**\n*string xmlTransform(xml, xsl [, parameters])*\n\n**PARAMETERS:**\n\n*xml (xml)* - An XML document in string format, or an XML document object.\n\n*xsl (string)* - XSLT transformation to apply; can be any of the following:\n - A string containing XSL text.\n - The name of an XSTLT file. Relative paths start at\n the directory containing the current CFML page.\n - The URL of an XSLT file; valid protocol identifiers\n include http, https, ftp, and file. Relative paths start\n at the directory containing the current CFML page.\n\n*parameters (struct)* - A structure containing XSL template parameter name-value\n pairs to use in transforming the document. The XSL transform\n defined in the xslString parameter uses these parameter values\n in processing the xml.\n"
    },
    {
        "prefix": "xmlValidate",
        "body": "xmlValidate(${1:xmlDoc})",
        "documentation": "Uses a Document Type Definition (DTD) or XML Schema to validate an XML text document or an XML document object. Returns keys `status` (boolean), `errors` (array), `fatalerrors` (array) and `warnings` (array)\n\n**USAGE:**\n*struct xmlValidate(xmlDoc [, validator])*\n\n**PARAMETERS:**\n\n*xmlDoc (any)* - Any of the following:\n - A string containing an XML document.\n - The name of an XML file.\n - The URL of an XML file; valid protocol identifiers\n include http, https, ftp, and file.\n - An XML document object, such as one generated by\n the XmlParse function.\n\n*validator (string)* - Any of the following:\n - A string containing a DTD or Schema.\n - The name of a DTD or Schema file.\n - The URL of a DTD or Schema file; valid protocol\n identifiers include http, https, ftp, and file. If this argument is omitted the xml document must have a `!DOCTYPE` `xsi:schemaLocation` or `xsi:noNamespaceSchemaLocation` tag pointing to the DTD or schema location.\n"
    },
    {
        "prefix": "year",
        "body": "year(${1:date})",
        "documentation": " From a date/time object, gets the year value.\n\n**USAGE:**\n*numeric year(date)*\n\n**PARAMETERS:**\n\n*date (date)*\n"
    },
    {
        "prefix": "yesNoFormat",
        "body": "yesNoFormat(${1:value})",
        "documentation": " Yes, for a true value; No for a false value, empty string or null. Throws an exception for other values.\n\n**USAGE:**\n*string yesNoFormat(value)*\n\n**PARAMETERS:**\n\n*value (any)* - A Boolean value or empty string\n"
    }
]